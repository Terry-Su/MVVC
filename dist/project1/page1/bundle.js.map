{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 18584ae5e3c32cc11972","webpack:///./src/project1/page1/controller/index.web.js","webpack:///./node_modules/_inferno@3.7.1@inferno/index.js","webpack:///./node_modules/_inferno@3.7.1@inferno/dist/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_inferno","_inferno2","obj","default","createVNode","render","document","getElementById","isStatefulComponent","isUndefined","isStringOrNumber","type","isNullOrUndef","isNull","isInvalid","isTrue","isFunction","isString","isNumber","isObject","throwError","message","ERROR_MSG","Error","combineFrom","first","second","out","key","key$1","Lifecycle","this","listeners","handleEvent","lastEvent","nextEvent","dom","delegatedRoots","delegatedEvents$1","items","Map","docEvent","attachEventToDocument","set","isiOS","trapClickOnNonInteractiveElement","delete","size","removeEventListener","normalizeEventName","dispatchEvents","event","target","count","isClick","eventData","eventsToTrigger","data","cancelBubble","parentNode","disabled","substr","toLowerCase","stopPropagation","stopImmediatePropagation","e","addEventListener","emptyFn","onclick","isCheckedType","onTextInputChange","vNode","props","EMPTY_OBJ","previousValue","value","onInput","oninput","newVNode","newProps","applyValue","wrappedOnChange","onChange","onCheckboxChange","onClick","processInput","nextPropsOrEmpty","mounting","isControlled","wrapped","onchange","checked","multiple","defaultValue","hasValue","setAttribute","updateChildOptionGroup","children","isArray","len","length","updateChildOption","isVNode","indexOf","selected","onSelectChange","applyValue$1","processSelect","wrappedOnChange$1","onTextareaInputChange","applyValue$2","processTextarea","domValue","processElement","flags","isControlledFormElement","normalizeChildNodes","parentDom","firstChild","nodeType","placeholder","createTextNode","replaceChild","nextSibling","lastDom","previousSibling","removeChild","hydrateComponent","lifecycle","context","isSVG","isClass","ref","_isSVG","namespaceURI","svgNS","instance","createClassComponentInstance","input","_lastInput","_vNode","hydrate","_childContext","mountClassComponentCallbacks","_updating","options","findDOMNodeEnabled","componentToDOMNodeMap","input$1","createFunctionalComponentInput","mountFunctionalComponentCallbacks","hydrateElement","className","tagName","newDom","mountElement","textContent","hydrateChildren","hasControlledValue","isFormElement","prop","patchProp","removeAttribute","mountRef","appendChild","nodeValue","child","mount","nextSibling$1","hydrateText","mountText","text","hydrateVoid","hydrateRoot","recycleElement","tag","pools","elementPools","pool","nonKeyed","keyed","recycledVNode","pop","patchElement","poolElement","push","recycleComponent","componentPools","patchComponent","poolComponent","hooks","onComponentWillMount","onComponentWillUnmount","onComponentDidMount","onComponentWillUpdate","onComponentDidUpdate","unmount","canRecycle","isRecycling","unmountComponent","unmountElement","unmountVoidOrText","isStatefulComponent$$1","_unmounted","beforeUnmount","componentWillUnmount","_lifecycle","recyclingEnabled","unmountRef","unmountChildren$1","isAttrAnEvent","patchEvent","findDOMNode","getRoot","roots","root","setRoot","removeRoot","splice","documentBody","NO_OP","directClone","trigger","lifecycle$1","patch","rootInput","createRenderer","lastInput","nextInput","lastVNode","nextVNode","lastFlags","nextFlags","replaceVNode","mountComponent","patchText","patchVoid","mountVoid","replaceLastChildAndUnmount","unmountChildren","removeAllChildren","nextTag","replaceWithNewNode","lastProps","nextProps","lastChildren","nextChildren","nextRef","lastClassName","nextClassName","patchChildren","lastPropsOrEmpty","nextValue","prop$1","removeProp","patchArray","patchKeyed","setTextContent","mountArrayChildren","updateTextContent","isKeyed","patchKeyedChildren","patchNonKeyedChildren","lastType","nextType","lastKey","nextKey","childContext","hasComponentDidUpdate","componentDidUpdate","nextState","state","lastState","getChildContext","_updateComponent","didUpdate","createVoidVNode","createTextVNode","parentVNode","afterUpdate","shouldUpdate","lastProps$1","nextHooks","nextHooksDefined","lastInput$1","nextInput$1","onComponentShouldUpdate","nextText","lastChildrenLength","nextChildrenLength","commonLength","nextChild","nextChild$1","a","b","j","aNode","bNode","nextNode","nextPos","node","aLength","bLength","aEnd","bEnd","aStart","bStart","aStartNode","bStartNode","aEndNode","bEndNode","outer","insertOrAppend","sources","Array","moved","pos","patched","keyIndex","seq","lis_algorithm","arr","u","v","slice","result","arrI","attr","lastValue","skipProps","has","booleanProps","strictProps","patchStyle","lastHtml","__html","nextHtml","innerHTML","namespaces","setAttributeNS","delegatedEvents","nameLowerCase","domEvent","linkEvent","lastAttrValue","nextAttrValue","style","domStyle","cssText","isUnitlessNumber","documentCreateElement","childrenIsSVG","hasDidMount","componentDidMount","afterMount","addListener","Component","_blockSetState","_pendingSetState","componentWillMount","_blockRender","beforeRender","afterRender","component","newNode","insertBefore","createElementNS","createElement","lastNode","nextDom","removeChildren","VNode","noNormalise","normalize","vNodeToClone","propsToClone","newChildren","tmpArray","props$1","propsToClone$1","cloneVNode","_children","len$2","arguments","childrenLen","len$1","tmpArray$1","i$1","applyKey","applyKeyIfMissing","applyKeyPrefix","_normalizeVNodes","nodes","index","currentKey","normalizeVNodes","newNodes","normalizeChildren","normalizeProps","getFlagsForElementVnode","defaultProps","isBrowser","window","callback","listener","shift","xlinkNS","xmlNS","Set","add","navigator","platform","test","body","internal_DOMNodeMap","internal_isUnitlessNumber","internal_normalize","internal_patch","version"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _inferno = __webpack_require__(1);\n\nvar _inferno2 = _interopRequireDefault(_inferno);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar createVNode = _inferno2.default.createVNode;\n\n\n(0, _inferno.render)(createVNode(2, 'div', null, '123'), document.getElementById('app'));\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(2).default;\nmodule.exports.default = module.exports;\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * @module Inferno-Shared\r\n */ /** TypeDoc Comment */\r\nvar NO_OP = \"$NO_OP\";\r\nvar ERROR_MSG = \"a runtime error occured! Use Inferno in development environment to find the error.\";\r\n// This should be boolean and not reference to window.document\r\nvar isBrowser = !!(typeof window !== \"undefined\" && window.document);\r\n// this is MUCH faster than .constructor === Array and instanceof Array\r\n// in Node 7 and the later versions of V8, slower in older versions though\r\nvar isArray = Array.isArray;\r\nfunction isStatefulComponent(o) {\r\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\r\n}\r\nfunction isStringOrNumber(o) {\r\n    var type = typeof o;\r\n    return type === \"string\" || type === \"number\";\r\n}\r\nfunction isNullOrUndef(o) {\r\n    return isUndefined(o) || isNull(o);\r\n}\r\nfunction isInvalid(o) {\r\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\r\n}\r\nfunction isFunction(o) {\r\n    return typeof o === \"function\";\r\n}\r\nfunction isString(o) {\r\n    return typeof o === \"string\";\r\n}\r\nfunction isNumber(o) {\r\n    return typeof o === \"number\";\r\n}\r\nfunction isNull(o) {\r\n    return o === null;\r\n}\r\nfunction isTrue(o) {\r\n    return o === true;\r\n}\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\r\nfunction isObject(o) {\r\n    return typeof o === \"object\";\r\n}\r\nfunction throwError(message) {\r\n    if (!message) {\r\n        message = ERROR_MSG;\r\n    }\r\n    throw new Error((\"Inferno Error: \" + message));\r\n}\r\nfunction warning(message) {\r\n    // tslint:disable-next-line:no-console\r\n    console.warn(message);\r\n}\r\nfunction combineFrom(first, second) {\r\n    var out = {};\r\n    if (first) {\r\n        for (var key in first) {\r\n            out[key] = first[key];\r\n        }\r\n    }\r\n    if (second) {\r\n        for (var key$1 in second) {\r\n            out[key$1] = second[key$1];\r\n        }\r\n    }\r\n    return out;\r\n}\r\nfunction Lifecycle() {\r\n    this.listeners = [];\r\n}\r\nLifecycle.prototype.addListener = function addListener(callback) {\r\n    this.listeners.push(callback);\r\n};\r\nLifecycle.prototype.trigger = function trigger() {\r\n    var listeners = this.listeners;\r\n    var listener;\r\n    // We need to remove current listener from array when calling it, because more listeners might be added\r\n    while ((listener = listeners.shift())) {\r\n        listener();\r\n    }\r\n};\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar options = {\r\n    afterMount: null,\r\n    afterRender: null,\r\n    afterUpdate: null,\r\n    beforeRender: null,\r\n    beforeUnmount: null,\r\n    createVNode: null,\r\n    findDOMNodeEnabled: false,\r\n    recyclingEnabled: false,\r\n    roots: []\r\n};\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar xlinkNS = \"http://www.w3.org/1999/xlink\";\r\nvar xmlNS = \"http://www.w3.org/XML/1998/namespace\";\r\nvar svgNS = \"http://www.w3.org/2000/svg\";\r\nvar strictProps = new Set();\r\nstrictProps.add(\"volume\");\r\nstrictProps.add(\"defaultChecked\");\r\nvar booleanProps = new Set();\r\nbooleanProps.add(\"muted\");\r\nbooleanProps.add(\"scoped\");\r\nbooleanProps.add(\"loop\");\r\nbooleanProps.add(\"open\");\r\nbooleanProps.add(\"checked\");\r\nbooleanProps.add(\"default\");\r\nbooleanProps.add(\"capture\");\r\nbooleanProps.add(\"disabled\");\r\nbooleanProps.add(\"readOnly\");\r\nbooleanProps.add(\"required\");\r\nbooleanProps.add(\"autoplay\");\r\nbooleanProps.add(\"controls\");\r\nbooleanProps.add(\"seamless\");\r\nbooleanProps.add(\"reversed\");\r\nbooleanProps.add(\"allowfullscreen\");\r\nbooleanProps.add(\"novalidate\");\r\nbooleanProps.add(\"hidden\");\r\nbooleanProps.add(\"autoFocus\");\r\nbooleanProps.add(\"selected\");\r\nbooleanProps.add(\"indeterminate\");\r\nvar namespaces = new Map();\r\nnamespaces.set(\"xlink:href\", xlinkNS);\r\nnamespaces.set(\"xlink:arcrole\", xlinkNS);\r\nnamespaces.set(\"xlink:actuate\", xlinkNS);\r\nnamespaces.set(\"xlink:show\", xlinkNS);\r\nnamespaces.set(\"xlink:role\", xlinkNS);\r\nnamespaces.set(\"xlink:title\", xlinkNS);\r\nnamespaces.set(\"xlink:type\", xlinkNS);\r\nnamespaces.set(\"xml:base\", xmlNS);\r\nnamespaces.set(\"xml:lang\", xmlNS);\r\nnamespaces.set(\"xml:space\", xmlNS);\r\nvar isUnitlessNumber = new Set();\r\nisUnitlessNumber.add(\"animationIterationCount\");\r\nisUnitlessNumber.add(\"borderImageOutset\");\r\nisUnitlessNumber.add(\"borderImageSlice\");\r\nisUnitlessNumber.add(\"borderImageWidth\");\r\nisUnitlessNumber.add(\"boxFlex\");\r\nisUnitlessNumber.add(\"boxFlexGroup\");\r\nisUnitlessNumber.add(\"boxOrdinalGroup\");\r\nisUnitlessNumber.add(\"columnCount\");\r\nisUnitlessNumber.add(\"flex\");\r\nisUnitlessNumber.add(\"flexGrow\");\r\nisUnitlessNumber.add(\"flexPositive\");\r\nisUnitlessNumber.add(\"flexShrink\");\r\nisUnitlessNumber.add(\"flexNegative\");\r\nisUnitlessNumber.add(\"flexOrder\");\r\nisUnitlessNumber.add(\"gridRow\");\r\nisUnitlessNumber.add(\"gridColumn\");\r\nisUnitlessNumber.add(\"fontWeight\");\r\nisUnitlessNumber.add(\"lineClamp\");\r\nisUnitlessNumber.add(\"lineHeight\");\r\nisUnitlessNumber.add(\"opacity\");\r\nisUnitlessNumber.add(\"order\");\r\nisUnitlessNumber.add(\"orphans\");\r\nisUnitlessNumber.add(\"tabSize\");\r\nisUnitlessNumber.add(\"widows\");\r\nisUnitlessNumber.add(\"zIndex\");\r\nisUnitlessNumber.add(\"zoom\");\r\nisUnitlessNumber.add(\"fillOpacity\");\r\nisUnitlessNumber.add(\"floodOpacity\");\r\nisUnitlessNumber.add(\"stopOpacity\");\r\nisUnitlessNumber.add(\"strokeDasharray\");\r\nisUnitlessNumber.add(\"strokeDashoffset\");\r\nisUnitlessNumber.add(\"strokeMiterlimit\");\r\nisUnitlessNumber.add(\"strokeOpacity\");\r\nisUnitlessNumber.add(\"strokeWidth\");\r\nvar skipProps = new Set();\r\nskipProps.add(\"children\");\r\nskipProps.add(\"childrenType\");\r\nskipProps.add(\"defaultValue\");\r\nskipProps.add(\"ref\");\r\nskipProps.add(\"key\");\r\nskipProps.add(\"checked\");\r\nskipProps.add(\"multiple\");\r\nvar delegatedEvents = new Set();\r\ndelegatedEvents.add(\"onClick\");\r\ndelegatedEvents.add(\"onMouseDown\");\r\ndelegatedEvents.add(\"onMouseUp\");\r\ndelegatedEvents.add(\"onMouseMove\");\r\ndelegatedEvents.add(\"onSubmit\");\r\ndelegatedEvents.add(\"onDblClick\");\r\ndelegatedEvents.add(\"onKeyDown\");\r\ndelegatedEvents.add(\"onKeyUp\");\r\ndelegatedEvents.add(\"onKeyPress\");\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar isiOS = isBrowser &&\r\n    !!navigator.platform &&\r\n    /iPad|iPhone|iPod/.test(navigator.platform);\r\nvar delegatedEvents$1 = new Map();\r\nfunction handleEvent(name, lastEvent, nextEvent, dom) {\r\n    var delegatedRoots = delegatedEvents$1.get(name);\r\n    if (nextEvent) {\r\n        if (!delegatedRoots) {\r\n            delegatedRoots = { items: new Map(), docEvent: null };\r\n            delegatedRoots.docEvent = attachEventToDocument(name, delegatedRoots);\r\n            delegatedEvents$1.set(name, delegatedRoots);\r\n        }\r\n        if (!lastEvent) {\r\n            if (isiOS && name === \"onClick\") {\r\n                trapClickOnNonInteractiveElement(dom);\r\n            }\r\n        }\r\n        delegatedRoots.items.set(dom, nextEvent);\r\n    }\r\n    else if (delegatedRoots) {\r\n        var items = delegatedRoots.items;\r\n        if (items.delete(dom)) {\r\n            // If any items were deleted, check if listener need to be removed\r\n            if (items.size === 0) {\r\n                document.removeEventListener(normalizeEventName(name), delegatedRoots.docEvent);\r\n                delegatedEvents$1.delete(name);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction dispatchEvents(event, target, items, count, isClick, eventData) {\r\n    var dom = target;\r\n    while (count > 0) {\r\n        var eventsToTrigger = items.get(dom);\r\n        if (eventsToTrigger) {\r\n            count--;\r\n            // linkEvent object\r\n            eventData.dom = dom;\r\n            if (eventsToTrigger.event) {\r\n                eventsToTrigger.event(eventsToTrigger.data, event);\r\n            }\r\n            else {\r\n                eventsToTrigger(event);\r\n            }\r\n            if (event.cancelBubble) {\r\n                return;\r\n            }\r\n        }\r\n        dom = dom.parentNode;\r\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\r\n        // because the event listener is on document.body\r\n        // Don't process clicks on disabled elements\r\n        if (dom === null || (isClick && dom.disabled)) {\r\n            return;\r\n        }\r\n    }\r\n}\r\nfunction normalizeEventName(name) {\r\n    return name.substr(2).toLowerCase();\r\n}\r\nfunction stopPropagation() {\r\n    this.cancelBubble = true;\r\n    this.stopImmediatePropagation();\r\n}\r\nfunction attachEventToDocument(name, delegatedRoots) {\r\n    var docEvent = function (event) {\r\n        var count = delegatedRoots.items.size;\r\n        if (count > 0) {\r\n            event.stopPropagation = stopPropagation;\r\n            // Event data needs to be object to save reference to currentTarget getter\r\n            var eventData = {\r\n                dom: document\r\n            };\r\n            try {\r\n                Object.defineProperty(event, \"currentTarget\", {\r\n                    configurable: true,\r\n                    get: function get() {\r\n                        return eventData.dom;\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                /* safari7 and phantomJS will crash */\r\n            }\r\n            dispatchEvents(event, event.target, delegatedRoots.items, count, event.type === \"click\", eventData);\r\n        }\r\n    };\r\n    document.addEventListener(normalizeEventName(name), docEvent);\r\n    return docEvent;\r\n}\r\n// tslint:disable-next-line:no-empty\r\nfunction emptyFn() { }\r\nfunction trapClickOnNonInteractiveElement(dom) {\r\n    // Mobile Safari does not fire properly bubble click events on\r\n    // non-interactive elements, which means delegated click listeners do not\r\n    // fire. The workaround for this bug involves attaching an empty click\r\n    // listener on the target node.\r\n    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\r\n    // Just set it using the onclick property so that we don't have to manage any\r\n    // bookkeeping for it. Not sure if we need to clear it when the listener is\r\n    // removed.\r\n    // TODO: Only do this for the relevant Safaris maybe?\r\n    dom.onclick = emptyFn;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction isCheckedType(type) {\r\n    return type === \"checkbox\" || type === \"radio\";\r\n}\r\nfunction onTextInputChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    var previousValue = props.value;\r\n    if (props.onInput) {\r\n        var event = props.onInput;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.oninput) {\r\n        props.oninput(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue(newProps, dom);\r\n    }\r\n}\r\nfunction wrappedOnChange(e) {\r\n    var props = this.vNode.props || EMPTY_OBJ;\r\n    var event = props.onChange;\r\n    if (event.event) {\r\n        event.event(event.data, e);\r\n    }\r\n    else {\r\n        event(e);\r\n    }\r\n}\r\nfunction onCheckboxChange(e) {\r\n    e.stopPropagation(); // This click should not propagate its for internal use\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    if (props.onClick) {\r\n        var event = props.onClick;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.onclick) {\r\n        props.onclick(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    applyValue(newProps, dom);\r\n}\r\nfunction processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue(nextPropsOrEmpty, dom);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            if (isCheckedType(nextPropsOrEmpty.type)) {\r\n                dom.onclick = onCheckboxChange;\r\n                dom.onclick.wrapped = true;\r\n            }\r\n            else {\r\n                dom.oninput = onTextInputChange;\r\n                dom.oninput.wrapped = true;\r\n            }\r\n            if (nextPropsOrEmpty.onChange) {\r\n                dom.onchange = wrappedOnChange;\r\n                dom.onchange.wrapped = true;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyValue(nextPropsOrEmpty, dom) {\r\n    var type = nextPropsOrEmpty.type;\r\n    var value = nextPropsOrEmpty.value;\r\n    var checked = nextPropsOrEmpty.checked;\r\n    var multiple = nextPropsOrEmpty.multiple;\r\n    var defaultValue = nextPropsOrEmpty.defaultValue;\r\n    var hasValue = !isNullOrUndef(value);\r\n    if (type && type !== dom.type) {\r\n        dom.setAttribute(\"type\", type);\r\n    }\r\n    if (multiple && multiple !== dom.multiple) {\r\n        dom.multiple = multiple;\r\n    }\r\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\r\n        dom.defaultValue = defaultValue + \"\";\r\n    }\r\n    if (isCheckedType(type)) {\r\n        if (hasValue) {\r\n            dom.value = value;\r\n        }\r\n        if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n    else {\r\n        if (hasValue && dom.value !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n        else if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction updateChildOptionGroup(vNode, value) {\r\n    var type = vNode.type;\r\n    if (type === \"optgroup\") {\r\n        var children = vNode.children;\r\n        if (isArray(children)) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOption(children[i], value);\r\n            }\r\n        }\r\n        else if (isVNode(children)) {\r\n            updateChildOption(children, value);\r\n        }\r\n    }\r\n    else {\r\n        updateChildOption(vNode, value);\r\n    }\r\n}\r\nfunction updateChildOption(vNode, value) {\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    // we do this as multiple may have changed\r\n    dom.value = props.value;\r\n    if ((isArray(value) && value.indexOf(props.value) !== -1) ||\r\n        props.value === value) {\r\n        dom.selected = true;\r\n    }\r\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\r\n        dom.selected = props.selected || false;\r\n    }\r\n}\r\nfunction onSelectChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    var previousValue = props.value;\r\n    if (props.onChange) {\r\n        var event = props.onChange;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.onchange) {\r\n        props.onchange(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue$1(newVNode, dom, newProps, false);\r\n    }\r\n}\r\nfunction processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue$1(vNode, dom, nextPropsOrEmpty, mounting);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            dom.onchange = onSelectChange;\r\n            dom.onchange.wrapped = true;\r\n        }\r\n    }\r\n}\r\nfunction applyValue$1(vNode, dom, nextPropsOrEmpty, mounting) {\r\n    if (nextPropsOrEmpty.multiple !== dom.multiple) {\r\n        dom.multiple = nextPropsOrEmpty.multiple;\r\n    }\r\n    var children = vNode.children;\r\n    if (!isInvalid(children)) {\r\n        var value = nextPropsOrEmpty.value;\r\n        if (mounting && isNullOrUndef(value)) {\r\n            value = nextPropsOrEmpty.defaultValue;\r\n        }\r\n        if (isArray(children)) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOptionGroup(children[i], value);\r\n            }\r\n        }\r\n        else if (isVNode(children)) {\r\n            updateChildOptionGroup(children, value);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction wrappedOnChange$1(e) {\r\n    var props = this.vNode.props || EMPTY_OBJ;\r\n    var event = props.onChange;\r\n    if (event.event) {\r\n        event.event(event.data, e);\r\n    }\r\n    else {\r\n        event(e);\r\n    }\r\n}\r\nfunction onTextareaInputChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var previousValue = props.value;\r\n    if (props.onInput) {\r\n        var event = props.onInput;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.oninput) {\r\n        props.oninput(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue$2(newVNode, vNode.dom, false);\r\n    }\r\n}\r\nfunction processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue$2(nextPropsOrEmpty, dom, mounting);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            dom.oninput = onTextareaInputChange;\r\n            dom.oninput.wrapped = true;\r\n            if (nextPropsOrEmpty.onChange) {\r\n                dom.onchange = wrappedOnChange$1;\r\n                dom.onchange.wrapped = true;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyValue$2(nextPropsOrEmpty, dom, mounting) {\r\n    var value = nextPropsOrEmpty.value;\r\n    var domValue = dom.value;\r\n    if (isNullOrUndef(value)) {\r\n        if (mounting) {\r\n            var defaultValue = nextPropsOrEmpty.defaultValue;\r\n            if (!isNullOrUndef(defaultValue)) {\r\n                if (defaultValue !== domValue) {\r\n                    dom.defaultValue = defaultValue;\r\n                    dom.value = defaultValue;\r\n                }\r\n            }\r\n            else if (domValue !== \"\") {\r\n                dom.defaultValue = \"\";\r\n                dom.value = \"\";\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        /* There is value so keep it controlled */\r\n        if (domValue !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * There is currently no support for switching same input between controlled and nonControlled\r\n * If that ever becomes a real issue, then re design controlled elements\r\n * Currently user must choose either controlled or non-controlled and stick with that\r\n */\r\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    if (flags & 512 /* InputElement */) {\r\n        processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n    if (flags & 2048 /* SelectElement */) {\r\n        processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n    if (flags & 1024 /* TextareaElement */) {\r\n        processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n}\r\nfunction isControlledFormElement(nextPropsOrEmpty) {\r\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type)\r\n        ? !isNullOrUndef(nextPropsOrEmpty.checked)\r\n        : !isNullOrUndef(nextPropsOrEmpty.value);\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction normalizeChildNodes(parentDom) {\r\n    var dom = parentDom.firstChild;\r\n    while (dom) {\r\n        if (dom.nodeType === 8) {\r\n            if (dom.data === \"!\") {\r\n                var placeholder = document.createTextNode(\"\");\r\n                parentDom.replaceChild(placeholder, dom);\r\n                dom = dom.nextSibling;\r\n            }\r\n            else {\r\n                var lastDom = dom.previousSibling;\r\n                parentDom.removeChild(dom);\r\n                dom = lastDom || parentDom.firstChild;\r\n            }\r\n        }\r\n        else {\r\n            dom = dom.nextSibling;\r\n        }\r\n    }\r\n}\r\nfunction hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {\r\n    var type = vNode.type;\r\n    var ref = vNode.ref;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    if (isClass) {\r\n        var _isSVG = dom.namespaceURI === svgNS;\r\n        var instance = createClassComponentInstance(vNode, type, props, context, _isSVG, lifecycle);\r\n        var input = instance._lastInput;\r\n        instance._vNode = vNode;\r\n        hydrate(input, dom, lifecycle, instance._childContext, _isSVG);\r\n        vNode.dom = input.dom;\r\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\r\n        instance._updating = false; // Mount finished allow going sync\r\n        if (options.findDOMNodeEnabled) {\r\n            componentToDOMNodeMap.set(instance, dom);\r\n        }\r\n    }\r\n    else {\r\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\r\n        hydrate(input$1, dom, lifecycle, context, isSVG);\r\n        vNode.children = input$1;\r\n        vNode.dom = input$1.dom;\r\n        mountFunctionalComponentCallbacks(props, ref, dom, lifecycle);\r\n    }\r\n    return dom;\r\n}\r\nfunction hydrateElement(vNode, dom, lifecycle, context, isSVG) {\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var flags = vNode.flags;\r\n    var ref = vNode.ref;\r\n    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;\r\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {\r\n        if (false) {\r\n            warning(\"Inferno hydration: Server-side markup doesn't match client-side markup or Initial render target is not empty\");\r\n        }\r\n        var newDom = mountElement(vNode, null, lifecycle, context, isSVG);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n        return newDom;\r\n    }\r\n    vNode.dom = dom;\r\n    if (!isInvalid(children)) {\r\n        hydrateChildren(children, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (dom.firstChild !== null) {\r\n        dom.textContent = \"\"; // dom has content, but VNode has no children remove everything from DOM\r\n    }\r\n    if (props) {\r\n        var hasControlledValue = false;\r\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\r\n        if (isFormElement) {\r\n            hasControlledValue = isControlledFormElement(props);\r\n        }\r\n        for (var prop in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\r\n        }\r\n        if (isFormElement) {\r\n            processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n        }\r\n    }\r\n    if (!isNullOrUndef(className)) {\r\n        if (isSVG) {\r\n            dom.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    else {\r\n        if (dom.className !== \"\") {\r\n            dom.removeAttribute(\"class\");\r\n        }\r\n    }\r\n    if (ref) {\r\n        mountRef(dom, ref, lifecycle);\r\n    }\r\n    return dom;\r\n}\r\nfunction hydrateChildren(children, parentDom, lifecycle, context, isSVG) {\r\n    normalizeChildNodes(parentDom);\r\n    var dom = parentDom.firstChild;\r\n    if (isStringOrNumber(children)) {\r\n        if (!isNull(dom) && dom.nodeType === 3) {\r\n            if (dom.nodeValue !== children) {\r\n                dom.nodeValue = children;\r\n            }\r\n        }\r\n        else if (children === \"\") {\r\n            parentDom.appendChild(document.createTextNode(\"\"));\r\n        }\r\n        else {\r\n            parentDom.textContent = children;\r\n        }\r\n        if (!isNull(dom)) {\r\n            dom = dom.nextSibling;\r\n        }\r\n    }\r\n    else if (isArray(children)) {\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            if (!isNull(child) && isObject(child)) {\r\n                if (!isNull(dom)) {\r\n                    var nextSibling = dom.nextSibling;\r\n                    hydrate(child, dom, lifecycle, context, isSVG);\r\n                    dom = nextSibling;\r\n                }\r\n                else {\r\n                    mount(child, parentDom, lifecycle, context, isSVG);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // It's VNode\r\n        if (!isNull(dom)) {\r\n            hydrate(children, dom, lifecycle, context, isSVG);\r\n            dom = dom.nextSibling;\r\n        }\r\n        else {\r\n            mount(children, parentDom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    // clear any other DOM nodes, there should be only a single entry for the root\r\n    while (dom) {\r\n        var nextSibling$1 = dom.nextSibling;\r\n        parentDom.removeChild(dom);\r\n        dom = nextSibling$1;\r\n    }\r\n}\r\nfunction hydrateText(vNode, dom) {\r\n    if (dom.nodeType !== 3) {\r\n        var newDom = mountText(vNode, null);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n        return newDom;\r\n    }\r\n    var text = vNode.children;\r\n    if (dom.nodeValue !== text) {\r\n        dom.nodeValue = text;\r\n    }\r\n    vNode.dom = dom;\r\n    return dom;\r\n}\r\nfunction hydrateVoid(vNode, dom) {\r\n    vNode.dom = dom;\r\n    return dom;\r\n}\r\nfunction hydrate(vNode, dom, lifecycle, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 28 /* Component */) {\r\n        hydrateComponent(vNode, dom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        hydrateElement(vNode, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        hydrateText(vNode, dom);\r\n    }\r\n    else if (flags & 4096 /* Void */) {\r\n        hydrateVoid(vNode, dom);\r\n    }\r\n    else {\r\n        if (false) {\r\n            throwError((\"hydrate() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\r\n        }\r\n        throwError();\r\n    }\r\n}\r\nfunction hydrateRoot(input, parentDom, lifecycle) {\r\n    if (!isNull(parentDom)) {\r\n        var dom = parentDom.firstChild;\r\n        if (!isNull(dom)) {\r\n            hydrate(input, dom, lifecycle, EMPTY_OBJ, false);\r\n            dom = parentDom.firstChild;\r\n            // clear any other DOM nodes, there should be only a single entry for the root\r\n            while ((dom = dom.nextSibling)) {\r\n                parentDom.removeChild(dom);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar componentPools = new Map();\r\nvar elementPools = new Map();\r\nfunction recycleElement(vNode, lifecycle, context, isSVG) {\r\n    var tag = vNode.type;\r\n    var pools = elementPools.get(tag);\r\n    if (!isUndefined(pools)) {\r\n        var key = vNode.key;\r\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\r\n        if (!isUndefined(pool)) {\r\n            var recycledVNode = pool.pop();\r\n            if (!isUndefined(recycledVNode)) {\r\n                patchElement(recycledVNode, vNode, null, lifecycle, context, isSVG, true);\r\n                return vNode.dom;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction poolElement(vNode) {\r\n    var tag = vNode.type;\r\n    var key = vNode.key;\r\n    var pools = elementPools.get(tag);\r\n    if (isUndefined(pools)) {\r\n        pools = {\r\n            keyed: new Map(),\r\n            nonKeyed: []\r\n        };\r\n        elementPools.set(tag, pools);\r\n    }\r\n    if (isNull(key)) {\r\n        pools.nonKeyed.push(vNode);\r\n    }\r\n    else {\r\n        var pool = pools.keyed.get(key);\r\n        if (isUndefined(pool)) {\r\n            pool = [];\r\n            pools.keyed.set(key, pool);\r\n        }\r\n        pool.push(vNode);\r\n    }\r\n}\r\nfunction recycleComponent(vNode, lifecycle, context, isSVG) {\r\n    var type = vNode.type;\r\n    var pools = componentPools.get(type);\r\n    if (!isUndefined(pools)) {\r\n        var key = vNode.key;\r\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\r\n        if (!isUndefined(pool)) {\r\n            var recycledVNode = pool.pop();\r\n            if (!isUndefined(recycledVNode)) {\r\n                var flags = vNode.flags;\r\n                var failed = patchComponent(recycledVNode, vNode, null, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0, true);\r\n                if (!failed) {\r\n                    return vNode.dom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction poolComponent(vNode) {\r\n    var hooks = vNode.ref;\r\n    var nonRecycleHooks = hooks &&\r\n        (hooks.onComponentWillMount ||\r\n            hooks.onComponentWillUnmount ||\r\n            hooks.onComponentDidMount ||\r\n            hooks.onComponentWillUpdate ||\r\n            hooks.onComponentDidUpdate);\r\n    if (nonRecycleHooks) {\r\n        return;\r\n    }\r\n    var type = vNode.type;\r\n    var key = vNode.key;\r\n    var pools = componentPools.get(type);\r\n    if (isUndefined(pools)) {\r\n        pools = {\r\n            keyed: new Map(),\r\n            nonKeyed: []\r\n        };\r\n        componentPools.set(type, pools);\r\n    }\r\n    if (isNull(key)) {\r\n        pools.nonKeyed.push(vNode);\r\n    }\r\n    else {\r\n        var pool = pools.keyed.get(key);\r\n        if (isUndefined(pool)) {\r\n            pool = [];\r\n            pools.keyed.set(key, pool);\r\n        }\r\n        pool.push(vNode);\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction unmount(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var flags = vNode.flags;\r\n    if (flags & 28 /* Component */) {\r\n        unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling);\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling);\r\n    }\r\n    else if (flags & (1 /* Text */ | 4096 /* Void */)) {\r\n        unmountVoidOrText(vNode, parentDom);\r\n    }\r\n}\r\nfunction unmountVoidOrText(vNode, parentDom) {\r\n    if (!isNull(parentDom)) {\r\n        removeChild(parentDom, vNode.dom);\r\n    }\r\n}\r\nfunction unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var instance = vNode.children;\r\n    var flags = vNode.flags;\r\n    var isStatefulComponent$$1 = flags & 4;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var ref = vNode.ref;\r\n    var dom = vNode.dom;\r\n    if (!isRecycling) {\r\n        if (isStatefulComponent$$1) {\r\n            if (!instance._unmounted) {\r\n                if (!isNull(options.beforeUnmount)) {\r\n                    options.beforeUnmount(vNode);\r\n                }\r\n                if (!isUndefined(instance.componentWillUnmount)) {\r\n                    instance.componentWillUnmount();\r\n                }\r\n                if (ref && !isRecycling) {\r\n                    ref(null);\r\n                }\r\n                instance._unmounted = true;\r\n                if (options.findDOMNodeEnabled) {\r\n                    componentToDOMNodeMap.delete(instance);\r\n                }\r\n                unmount(instance._lastInput, null, instance._lifecycle, false, isRecycling);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndef(ref)) {\r\n                if (!isNullOrUndef(ref.onComponentWillUnmount)) {\r\n                    ref.onComponentWillUnmount(dom, props);\r\n                }\r\n            }\r\n            unmount(instance, null, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n    if (parentDom) {\r\n        removeChild(parentDom, dom);\r\n    }\r\n    if (options.recyclingEnabled &&\r\n        !isStatefulComponent$$1 &&\r\n        (parentDom || canRecycle)) {\r\n        poolComponent(vNode);\r\n    }\r\n}\r\nfunction unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var dom = vNode.dom;\r\n    var ref = vNode.ref;\r\n    var props = vNode.props;\r\n    if (ref && !isRecycling) {\r\n        unmountRef(ref);\r\n    }\r\n    var children = vNode.children;\r\n    if (!isNullOrUndef(children)) {\r\n        unmountChildren$1(children, lifecycle, isRecycling);\r\n    }\r\n    if (!isNull(props)) {\r\n        for (var name in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            if (props[name] !== null && isAttrAnEvent(name)) {\r\n                patchEvent(name, props[name], null, dom);\r\n                // We need to set this null, because same props otherwise come back if SCU returns false and we are recyling\r\n                props[name] = null;\r\n            }\r\n        }\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        removeChild(parentDom, dom);\r\n    }\r\n    if (options.recyclingEnabled && (parentDom || canRecycle)) {\r\n        poolElement(vNode);\r\n    }\r\n}\r\nfunction unmountChildren$1(children, lifecycle, isRecycling) {\r\n    if (isArray(children)) {\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            if (!isInvalid(child) && isObject(child)) {\r\n                unmount(child, null, lifecycle, false, isRecycling);\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(children)) {\r\n        unmount(children, null, lifecycle, false, isRecycling);\r\n    }\r\n}\r\nfunction unmountRef(ref) {\r\n    if (isFunction(ref)) {\r\n        ref(null);\r\n    }\r\n    else {\r\n        if (isInvalid(ref)) {\r\n            return;\r\n        }\r\n        if (false) {\r\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n        }\r\n        throwError();\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n// rather than use a Map, like we did before, we can use an array here\r\n// given there shouldn't be THAT many roots on the page, the difference\r\n// in performance is huge: https://esbench.com/bench/5802a691330ab09900a1a2da\r\nvar componentToDOMNodeMap = new Map();\r\nvar roots = options.roots;\r\n/**\r\n * When inferno.options.findDOMNOdeEnabled is true, this function will return DOM Node by component instance\r\n * @param ref Component instance\r\n * @returns {*|null} returns dom node\r\n */\r\nfunction findDOMNode(ref) {\r\n    if (!options.findDOMNodeEnabled) {\r\n        if (false) {\r\n            throwError(\"findDOMNode() has been disabled, use Inferno.options.findDOMNodeEnabled = true; enabled findDOMNode(). Warning this can significantly impact performance!\");\r\n        }\r\n        throwError();\r\n    }\r\n    var dom = ref && ref.nodeType ? ref : null;\r\n    return componentToDOMNodeMap.get(ref) || dom;\r\n}\r\nfunction getRoot(dom) {\r\n    for (var i = 0, len = roots.length; i < len; i++) {\r\n        var root = roots[i];\r\n        if (root.dom === dom) {\r\n            return root;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction setRoot(dom, input, lifecycle) {\r\n    var root = {\r\n        dom: dom,\r\n        input: input,\r\n        lifecycle: lifecycle\r\n    };\r\n    roots.push(root);\r\n    return root;\r\n}\r\nfunction removeRoot(root) {\r\n    for (var i = 0, len = roots.length; i < len; i++) {\r\n        if (roots[i] === root) {\r\n            roots.splice(i, 1);\r\n            return;\r\n        }\r\n    }\r\n}\r\nif (false) {\r\n    if (isBrowser && document.body === null) {\r\n        warning('Inferno warning: you cannot initialize inferno without \"document.body\". Wait on \"DOMContentLoaded\" event, add script to bottom of body, or use async/defer attributes on script tag.');\r\n    }\r\n}\r\nvar documentBody = isBrowser ? document.body : null;\r\n/**\r\n * Renders virtual node tree into parent node.\r\n * @param {VNode | null | string | number} input vNode to be rendered\r\n * @param parentDom DOM node which content will be replaced by virtual node\r\n * @returns {InfernoChildren} rendered virtual node\r\n */\r\nfunction render(input, parentDom) {\r\n    if (documentBody === parentDom) {\r\n        if (false) {\r\n            throwError('you cannot render() to the \"document.body\". Use an empty element as a container instead.');\r\n        }\r\n        throwError();\r\n    }\r\n    if (input === NO_OP) {\r\n        return;\r\n    }\r\n    var root = getRoot(parentDom);\r\n    if (isNull(root)) {\r\n        var lifecycle = new Lifecycle();\r\n        if (!isInvalid(input)) {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            if (!hydrateRoot(input, parentDom, lifecycle)) {\r\n                mount(input, parentDom, lifecycle, EMPTY_OBJ, false);\r\n            }\r\n            root = setRoot(parentDom, input, lifecycle);\r\n            lifecycle.trigger();\r\n        }\r\n    }\r\n    else {\r\n        var lifecycle$1 = root.lifecycle;\r\n        lifecycle$1.listeners = [];\r\n        if (isNullOrUndef(input)) {\r\n            unmount(root.input, parentDom, lifecycle$1, false, false);\r\n            removeRoot(root);\r\n        }\r\n        else {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            patch(root.input, input, parentDom, lifecycle$1, EMPTY_OBJ, false, false);\r\n        }\r\n        root.input = input;\r\n        lifecycle$1.trigger();\r\n    }\r\n    if (root) {\r\n        var rootInput = root.input;\r\n        if (rootInput && rootInput.flags & 28 /* Component */) {\r\n            return rootInput.children;\r\n        }\r\n    }\r\n}\r\nfunction createRenderer(parentDom) {\r\n    return function renderer(lastInput, nextInput) {\r\n        if (!parentDom) {\r\n            parentDom = lastInput;\r\n        }\r\n        render(nextInput, parentDom);\r\n    };\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    if (lastVNode !== nextVNode) {\r\n        var lastFlags = lastVNode.flags;\r\n        var nextFlags = nextVNode.flags;\r\n        if (nextFlags & 28 /* Component */) {\r\n            var isClass = (nextFlags & 4 /* ComponentClass */) > 0;\r\n            if (lastFlags & 28 /* Component */) {\r\n                patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, isClass), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 3970 /* Element */) {\r\n            if (lastFlags & 3970 /* Element */) {\r\n                patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountElement(nextVNode, null, lifecycle, context, isSVG), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 1 /* Text */) {\r\n            if (lastFlags & 1 /* Text */) {\r\n                patchText(lastVNode, nextVNode);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountText(nextVNode, null), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 4096 /* Void */) {\r\n            if (lastFlags & 4096 /* Void */) {\r\n                patchVoid(lastVNode, nextVNode);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountVoid(nextVNode, null), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else {\r\n            // Error case: mount new one replacing old one\r\n            replaceLastChildAndUnmount(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction unmountChildren(children, dom, lifecycle, isRecycling) {\r\n    if (isVNode(children)) {\r\n        unmount(children, dom, lifecycle, true, isRecycling);\r\n    }\r\n    else if (isArray(children)) {\r\n        removeAllChildren(dom, children, lifecycle, isRecycling);\r\n    }\r\n    else {\r\n        dom.textContent = \"\";\r\n    }\r\n}\r\nfunction patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    var nextTag = nextVNode.type;\r\n    var lastTag = lastVNode.type;\r\n    if (lastTag !== nextTag) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n    }\r\n    else {\r\n        var dom = lastVNode.dom;\r\n        var lastProps = lastVNode.props;\r\n        var nextProps = nextVNode.props;\r\n        var lastChildren = lastVNode.children;\r\n        var nextChildren = nextVNode.children;\r\n        var lastFlags = lastVNode.flags;\r\n        var nextFlags = nextVNode.flags;\r\n        var nextRef = nextVNode.ref;\r\n        var lastClassName = lastVNode.className;\r\n        var nextClassName = nextVNode.className;\r\n        nextVNode.dom = dom;\r\n        isSVG = isSVG || (nextFlags & 128 /* SvgElement */) > 0;\r\n        if (lastChildren !== nextChildren) {\r\n            var childrenIsSVG = isSVG === true && nextVNode.type !== \"foreignObject\";\r\n            patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, childrenIsSVG, isRecycling);\r\n        }\r\n        // inlined patchProps  -- starts --\r\n        if (lastProps !== nextProps) {\r\n            var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\r\n            var nextPropsOrEmpty = nextProps || EMPTY_OBJ;\r\n            var hasControlledValue = false;\r\n            if (nextPropsOrEmpty !== EMPTY_OBJ) {\r\n                var isFormElement = (nextFlags & 3584 /* FormElement */) > 0;\r\n                if (isFormElement) {\r\n                    hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\r\n                }\r\n                for (var prop in nextPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    var nextValue = nextPropsOrEmpty[prop];\r\n                    var lastValue = lastPropsOrEmpty[prop];\r\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue);\r\n                }\r\n                if (isFormElement) {\r\n                    // When inferno is recycling form element, we need to process it like it would be mounting\r\n                    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, isRecycling, hasControlledValue);\r\n                }\r\n            }\r\n            if (lastPropsOrEmpty !== EMPTY_OBJ) {\r\n                for (var prop$1 in lastPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    if (isNullOrUndef(nextPropsOrEmpty[prop$1]) &&\r\n                        !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\r\n                        removeProp(prop$1, lastPropsOrEmpty[prop$1], dom, nextFlags);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // inlined patchProps  -- ends --\r\n        if (lastClassName !== nextClassName) {\r\n            if (isNullOrUndef(nextClassName)) {\r\n                dom.removeAttribute(\"class\");\r\n            }\r\n            else {\r\n                if (isSVG) {\r\n                    dom.setAttribute(\"class\", nextClassName);\r\n                }\r\n                else {\r\n                    dom.className = nextClassName;\r\n                }\r\n            }\r\n        }\r\n        if (nextRef) {\r\n            if (lastVNode.ref !== nextRef || isRecycling) {\r\n                mountRef(dom, nextRef, lifecycle);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var patchArray = false;\r\n    var patchKeyed = false;\r\n    if (nextFlags & 64 /* HasNonKeyedChildren */) {\r\n        patchArray = true;\r\n    }\r\n    else if ((lastFlags & 32 /* HasKeyedChildren */) > 0 &&\r\n        (nextFlags & 32 /* HasKeyedChildren */) > 0) {\r\n        patchKeyed = true;\r\n        patchArray = true;\r\n    }\r\n    else if (isInvalid(nextChildren)) {\r\n        unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n    }\r\n    else if (isInvalid(lastChildren)) {\r\n        if (isStringOrNumber(nextChildren)) {\r\n            setTextContent(dom, nextChildren);\r\n        }\r\n        else {\r\n            if (isArray(nextChildren)) {\r\n                mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\r\n            }\r\n            else {\r\n                mount(nextChildren, dom, lifecycle, context, isSVG);\r\n            }\r\n        }\r\n    }\r\n    else if (isStringOrNumber(nextChildren)) {\r\n        if (isStringOrNumber(lastChildren)) {\r\n            updateTextContent(dom, nextChildren);\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            setTextContent(dom, nextChildren);\r\n        }\r\n    }\r\n    else if (isArray(nextChildren)) {\r\n        if (isArray(lastChildren)) {\r\n            patchArray = true;\r\n            if (isKeyed(lastChildren, nextChildren)) {\r\n                patchKeyed = true;\r\n            }\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    else if (isArray(lastChildren)) {\r\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\r\n        mount(nextChildren, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (isVNode(nextChildren)) {\r\n        if (isVNode(lastChildren)) {\r\n            patch(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            mount(nextChildren, dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    if (patchArray) {\r\n        if (patchKeyed) {\r\n            patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n        else {\r\n            patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling) {\r\n    var lastType = lastVNode.type;\r\n    var nextType = nextVNode.type;\r\n    var lastKey = lastVNode.key;\r\n    var nextKey = nextVNode.key;\r\n    if (lastType !== nextType || lastKey !== nextKey) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n        return false;\r\n    }\r\n    else {\r\n        var nextProps = nextVNode.props || EMPTY_OBJ;\r\n        if (isClass) {\r\n            var instance = lastVNode.children;\r\n            instance._updating = true;\r\n            if (instance._unmounted) {\r\n                if (isNull(parentDom)) {\r\n                    return true;\r\n                }\r\n                replaceChild(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, (nextVNode.flags & 4 /* ComponentClass */) > 0), lastVNode.dom);\r\n            }\r\n            else {\r\n                var hasComponentDidUpdate = !isUndefined(instance.componentDidUpdate);\r\n                var nextState = instance.state;\r\n                // When component has componentDidUpdate hook, we need to clone lastState or will be modified by reference during update\r\n                var lastState = hasComponentDidUpdate\r\n                    ? combineFrom(nextState, null)\r\n                    : nextState;\r\n                var lastProps = instance.props;\r\n                var childContext;\r\n                if (!isNullOrUndef(instance.getChildContext)) {\r\n                    childContext = instance.getChildContext();\r\n                }\r\n                nextVNode.children = instance;\r\n                instance._isSVG = isSVG;\r\n                if (isNullOrUndef(childContext)) {\r\n                    childContext = context;\r\n                }\r\n                else {\r\n                    childContext = combineFrom(context, childContext);\r\n                }\r\n                var lastInput = instance._lastInput;\r\n                var nextInput = instance._updateComponent(lastState, nextState, lastProps, nextProps, context, false, false);\r\n                var didUpdate = true;\r\n                instance._childContext = childContext;\r\n                if (isInvalid(nextInput)) {\r\n                    nextInput = createVoidVNode();\r\n                }\r\n                else if (nextInput === NO_OP) {\r\n                    nextInput = lastInput;\r\n                    didUpdate = false;\r\n                }\r\n                else if (isStringOrNumber(nextInput)) {\r\n                    nextInput = createTextVNode(nextInput, null);\r\n                }\r\n                else if (isArray(nextInput)) {\r\n                    if (false) {\r\n                        throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n                    }\r\n                    throwError();\r\n                }\r\n                else if (isObject(nextInput)) {\r\n                    if (!isNull(nextInput.dom)) {\r\n                        nextInput = directClone(nextInput);\r\n                    }\r\n                }\r\n                if (nextInput.flags & 28 /* Component */) {\r\n                    nextInput.parentVNode = nextVNode;\r\n                }\r\n                else if (lastInput.flags & 28 /* Component */) {\r\n                    lastInput.parentVNode = nextVNode;\r\n                }\r\n                instance._lastInput = nextInput;\r\n                instance._vNode = nextVNode;\r\n                if (didUpdate) {\r\n                    patch(lastInput, nextInput, parentDom, lifecycle, childContext, isSVG, isRecycling);\r\n                    if (hasComponentDidUpdate && instance.componentDidUpdate) {\r\n                        instance.componentDidUpdate(lastProps, lastState);\r\n                    }\r\n                    if (!isNull(options.afterUpdate)) {\r\n                        options.afterUpdate(nextVNode);\r\n                    }\r\n                    if (options.findDOMNodeEnabled) {\r\n                        componentToDOMNodeMap.set(instance, nextInput.dom);\r\n                    }\r\n                }\r\n                nextVNode.dom = nextInput.dom;\r\n            }\r\n            instance._updating = false;\r\n        }\r\n        else {\r\n            var shouldUpdate = true;\r\n            var lastProps$1 = lastVNode.props;\r\n            var nextHooks = nextVNode.ref;\r\n            var nextHooksDefined = !isNullOrUndef(nextHooks);\r\n            var lastInput$1 = lastVNode.children;\r\n            var nextInput$1 = lastInput$1;\r\n            nextVNode.dom = lastVNode.dom;\r\n            nextVNode.children = lastInput$1;\r\n            if (lastKey !== nextKey) {\r\n                shouldUpdate = true;\r\n            }\r\n            else {\r\n                if (nextHooksDefined &&\r\n                    !isNullOrUndef(nextHooks.onComponentShouldUpdate)) {\r\n                    shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps$1, nextProps);\r\n                }\r\n            }\r\n            if (shouldUpdate !== false) {\r\n                if (nextHooksDefined &&\r\n                    !isNullOrUndef(nextHooks.onComponentWillUpdate)) {\r\n                    nextHooks.onComponentWillUpdate(lastProps$1, nextProps);\r\n                }\r\n                nextInput$1 = nextType(nextProps, context);\r\n                if (isInvalid(nextInput$1)) {\r\n                    nextInput$1 = createVoidVNode();\r\n                }\r\n                else if (isStringOrNumber(nextInput$1) && nextInput$1 !== NO_OP) {\r\n                    nextInput$1 = createTextVNode(nextInput$1, null);\r\n                }\r\n                else if (isArray(nextInput$1)) {\r\n                    if (false) {\r\n                        throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n                    }\r\n                    throwError();\r\n                }\r\n                else if (isObject(nextInput$1)) {\r\n                    if (!isNull(nextInput$1.dom)) {\r\n                        nextInput$1 = directClone(nextInput$1);\r\n                    }\r\n                }\r\n                if (nextInput$1 !== NO_OP) {\r\n                    patch(lastInput$1, nextInput$1, parentDom, lifecycle, context, isSVG, isRecycling);\r\n                    nextVNode.children = nextInput$1;\r\n                    if (nextHooksDefined &&\r\n                        !isNullOrUndef(nextHooks.onComponentDidUpdate)) {\r\n                        nextHooks.onComponentDidUpdate(lastProps$1, nextProps);\r\n                    }\r\n                    nextVNode.dom = nextInput$1.dom;\r\n                }\r\n            }\r\n            if (nextInput$1.flags & 28 /* Component */) {\r\n                nextInput$1.parentVNode = nextVNode;\r\n            }\r\n            else if (lastInput$1.flags & 28 /* Component */) {\r\n                lastInput$1.parentVNode = nextVNode;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction patchText(lastVNode, nextVNode) {\r\n    var nextText = nextVNode.children;\r\n    var dom = lastVNode.dom;\r\n    nextVNode.dom = dom;\r\n    if (lastVNode.children !== nextText) {\r\n        dom.nodeValue = nextText;\r\n    }\r\n}\r\nfunction patchVoid(lastVNode, nextVNode) {\r\n    nextVNode.dom = lastVNode.dom;\r\n}\r\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var lastChildrenLength = lastChildren.length;\r\n    var nextChildrenLength = nextChildren.length;\r\n    var commonLength = lastChildrenLength > nextChildrenLength\r\n        ? nextChildrenLength\r\n        : lastChildrenLength;\r\n    var i = 0;\r\n    for (; i < commonLength; i++) {\r\n        var nextChild = nextChildren[i];\r\n        if (nextChild.dom) {\r\n            nextChild = nextChildren[i] = directClone(nextChild);\r\n        }\r\n        patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG, isRecycling);\r\n    }\r\n    if (lastChildrenLength < nextChildrenLength) {\r\n        for (i = commonLength; i < nextChildrenLength; i++) {\r\n            var nextChild$1 = nextChildren[i];\r\n            if (nextChild$1.dom) {\r\n                nextChild$1 = nextChildren[i] = directClone(nextChild$1);\r\n            }\r\n            appendChild(dom, mount(nextChild$1, null, lifecycle, context, isSVG));\r\n        }\r\n    }\r\n    else if (nextChildrenLength === 0) {\r\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\r\n    }\r\n    else if (lastChildrenLength > nextChildrenLength) {\r\n        for (i = commonLength; i < lastChildrenLength; i++) {\r\n            unmount(lastChildren[i], dom, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var aLength = a.length;\r\n    var bLength = b.length;\r\n    var aEnd = aLength - 1;\r\n    var bEnd = bLength - 1;\r\n    var aStart = 0;\r\n    var bStart = 0;\r\n    var i;\r\n    var j;\r\n    var aNode;\r\n    var bNode;\r\n    var nextNode;\r\n    var nextPos;\r\n    var node;\r\n    if (aLength === 0) {\r\n        if (bLength > 0) {\r\n            mountArrayChildren(b, dom, lifecycle, context, isSVG);\r\n        }\r\n        return;\r\n    }\r\n    else if (bLength === 0) {\r\n        removeAllChildren(dom, a, lifecycle, isRecycling);\r\n        return;\r\n    }\r\n    var aStartNode = a[aStart];\r\n    var bStartNode = b[bStart];\r\n    var aEndNode = a[aEnd];\r\n    var bEndNode = b[bEnd];\r\n    if (bStartNode.dom) {\r\n        b[bStart] = bStartNode = directClone(bStartNode);\r\n    }\r\n    if (bEndNode.dom) {\r\n        b[bEnd] = bEndNode = directClone(bEndNode);\r\n    }\r\n    // Step 1\r\n    /* eslint no-constant-condition: 0 */\r\n    outer: while (true) {\r\n        // Sync nodes with the same key at the beginning.\r\n        while (aStartNode.key === bStartNode.key) {\r\n            patch(aStartNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            aStart++;\r\n            bStart++;\r\n            if (aStart > aEnd || bStart > bEnd) {\r\n                break outer;\r\n            }\r\n            aStartNode = a[aStart];\r\n            bStartNode = b[bStart];\r\n            if (bStartNode.dom) {\r\n                b[bStart] = bStartNode = directClone(bStartNode);\r\n            }\r\n        }\r\n        // Sync nodes with the same key at the end.\r\n        while (aEndNode.key === bEndNode.key) {\r\n            patch(aEndNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            aEnd--;\r\n            bEnd--;\r\n            if (aStart > aEnd || bStart > bEnd) {\r\n                break outer;\r\n            }\r\n            aEndNode = a[aEnd];\r\n            bEndNode = b[bEnd];\r\n            if (bEndNode.dom) {\r\n                b[bEnd] = bEndNode = directClone(bEndNode);\r\n            }\r\n        }\r\n        // Move and sync nodes from right to left.\r\n        if (aEndNode.key === bStartNode.key) {\r\n            patch(aEndNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            insertOrAppend(dom, bStartNode.dom, aStartNode.dom);\r\n            aEnd--;\r\n            bStart++;\r\n            aEndNode = a[aEnd];\r\n            bStartNode = b[bStart];\r\n            if (bStartNode.dom) {\r\n                b[bStart] = bStartNode = directClone(bStartNode);\r\n            }\r\n            continue;\r\n        }\r\n        // Move and sync nodes from left to right.\r\n        if (aStartNode.key === bEndNode.key) {\r\n            patch(aStartNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            nextPos = bEnd + 1;\r\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n            insertOrAppend(dom, bEndNode.dom, nextNode);\r\n            aStart++;\r\n            bEnd--;\r\n            aStartNode = a[aStart];\r\n            bEndNode = b[bEnd];\r\n            if (bEndNode.dom) {\r\n                b[bEnd] = bEndNode = directClone(bEndNode);\r\n            }\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    if (aStart > aEnd) {\r\n        if (bStart <= bEnd) {\r\n            nextPos = bEnd + 1;\r\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n            while (bStart <= bEnd) {\r\n                node = b[bStart];\r\n                if (node.dom) {\r\n                    b[bStart] = node = directClone(node);\r\n                }\r\n                bStart++;\r\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n            }\r\n        }\r\n    }\r\n    else if (bStart > bEnd) {\r\n        while (aStart <= aEnd) {\r\n            unmount(a[aStart++], dom, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n    else {\r\n        aLength = aEnd - aStart + 1;\r\n        bLength = bEnd - bStart + 1;\r\n        var sources = new Array(bLength);\r\n        // Mark all nodes as inserted.\r\n        for (i = 0; i < bLength; i++) {\r\n            sources[i] = -1;\r\n        }\r\n        var moved = false;\r\n        var pos = 0;\r\n        var patched = 0;\r\n        // When sizes are small, just loop them through\r\n        if (bLength <= 4 || aLength * bLength <= 16) {\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLength) {\r\n                    for (j = bStart; j <= bEnd; j++) {\r\n                        bNode = b[j];\r\n                        if (aNode.key === bNode.key) {\r\n                            sources[j - bStart] = i;\r\n                            if (pos > j) {\r\n                                moved = true;\r\n                            }\r\n                            else {\r\n                                pos = j;\r\n                            }\r\n                            if (bNode.dom) {\r\n                                b[j] = bNode = directClone(bNode);\r\n                            }\r\n                            patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\r\n                            patched++;\r\n                            a[i] = null;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var keyIndex = new Map();\r\n            // Map keys by their index in array\r\n            for (i = bStart; i <= bEnd; i++) {\r\n                keyIndex.set(b[i].key, i);\r\n            }\r\n            // Try to patch same keys\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLength) {\r\n                    j = keyIndex.get(aNode.key);\r\n                    if (!isUndefined(j)) {\r\n                        bNode = b[j];\r\n                        sources[j - bStart] = i;\r\n                        if (pos > j) {\r\n                            moved = true;\r\n                        }\r\n                        else {\r\n                            pos = j;\r\n                        }\r\n                        if (bNode.dom) {\r\n                            b[j] = bNode = directClone(bNode);\r\n                        }\r\n                        patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\r\n                        patched++;\r\n                        a[i] = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // fast-path: if nothing patched remove all old and add all new\r\n        if (aLength === a.length && patched === 0) {\r\n            removeAllChildren(dom, a, lifecycle, isRecycling);\r\n            while (bStart < bLength) {\r\n                node = b[bStart];\r\n                if (node.dom) {\r\n                    b[bStart] = node = directClone(node);\r\n                }\r\n                bStart++;\r\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), null);\r\n            }\r\n        }\r\n        else {\r\n            i = aLength - patched;\r\n            while (i > 0) {\r\n                aNode = a[aStart++];\r\n                if (!isNull(aNode)) {\r\n                    unmount(aNode, dom, lifecycle, true, isRecycling);\r\n                    i--;\r\n                }\r\n            }\r\n            if (moved) {\r\n                var seq = lis_algorithm(sources);\r\n                j = seq.length - 1;\r\n                for (i = bLength - 1; i >= 0; i--) {\r\n                    if (sources[i] === -1) {\r\n                        pos = i + bStart;\r\n                        node = b[pos];\r\n                        if (node.dom) {\r\n                            b[pos] = node = directClone(node);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n                    }\r\n                    else {\r\n                        if (j < 0 || i !== seq[j]) {\r\n                            pos = i + bStart;\r\n                            node = b[pos];\r\n                            nextPos = pos + 1;\r\n                            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                            insertOrAppend(dom, node.dom, nextNode);\r\n                        }\r\n                        else {\r\n                            j--;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (patched !== bLength) {\r\n                // when patched count doesn't match b length we need to insert those new ones\r\n                // loop backwards so we can use insertBefore\r\n                for (i = bLength - 1; i >= 0; i--) {\r\n                    if (sources[i] === -1) {\r\n                        pos = i + bStart;\r\n                        node = b[pos];\r\n                        if (node.dom) {\r\n                            b[pos] = node = directClone(node);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n// // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction lis_algorithm(arr) {\r\n    var p = arr.slice(0);\r\n    var result = [0];\r\n    var i;\r\n    var j;\r\n    var u;\r\n    var v;\r\n    var c;\r\n    var len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var arrI = arr[i];\r\n        if (arrI === -1) {\r\n            continue;\r\n        }\r\n        j = result[result.length - 1];\r\n        if (arr[j] < arrI) {\r\n            p[i] = j;\r\n            result.push(i);\r\n            continue;\r\n        }\r\n        u = 0;\r\n        v = result.length - 1;\r\n        while (u < v) {\r\n            c = ((u + v) / 2) | 0;\r\n            if (arr[result[c]] < arrI) {\r\n                u = c + 1;\r\n            }\r\n            else {\r\n                v = c;\r\n            }\r\n        }\r\n        if (arrI < arr[result[u]]) {\r\n            if (u > 0) {\r\n                p[i] = result[u - 1];\r\n            }\r\n            result[u] = i;\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\r\nfunction isAttrAnEvent(attr) {\r\n    return attr[0] === \"o\" && attr[1] === \"n\";\r\n}\r\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue) {\r\n    if (lastValue !== nextValue) {\r\n        if (skipProps.has(prop) || (hasControlledValue && prop === \"value\")) {\r\n            return;\r\n        }\r\n        else if (booleanProps.has(prop)) {\r\n            prop = prop === \"autoFocus\" ? prop.toLowerCase() : prop;\r\n            dom[prop] = !!nextValue;\r\n        }\r\n        else if (strictProps.has(prop)) {\r\n            var value = isNullOrUndef(nextValue) ? \"\" : nextValue;\r\n            if (dom[prop] !== value) {\r\n                dom[prop] = value;\r\n            }\r\n        }\r\n        else if (isAttrAnEvent(prop)) {\r\n            patchEvent(prop, lastValue, nextValue, dom);\r\n        }\r\n        else if (isNullOrUndef(nextValue)) {\r\n            dom.removeAttribute(prop);\r\n        }\r\n        else if (prop === \"style\") {\r\n            patchStyle(lastValue, nextValue, dom);\r\n        }\r\n        else if (prop === \"dangerouslySetInnerHTML\") {\r\n            var lastHtml = lastValue && lastValue.__html;\r\n            var nextHtml = nextValue && nextValue.__html;\r\n            if (lastHtml !== nextHtml) {\r\n                if (!isNullOrUndef(nextHtml)) {\r\n                    dom.innerHTML = nextHtml;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // We optimize for NS being boolean. Its 99.9% time false\r\n            if (isSVG && namespaces.has(prop)) {\r\n                // If we end up in this path we can read property again\r\n                dom.setAttributeNS(namespaces.get(prop), prop, nextValue);\r\n            }\r\n            else {\r\n                dom.setAttribute(prop, nextValue);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchEvent(name, lastValue, nextValue, dom) {\r\n    if (lastValue !== nextValue) {\r\n        if (delegatedEvents.has(name)) {\r\n            handleEvent(name, lastValue, nextValue, dom);\r\n        }\r\n        else {\r\n            var nameLowerCase = name.toLowerCase();\r\n            var domEvent = dom[nameLowerCase];\r\n            // if the function is wrapped, that means it's been controlled by a wrapper\r\n            if (domEvent && domEvent.wrapped) {\r\n                return;\r\n            }\r\n            if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {\r\n                var linkEvent = nextValue.event;\r\n                if (linkEvent && isFunction(linkEvent)) {\r\n                    dom[nameLowerCase] = function (e) {\r\n                        linkEvent(nextValue.data, e);\r\n                    };\r\n                }\r\n                else {\r\n                    if (false) {\r\n                        throwError((\"an event on a VNode \\\"\" + name + \"\\\". was not a function or a valid linkEvent.\"));\r\n                    }\r\n                    throwError();\r\n                }\r\n            }\r\n            else {\r\n                dom[nameLowerCase] = nextValue;\r\n            }\r\n        }\r\n    }\r\n}\r\n// We are assuming here that we come from patchProp routine\r\n// -nextAttrValue cannot be null or undefined\r\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\r\n    var domStyle = dom.style;\r\n    var style;\r\n    var value;\r\n    if (isString(nextAttrValue)) {\r\n        domStyle.cssText = nextAttrValue;\r\n        return;\r\n    }\r\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\r\n        for (style in nextAttrValue) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            value = nextAttrValue[style];\r\n            if (value !== lastAttrValue[style]) {\r\n                domStyle[style] =\r\n                    !isNumber(value) || isUnitlessNumber.has(style)\r\n                        ? value\r\n                        : value + \"px\";\r\n            }\r\n        }\r\n        for (style in lastAttrValue) {\r\n            if (isNullOrUndef(nextAttrValue[style])) {\r\n                domStyle[style] = \"\";\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (style in nextAttrValue) {\r\n            value = nextAttrValue[style];\r\n            domStyle[style] =\r\n                !isNumber(value) || isUnitlessNumber.has(style) ? value : value + \"px\";\r\n        }\r\n    }\r\n}\r\nfunction removeProp(prop, lastValue, dom, nextFlags) {\r\n    if (prop === \"value\") {\r\n        // When removing value of select element, it needs to be set to null instead empty string, because empty string is valid value for option which makes that option selected\r\n        // MS IE/Edge don't follow html spec for textArea and input elements and we need to set empty string to value in those cases to avoid \"null\" and \"undefined\" texts\r\n        dom.value = nextFlags & 2048 /* SelectElement */ ? null : \"\";\r\n    }\r\n    else if (prop === \"style\") {\r\n        dom.removeAttribute(\"style\");\r\n    }\r\n    else if (isAttrAnEvent(prop)) {\r\n        handleEvent(prop, lastValue, null, dom);\r\n    }\r\n    else {\r\n        dom.removeAttribute(prop);\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction mount(vNode, parentDom, lifecycle, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 3970 /* Element */) {\r\n        return mountElement(vNode, parentDom, lifecycle, context, isSVG);\r\n    }\r\n    else if (flags & 28 /* Component */) {\r\n        return mountComponent(vNode, parentDom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 4096 /* Void */) {\r\n        return mountVoid(vNode, parentDom);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        return mountText(vNode, parentDom);\r\n    }\r\n    else {\r\n        if (false) {\r\n            if (typeof vNode === \"object\") {\r\n                throwError((\"mount() received an object that's not a valid VNode, you should stringify it first. Object: \\\"\" + (JSON.stringify(vNode)) + \"\\\".\"));\r\n            }\r\n            else {\r\n                throwError((\"mount() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\r\n            }\r\n        }\r\n        throwError();\r\n    }\r\n}\r\nfunction mountText(vNode, parentDom) {\r\n    var dom = document.createTextNode(vNode.children);\r\n    vNode.dom = dom;\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountVoid(vNode, parentDom) {\r\n    var dom = document.createTextNode(\"\");\r\n    vNode.dom = dom;\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountElement(vNode, parentDom, lifecycle, context, isSVG) {\r\n    var dom;\r\n    if (options.recyclingEnabled) {\r\n        dom = recycleElement(vNode, lifecycle, context, isSVG);\r\n        if (!isNull(dom)) {\r\n            if (!isNull(parentDom)) {\r\n                appendChild(parentDom, dom);\r\n            }\r\n            return dom;\r\n        }\r\n    }\r\n    var flags = vNode.flags;\r\n    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;\r\n    dom = documentCreateElement(vNode.type, isSVG);\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var ref = vNode.ref;\r\n    vNode.dom = dom;\r\n    if (!isInvalid(children)) {\r\n        if (isStringOrNumber(children)) {\r\n            setTextContent(dom, children);\r\n        }\r\n        else {\r\n            var childrenIsSVG = isSVG === true && vNode.type !== \"foreignObject\";\r\n            if (isArray(children)) {\r\n                mountArrayChildren(children, dom, lifecycle, context, childrenIsSVG);\r\n            }\r\n            else if (isVNode(children)) {\r\n                mount(children, dom, lifecycle, context, childrenIsSVG);\r\n            }\r\n        }\r\n    }\r\n    if (!isNull(props)) {\r\n        var hasControlledValue = false;\r\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\r\n        if (isFormElement) {\r\n            hasControlledValue = isControlledFormElement(props);\r\n        }\r\n        for (var prop in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\r\n        }\r\n        if (isFormElement) {\r\n            processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n        }\r\n    }\r\n    if (className !== null) {\r\n        if (isSVG) {\r\n            dom.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    if (!isNull(ref)) {\r\n        mountRef(dom, ref, lifecycle);\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountArrayChildren(children, dom, lifecycle, context, isSVG) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        // Verify can string/number be here. might cause de-opt. - Normalization takes care of it.\r\n        if (!isInvalid(child)) {\r\n            if (child.dom) {\r\n                children[i] = child = directClone(child);\r\n            }\r\n            mount(children[i], dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n}\r\nfunction mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {\r\n    var dom;\r\n    if (options.recyclingEnabled) {\r\n        dom = recycleComponent(vNode, lifecycle, context, isSVG);\r\n        if (!isNull(dom)) {\r\n            if (!isNull(parentDom)) {\r\n                appendChild(parentDom, dom);\r\n            }\r\n            return dom;\r\n        }\r\n    }\r\n    var type = vNode.type;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var ref = vNode.ref;\r\n    if (isClass) {\r\n        var instance = createClassComponentInstance(vNode, type, props, context, isSVG, lifecycle);\r\n        var input = instance._lastInput;\r\n        instance._vNode = vNode;\r\n        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);\r\n        if (!isNull(parentDom)) {\r\n            appendChild(parentDom, dom);\r\n        }\r\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\r\n        instance._updating = false;\r\n        if (options.findDOMNodeEnabled) {\r\n            componentToDOMNodeMap.set(instance, dom);\r\n        }\r\n    }\r\n    else {\r\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\r\n        vNode.dom = dom = mount(input$1, null, lifecycle, context, isSVG);\r\n        vNode.children = input$1;\r\n        mountFunctionalComponentCallbacks(props, ref, dom, lifecycle);\r\n        if (!isNull(parentDom)) {\r\n            appendChild(parentDom, dom);\r\n        }\r\n    }\r\n    return dom;\r\n}\r\nfunction mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {\r\n    if (ref) {\r\n        if (isFunction(ref)) {\r\n            ref(instance);\r\n        }\r\n        else {\r\n            if (false) {\r\n                if (isStringOrNumber(ref)) {\r\n                    throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n                }\r\n                else if (isObject(ref) && vNode.flags & 4 /* ComponentClass */) {\r\n                    throwError(\"functional component lifecycle events are not supported on ES2015 class components.\");\r\n                }\r\n                else {\r\n                    throwError((\"a bad value for \\\"ref\\\" was used on component: \\\"\" + (JSON.stringify(ref)) + \"\\\"\"));\r\n                }\r\n            }\r\n            throwError();\r\n        }\r\n    }\r\n    var hasDidMount = !isUndefined(instance.componentDidMount);\r\n    var afterMount = options.afterMount;\r\n    if (hasDidMount || !isNull(afterMount)) {\r\n        lifecycle.addListener((function () {\r\n            instance._updating = true;\r\n            if (afterMount) {\r\n                afterMount(vNode);\r\n            }\r\n            if (hasDidMount) {\r\n                instance.componentDidMount();\r\n            }\r\n            instance._updating = false;\r\n        }));\r\n    }\r\n}\r\nfunction mountFunctionalComponentCallbacks(props, ref, dom, lifecycle) {\r\n    if (ref) {\r\n        if (!isNullOrUndef(ref.onComponentWillMount)) {\r\n            ref.onComponentWillMount(props);\r\n        }\r\n        if (!isNullOrUndef(ref.onComponentDidMount)) {\r\n            lifecycle.addListener((function () { return ref.onComponentDidMount(dom, props); }));\r\n        }\r\n    }\r\n}\r\nfunction mountRef(dom, value, lifecycle) {\r\n    if (isFunction(value)) {\r\n        lifecycle.addListener((function () { return value(dom); }));\r\n    }\r\n    else {\r\n        if (isInvalid(value)) {\r\n            return;\r\n        }\r\n        if (false) {\r\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n        }\r\n        throwError();\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n// We need EMPTY_OBJ defined in one place.\r\n// Its used for comparison so we cant inline it into shared\r\nvar EMPTY_OBJ = {};\r\nif (false) {\r\n    Object.freeze(EMPTY_OBJ);\r\n}\r\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\r\n    if (isUndefined(context)) {\r\n        context = EMPTY_OBJ; // Context should not be mutable\r\n    }\r\n    var instance = new Component(props, context);\r\n    vNode.children = instance;\r\n    instance._blockSetState = false;\r\n    instance.context = context;\r\n    if (instance.props === EMPTY_OBJ) {\r\n        instance.props = props;\r\n    }\r\n    // setState callbacks must fire after render is done when called from componentWillReceiveProps or componentWillMount\r\n    instance._lifecycle = lifecycle;\r\n    instance._unmounted = false;\r\n    instance._pendingSetState = true;\r\n    instance._isSVG = isSVG;\r\n    if (!isNullOrUndef(instance.componentWillMount)) {\r\n        instance._blockRender = true;\r\n        instance.componentWillMount();\r\n        instance._blockRender = false;\r\n    }\r\n    var childContext;\r\n    if (!isNullOrUndef(instance.getChildContext)) {\r\n        childContext = instance.getChildContext();\r\n    }\r\n    if (isNullOrUndef(childContext)) {\r\n        instance._childContext = context;\r\n    }\r\n    else {\r\n        instance._childContext = combineFrom(context, childContext);\r\n    }\r\n    if (!isNull(options.beforeRender)) {\r\n        options.beforeRender(instance);\r\n    }\r\n    var input = instance.render(props, instance.state, context);\r\n    if (!isNull(options.afterRender)) {\r\n        options.afterRender(instance);\r\n    }\r\n    if (isArray(input)) {\r\n        if (false) {\r\n            throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n        }\r\n        throwError();\r\n    }\r\n    else if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 28 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = vNode;\r\n        }\r\n    }\r\n    instance._pendingSetState = false;\r\n    instance._lastInput = input;\r\n    return instance;\r\n}\r\nfunction replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    replaceVNode(parentDom, mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);\r\n}\r\nfunction replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {\r\n    unmount(vNode, null, lifecycle, false, isRecycling);\r\n    replaceChild(parentDom, dom, vNode.dom);\r\n}\r\nfunction createFunctionalComponentInput(vNode, component, props, context) {\r\n    var input = component(props, context);\r\n    if (isArray(input)) {\r\n        if (false) {\r\n            throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n        }\r\n        throwError();\r\n    }\r\n    else if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 28 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = vNode;\r\n        }\r\n    }\r\n    return input;\r\n}\r\nfunction setTextContent(dom, text) {\r\n    if (text !== \"\") {\r\n        dom.textContent = text;\r\n    }\r\n    else {\r\n        dom.appendChild(document.createTextNode(\"\"));\r\n    }\r\n}\r\nfunction updateTextContent(dom, text) {\r\n    dom.firstChild.nodeValue = text;\r\n}\r\nfunction appendChild(parentDom, dom) {\r\n    parentDom.appendChild(dom);\r\n}\r\nfunction insertOrAppend(parentDom, newNode, nextNode) {\r\n    if (isNullOrUndef(nextNode)) {\r\n        appendChild(parentDom, newNode);\r\n    }\r\n    else {\r\n        parentDom.insertBefore(newNode, nextNode);\r\n    }\r\n}\r\nfunction documentCreateElement(tag, isSVG) {\r\n    if (isSVG === true) {\r\n        return document.createElementNS(svgNS, tag);\r\n    }\r\n    else {\r\n        return document.createElement(tag);\r\n    }\r\n}\r\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    unmount(lastNode, null, lifecycle, false, isRecycling);\r\n    var dom = mount(nextNode, null, lifecycle, context, isSVG);\r\n    nextNode.dom = dom;\r\n    replaceChild(parentDom, dom, lastNode.dom);\r\n}\r\nfunction replaceChild(parentDom, nextDom, lastDom) {\r\n    if (!parentDom) {\r\n        parentDom = lastDom.parentNode;\r\n    }\r\n    parentDom.replaceChild(nextDom, lastDom);\r\n}\r\nfunction removeChild(parentDom, dom) {\r\n    parentDom.removeChild(dom);\r\n}\r\nfunction removeAllChildren(dom, children, lifecycle, isRecycling) {\r\n    if (!options.recyclingEnabled || (options.recyclingEnabled && !isRecycling)) {\r\n        removeChildren(null, children, lifecycle, isRecycling);\r\n    }\r\n    dom.textContent = \"\";\r\n}\r\nfunction removeChildren(dom, children, lifecycle, isRecycling) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        if (!isInvalid(child)) {\r\n            unmount(child, dom, lifecycle, true, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction isKeyed(lastChildren, nextChildren) {\r\n    return (nextChildren.length > 0 &&\r\n        !isNullOrUndef(nextChildren[0]) &&\r\n        !isNullOrUndef(nextChildren[0].key) &&\r\n        lastChildren.length > 0 &&\r\n        !isNullOrUndef(lastChildren[0]) &&\r\n        !isNullOrUndef(lastChildren[0].key));\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction VNode(children, className, flags, key, props, ref, type) {\r\n    this.children = children;\r\n    this.className = className;\r\n    this.dom = null;\r\n    this.flags = flags;\r\n    this.key = key;\r\n    this.props = props;\r\n    this.ref = ref;\r\n    this.type = type;\r\n}\r\n/**\r\n * Creates virtual node\r\n * @param {number} flags\r\n * @param {string|Function|null} type\r\n * @param {string|null=} className\r\n * @param {object=} children\r\n * @param {object=} props\r\n * @param {*=} key\r\n * @param {object|Function=} ref\r\n * @param {boolean=} noNormalise\r\n * @returns {VNode} returns new virtual node\r\n */\r\nfunction createVNode(flags, type, className, children, props, key, ref, noNormalise) {\r\n    if (flags & 16 /* ComponentUnknown */) {\r\n        flags = isStatefulComponent(type)\r\n            ? 4 /* ComponentClass */\r\n            : 8 /* ComponentFunction */;\r\n    }\r\n    var vNode = new VNode(children === void 0 ? null : children, className === void 0 ? null : className, flags, key === void 0 ? null : key, props === void 0 ? null : props, ref === void 0 ? null : ref, type);\r\n    if (noNormalise !== true) {\r\n        normalize(vNode);\r\n    }\r\n    if (options.createVNode !== null) {\r\n        options.createVNode(vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction directClone(vNodeToClone) {\r\n    var newVNode;\r\n    var flags = vNodeToClone.flags;\r\n    if (flags & 28 /* Component */) {\r\n        var props;\r\n        var propsToClone = vNodeToClone.props;\r\n        if (isNull(propsToClone)) {\r\n            props = EMPTY_OBJ;\r\n        }\r\n        else {\r\n            props = {};\r\n            for (var key in propsToClone) {\r\n                props[key] = propsToClone[key];\r\n            }\r\n        }\r\n        newVNode = createVNode(flags, vNodeToClone.type, null, null, props, vNodeToClone.key, vNodeToClone.ref, true);\r\n        var newProps = newVNode.props;\r\n        var newChildren = newProps.children;\r\n        // we need to also clone component children that are in props\r\n        // as the children may also have been hoisted\r\n        if (newChildren) {\r\n            if (isArray(newChildren)) {\r\n                var len = newChildren.length;\r\n                if (len > 0) {\r\n                    var tmpArray = [];\r\n                    for (var i = 0; i < len; i++) {\r\n                        var child = newChildren[i];\r\n                        if (isStringOrNumber(child)) {\r\n                            tmpArray.push(child);\r\n                        }\r\n                        else if (!isInvalid(child) && isVNode(child)) {\r\n                            tmpArray.push(directClone(child));\r\n                        }\r\n                    }\r\n                    newProps.children = tmpArray;\r\n                }\r\n            }\r\n            else if (isVNode(newChildren)) {\r\n                newProps.children = directClone(newChildren);\r\n            }\r\n        }\r\n        newVNode.children = null;\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        var children = vNodeToClone.children;\r\n        var props$1;\r\n        var propsToClone$1 = vNodeToClone.props;\r\n        if (propsToClone$1 === null) {\r\n            props$1 = EMPTY_OBJ;\r\n        }\r\n        else {\r\n            props$1 = {};\r\n            for (var key$1 in propsToClone$1) {\r\n                props$1[key$1] = propsToClone$1[key$1];\r\n            }\r\n        }\r\n        newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, children, props$1, vNodeToClone.key, vNodeToClone.ref, !children);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);\r\n    }\r\n    return newVNode;\r\n}\r\n/*\r\n directClone is preferred over cloneVNode and used internally also.\r\n This function makes Inferno backwards compatible.\r\n And can be tree-shaked by modern bundlers\r\n\n Would be nice to combine this with directClone but could not do it without breaking change\r\n */\r\n/**\r\n * Clones given virtual node by creating new instance of it\r\n * @param {VNode} vNodeToClone virtual node to be cloned\r\n * @param {Props=} props additional props for new virtual node\r\n * @param {...*} _children new children for new virtual node\r\n * @returns {VNode} new virtual node\r\n */\r\nfunction cloneVNode(vNodeToClone, props) {\n    var _children = [], len$2 = arguments.length - 2;\n    while ( len$2-- > 0 ) _children[ len$2 ] = arguments[ len$2 + 2 ];\n\r\n    var children = _children;\r\n    var childrenLen = _children.length;\r\n    if (childrenLen > 0 && !isUndefined(_children[0])) {\r\n        if (!props) {\r\n            props = {};\r\n        }\r\n        if (childrenLen === 1) {\r\n            children = _children[0];\r\n        }\r\n        if (!isUndefined(children)) {\r\n            props.children = children;\r\n        }\r\n    }\r\n    var newVNode;\r\n    if (isArray(vNodeToClone)) {\r\n        var tmpArray = [];\r\n        for (var i = 0, len = vNodeToClone.length; i < len; i++) {\r\n            tmpArray.push(directClone(vNodeToClone[i]));\r\n        }\r\n        newVNode = tmpArray;\r\n    }\r\n    else {\r\n        var flags = vNodeToClone.flags;\r\n        var className = vNodeToClone.className;\r\n        var key = vNodeToClone.key;\r\n        var ref = vNodeToClone.ref;\r\n        if (props) {\r\n            if (props.hasOwnProperty(\"className\")) {\r\n                className = props.className;\r\n            }\r\n            if (props.hasOwnProperty(\"ref\")) {\r\n                ref = props.ref;\r\n            }\r\n            if (props.hasOwnProperty(\"key\")) {\r\n                key = props.key;\r\n            }\r\n        }\r\n        if (flags & 28 /* Component */) {\r\n            newVNode = createVNode(flags, vNodeToClone.type, className, null, !vNodeToClone.props && !props\r\n                ? EMPTY_OBJ\r\n                : combineFrom(vNodeToClone.props, props), key, ref, true);\r\n            var newProps = newVNode.props;\r\n            if (newProps) {\r\n                var newChildren = newProps.children;\r\n                // we need to also clone component children that are in props\r\n                // as the children may also have been hoisted\r\n                if (newChildren) {\r\n                    if (isArray(newChildren)) {\r\n                        var len$1 = newChildren.length;\r\n                        if (len$1 > 0) {\r\n                            var tmpArray$1 = [];\r\n                            for (var i$1 = 0; i$1 < len$1; i$1++) {\r\n                                var child = newChildren[i$1];\r\n                                if (isStringOrNumber(child)) {\r\n                                    tmpArray$1.push(child);\r\n                                }\r\n                                else if (!isInvalid(child) && isVNode(child)) {\r\n                                    tmpArray$1.push(directClone(child));\r\n                                }\r\n                            }\r\n                            newProps.children = tmpArray$1;\r\n                        }\r\n                    }\r\n                    else if (isVNode(newChildren)) {\r\n                        newProps.children = directClone(newChildren);\r\n                    }\r\n                }\r\n            }\r\n            newVNode.children = null;\r\n        }\r\n        else if (flags & 3970 /* Element */) {\r\n            children =\r\n                props && !isUndefined(props.children)\r\n                    ? props.children\r\n                    : vNodeToClone.children;\r\n            newVNode = createVNode(flags, vNodeToClone.type, className, children, !vNodeToClone.props && !props\r\n                ? EMPTY_OBJ\r\n                : combineFrom(vNodeToClone.props, props), key, ref, false);\r\n        }\r\n        else if (flags & 1 /* Text */) {\r\n            newVNode = createTextVNode(vNodeToClone.children, key);\r\n        }\r\n    }\r\n    return newVNode;\r\n}\r\nfunction createVoidVNode() {\r\n    return createVNode(4096 /* Void */, null);\r\n}\r\nfunction createTextVNode(text, key) {\r\n    return createVNode(1 /* Text */, null, null, text, null, key);\r\n}\r\nfunction isVNode(o) {\r\n    return !!o.flags;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction applyKey(key, vNode) {\r\n    vNode.key = key;\r\n    return vNode;\r\n}\r\nfunction applyKeyIfMissing(key, vNode) {\r\n    if (isNumber(key)) {\r\n        key = \".\" + key;\r\n    }\r\n    if (isNull(vNode.key) || vNode.key[0] === \".\") {\r\n        return applyKey(key, vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction applyKeyPrefix(key, vNode) {\r\n    vNode.key = key + vNode.key;\r\n    return vNode;\r\n}\r\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\r\n    for (var len = nodes.length; index < len; index++) {\r\n        var n = nodes[index];\r\n        var key = currentKey + \".\" + index;\r\n        if (!isInvalid(n)) {\r\n            if (isArray(n)) {\r\n                _normalizeVNodes(n, result, 0, key);\r\n            }\r\n            else {\r\n                if (isStringOrNumber(n)) {\r\n                    n = createTextVNode(n, null);\r\n                }\r\n                else if ((isVNode(n) && n.dom) || (n.key && n.key[0] === \".\")) {\r\n                    n = directClone(n);\r\n                }\r\n                if (isNull(n.key) || n.key[0] === \".\") {\r\n                    n = applyKey(key, n);\r\n                }\r\n                else {\r\n                    n = applyKeyPrefix(currentKey, n);\r\n                }\r\n                result.push(n);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction normalizeVNodes(nodes) {\r\n    var newNodes;\r\n    // we assign $ which basically means we've flagged this array for future note\r\n    // if it comes back again, we need to clone it, as people are using it\r\n    // in an immutable way\r\n    // tslint:disable\r\n    if (nodes[\"$\"] === true) {\r\n        nodes = nodes.slice();\r\n    }\r\n    else {\r\n        nodes[\"$\"] = true;\r\n    }\r\n    // tslint:enable\r\n    for (var i = 0, len = nodes.length; i < len; i++) {\r\n        var n = nodes[i];\r\n        if (isInvalid(n) || isArray(n)) {\r\n            var result = (newNodes || nodes).slice(0, i);\r\n            _normalizeVNodes(nodes, result, i, \"\");\r\n            return result;\r\n        }\r\n        else if (isStringOrNumber(n)) {\r\n            if (!newNodes) {\r\n                newNodes = nodes.slice(0, i);\r\n            }\r\n            newNodes.push(applyKeyIfMissing(i, createTextVNode(n, null)));\r\n        }\r\n        else if ((isVNode(n) && n.dom !== null) ||\r\n            (isNull(n.key) && (n.flags & 64 /* HasNonKeyedChildren */) === 0)) {\r\n            if (!newNodes) {\r\n                newNodes = nodes.slice(0, i);\r\n            }\r\n            newNodes.push(applyKeyIfMissing(i, directClone(n)));\r\n        }\r\n        else if (newNodes) {\r\n            newNodes.push(applyKeyIfMissing(i, directClone(n)));\r\n        }\r\n    }\r\n    return newNodes || nodes;\r\n}\r\nfunction normalizeChildren(children) {\r\n    if (isArray(children)) {\r\n        return normalizeVNodes(children);\r\n    }\r\n    else if (isVNode(children) && children.dom !== null) {\r\n        return directClone(children);\r\n    }\r\n    return children;\r\n}\r\nfunction normalizeProps(vNode, props, children) {\r\n    if (vNode.flags & 3970 /* Element */) {\r\n        if (isNullOrUndef(children) && props.hasOwnProperty(\"children\")) {\r\n            vNode.children = props.children;\r\n        }\r\n        if (props.hasOwnProperty(\"className\")) {\r\n            vNode.className = props.className || null;\r\n            delete props.className;\r\n        }\r\n    }\r\n    if (props.hasOwnProperty(\"ref\")) {\r\n        vNode.ref = props.ref;\r\n        delete props.ref;\r\n    }\r\n    if (props.hasOwnProperty(\"key\")) {\r\n        vNode.key = props.key;\r\n        delete props.key;\r\n    }\r\n}\r\nfunction getFlagsForElementVnode(type) {\r\n    if (type === \"svg\") {\r\n        return 128 /* SvgElement */;\r\n    }\r\n    else if (type === \"input\") {\r\n        return 512 /* InputElement */;\r\n    }\r\n    else if (type === \"select\") {\r\n        return 2048 /* SelectElement */;\r\n    }\r\n    else if (type === \"textarea\") {\r\n        return 1024 /* TextareaElement */;\r\n    }\r\n    else if (type === \"media\") {\r\n        return 256 /* MediaElement */;\r\n    }\r\n    return 2 /* HtmlElement */;\r\n}\r\nfunction normalize(vNode) {\r\n    var props = vNode.props;\r\n    var children = vNode.children;\r\n    // convert a wrongly created type back to element\r\n    // Primitive node doesn't have defaultProps, only Component\r\n    if (vNode.flags & 28 /* Component */) {\r\n        // set default props\r\n        var type = vNode.type;\r\n        var defaultProps = type.defaultProps;\r\n        if (!isNullOrUndef(defaultProps)) {\r\n            if (!props) {\r\n                props = vNode.props = defaultProps; // Create new object if only defaultProps given\r\n            }\r\n            else {\r\n                for (var prop in defaultProps) {\r\n                    if (isUndefined(props[prop])) {\r\n                        props[prop] = defaultProps[prop];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (isString(type)) {\r\n            vNode.flags = getFlagsForElementVnode(type);\r\n            if (props && props.children) {\r\n                vNode.children = props.children;\r\n                children = props.children;\r\n            }\r\n        }\r\n    }\r\n    if (props) {\r\n        normalizeProps(vNode, props, children);\r\n        if (!isInvalid(props.children)) {\r\n            props.children = normalizeChildren(props.children);\r\n        }\r\n    }\r\n    if (!isInvalid(children)) {\r\n        vNode.children = normalizeChildren(children);\r\n    }\r\n    if (false) {\r\n        // This code will be stripped out from production CODE\r\n        // It helps users to track errors in their applications.\r\n        var verifyKeys = function (vNodes) {\r\n            var keyValues = vNodes.map((function (vnode) {\r\n                return vnode.key;\r\n            }));\r\n            keyValues.some((function (item, idx) {\r\n                var hasDuplicate = keyValues.indexOf(item) !== idx;\r\n                if (hasDuplicate) {\r\n                    warning(\"Inferno normalisation(...): Encountered two children with same key, all keys must be unique within its siblings. Duplicated key is:\" +\r\n                        item);\r\n                }\r\n                return hasDuplicate;\r\n            }));\r\n        };\r\n        if (vNode.children && Array.isArray(vNode.children)) {\r\n            verifyKeys(vNode.children);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * Links given data to event as first parameter\r\n * @param {*} data data to be linked, it will be available in function as first parameter\r\n * @param {Function} event Function to be called when event occurs\r\n * @returns {{data: *, event: Function}}\r\n */\r\nfunction linkEvent(data, event) {\r\n    if (isFunction(event)) {\r\n        return { data: data, event: event };\r\n    }\r\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/* tslint:disable:object-literal-sort-keys */\r\nif (false) {\r\n    /* tslint:disable-next-line:no-empty */\r\n    var testFunc = function testFn() { };\r\n    if ((testFunc.name || testFunc.toString()).indexOf(\"testFn\") ===\r\n        -1) {\r\n        warning(\"It looks like you're using a minified copy of the development build \" +\r\n            \"of Inferno. When deploying Inferno apps to production, make sure to use \" +\r\n            \"the production build which skips development warnings and is faster. \" +\r\n            \"See http://infernojs.org for more details.\");\r\n    }\r\n}\r\nvar version = \"3.7.1\";\r\n// we duplicate it so it plays nicely with different module loading systems\r\nvar index = {\r\n    EMPTY_OBJ: EMPTY_OBJ,\r\n    NO_OP: NO_OP,\r\n    cloneVNode: cloneVNode,\r\n    createRenderer: createRenderer,\r\n    createVNode: createVNode,\r\n    findDOMNode: findDOMNode,\r\n    getFlagsForElementVnode: getFlagsForElementVnode,\r\n    internal_DOMNodeMap: componentToDOMNodeMap,\r\n    internal_isUnitlessNumber: isUnitlessNumber,\r\n    internal_normalize: normalize,\r\n    internal_patch: patch,\r\n    linkEvent: linkEvent,\r\n    options: options,\r\n    render: render,\r\n    version: version\r\n};\n\nexports['default'] = index;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nexports.NO_OP = NO_OP;\nexports.cloneVNode = cloneVNode;\nexports.createRenderer = createRenderer;\nexports.createVNode = createVNode;\nexports.findDOMNode = findDOMNode;\nexports.getFlagsForElementVnode = getFlagsForElementVnode;\nexports.internal_DOMNodeMap = componentToDOMNodeMap;\nexports.internal_isUnitlessNumber = isUnitlessNumber;\nexports.internal_normalize = normalize;\nexports.internal_patch = patch;\nexports.linkEvent = linkEvent;\nexports.options = options;\nexports.render = render;\nexports.version = version;\n\n\n/***/ })\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 18584ae5e3c32cc11972","import Inferno from 'inferno'\nimport { render } from 'inferno'\n\nrender(\n  <div>123</div>,\n  document.getElementById('app')\n)\n\n\n// WEBPACK FOOTER //\n// ./src/project1/page1/controller/index.web.js","module.exports = require('./dist').default;\nmodule.exports.default = module.exports;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_inferno@3.7.1@inferno/index.js\n// module id = 1\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * @module Inferno-Shared\r\n */ /** TypeDoc Comment */\r\nvar NO_OP = \"$NO_OP\";\r\nvar ERROR_MSG = \"a runtime error occured! Use Inferno in development environment to find the error.\";\r\n// This should be boolean and not reference to window.document\r\nvar isBrowser = !!(typeof window !== \"undefined\" && window.document);\r\n// this is MUCH faster than .constructor === Array and instanceof Array\r\n// in Node 7 and the later versions of V8, slower in older versions though\r\nvar isArray = Array.isArray;\r\nfunction isStatefulComponent(o) {\r\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\r\n}\r\nfunction isStringOrNumber(o) {\r\n    var type = typeof o;\r\n    return type === \"string\" || type === \"number\";\r\n}\r\nfunction isNullOrUndef(o) {\r\n    return isUndefined(o) || isNull(o);\r\n}\r\nfunction isInvalid(o) {\r\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\r\n}\r\nfunction isFunction(o) {\r\n    return typeof o === \"function\";\r\n}\r\nfunction isString(o) {\r\n    return typeof o === \"string\";\r\n}\r\nfunction isNumber(o) {\r\n    return typeof o === \"number\";\r\n}\r\nfunction isNull(o) {\r\n    return o === null;\r\n}\r\nfunction isTrue(o) {\r\n    return o === true;\r\n}\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\r\nfunction isObject(o) {\r\n    return typeof o === \"object\";\r\n}\r\nfunction throwError(message) {\r\n    if (!message) {\r\n        message = ERROR_MSG;\r\n    }\r\n    throw new Error((\"Inferno Error: \" + message));\r\n}\r\nfunction warning(message) {\r\n    // tslint:disable-next-line:no-console\r\n    console.warn(message);\r\n}\r\nfunction combineFrom(first, second) {\r\n    var out = {};\r\n    if (first) {\r\n        for (var key in first) {\r\n            out[key] = first[key];\r\n        }\r\n    }\r\n    if (second) {\r\n        for (var key$1 in second) {\r\n            out[key$1] = second[key$1];\r\n        }\r\n    }\r\n    return out;\r\n}\r\nfunction Lifecycle() {\r\n    this.listeners = [];\r\n}\r\nLifecycle.prototype.addListener = function addListener(callback) {\r\n    this.listeners.push(callback);\r\n};\r\nLifecycle.prototype.trigger = function trigger() {\r\n    var listeners = this.listeners;\r\n    var listener;\r\n    // We need to remove current listener from array when calling it, because more listeners might be added\r\n    while ((listener = listeners.shift())) {\r\n        listener();\r\n    }\r\n};\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar options = {\r\n    afterMount: null,\r\n    afterRender: null,\r\n    afterUpdate: null,\r\n    beforeRender: null,\r\n    beforeUnmount: null,\r\n    createVNode: null,\r\n    findDOMNodeEnabled: false,\r\n    recyclingEnabled: false,\r\n    roots: []\r\n};\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar xlinkNS = \"http://www.w3.org/1999/xlink\";\r\nvar xmlNS = \"http://www.w3.org/XML/1998/namespace\";\r\nvar svgNS = \"http://www.w3.org/2000/svg\";\r\nvar strictProps = new Set();\r\nstrictProps.add(\"volume\");\r\nstrictProps.add(\"defaultChecked\");\r\nvar booleanProps = new Set();\r\nbooleanProps.add(\"muted\");\r\nbooleanProps.add(\"scoped\");\r\nbooleanProps.add(\"loop\");\r\nbooleanProps.add(\"open\");\r\nbooleanProps.add(\"checked\");\r\nbooleanProps.add(\"default\");\r\nbooleanProps.add(\"capture\");\r\nbooleanProps.add(\"disabled\");\r\nbooleanProps.add(\"readOnly\");\r\nbooleanProps.add(\"required\");\r\nbooleanProps.add(\"autoplay\");\r\nbooleanProps.add(\"controls\");\r\nbooleanProps.add(\"seamless\");\r\nbooleanProps.add(\"reversed\");\r\nbooleanProps.add(\"allowfullscreen\");\r\nbooleanProps.add(\"novalidate\");\r\nbooleanProps.add(\"hidden\");\r\nbooleanProps.add(\"autoFocus\");\r\nbooleanProps.add(\"selected\");\r\nbooleanProps.add(\"indeterminate\");\r\nvar namespaces = new Map();\r\nnamespaces.set(\"xlink:href\", xlinkNS);\r\nnamespaces.set(\"xlink:arcrole\", xlinkNS);\r\nnamespaces.set(\"xlink:actuate\", xlinkNS);\r\nnamespaces.set(\"xlink:show\", xlinkNS);\r\nnamespaces.set(\"xlink:role\", xlinkNS);\r\nnamespaces.set(\"xlink:title\", xlinkNS);\r\nnamespaces.set(\"xlink:type\", xlinkNS);\r\nnamespaces.set(\"xml:base\", xmlNS);\r\nnamespaces.set(\"xml:lang\", xmlNS);\r\nnamespaces.set(\"xml:space\", xmlNS);\r\nvar isUnitlessNumber = new Set();\r\nisUnitlessNumber.add(\"animationIterationCount\");\r\nisUnitlessNumber.add(\"borderImageOutset\");\r\nisUnitlessNumber.add(\"borderImageSlice\");\r\nisUnitlessNumber.add(\"borderImageWidth\");\r\nisUnitlessNumber.add(\"boxFlex\");\r\nisUnitlessNumber.add(\"boxFlexGroup\");\r\nisUnitlessNumber.add(\"boxOrdinalGroup\");\r\nisUnitlessNumber.add(\"columnCount\");\r\nisUnitlessNumber.add(\"flex\");\r\nisUnitlessNumber.add(\"flexGrow\");\r\nisUnitlessNumber.add(\"flexPositive\");\r\nisUnitlessNumber.add(\"flexShrink\");\r\nisUnitlessNumber.add(\"flexNegative\");\r\nisUnitlessNumber.add(\"flexOrder\");\r\nisUnitlessNumber.add(\"gridRow\");\r\nisUnitlessNumber.add(\"gridColumn\");\r\nisUnitlessNumber.add(\"fontWeight\");\r\nisUnitlessNumber.add(\"lineClamp\");\r\nisUnitlessNumber.add(\"lineHeight\");\r\nisUnitlessNumber.add(\"opacity\");\r\nisUnitlessNumber.add(\"order\");\r\nisUnitlessNumber.add(\"orphans\");\r\nisUnitlessNumber.add(\"tabSize\");\r\nisUnitlessNumber.add(\"widows\");\r\nisUnitlessNumber.add(\"zIndex\");\r\nisUnitlessNumber.add(\"zoom\");\r\nisUnitlessNumber.add(\"fillOpacity\");\r\nisUnitlessNumber.add(\"floodOpacity\");\r\nisUnitlessNumber.add(\"stopOpacity\");\r\nisUnitlessNumber.add(\"strokeDasharray\");\r\nisUnitlessNumber.add(\"strokeDashoffset\");\r\nisUnitlessNumber.add(\"strokeMiterlimit\");\r\nisUnitlessNumber.add(\"strokeOpacity\");\r\nisUnitlessNumber.add(\"strokeWidth\");\r\nvar skipProps = new Set();\r\nskipProps.add(\"children\");\r\nskipProps.add(\"childrenType\");\r\nskipProps.add(\"defaultValue\");\r\nskipProps.add(\"ref\");\r\nskipProps.add(\"key\");\r\nskipProps.add(\"checked\");\r\nskipProps.add(\"multiple\");\r\nvar delegatedEvents = new Set();\r\ndelegatedEvents.add(\"onClick\");\r\ndelegatedEvents.add(\"onMouseDown\");\r\ndelegatedEvents.add(\"onMouseUp\");\r\ndelegatedEvents.add(\"onMouseMove\");\r\ndelegatedEvents.add(\"onSubmit\");\r\ndelegatedEvents.add(\"onDblClick\");\r\ndelegatedEvents.add(\"onKeyDown\");\r\ndelegatedEvents.add(\"onKeyUp\");\r\ndelegatedEvents.add(\"onKeyPress\");\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar isiOS = isBrowser &&\r\n    !!navigator.platform &&\r\n    /iPad|iPhone|iPod/.test(navigator.platform);\r\nvar delegatedEvents$1 = new Map();\r\nfunction handleEvent(name, lastEvent, nextEvent, dom) {\r\n    var delegatedRoots = delegatedEvents$1.get(name);\r\n    if (nextEvent) {\r\n        if (!delegatedRoots) {\r\n            delegatedRoots = { items: new Map(), docEvent: null };\r\n            delegatedRoots.docEvent = attachEventToDocument(name, delegatedRoots);\r\n            delegatedEvents$1.set(name, delegatedRoots);\r\n        }\r\n        if (!lastEvent) {\r\n            if (isiOS && name === \"onClick\") {\r\n                trapClickOnNonInteractiveElement(dom);\r\n            }\r\n        }\r\n        delegatedRoots.items.set(dom, nextEvent);\r\n    }\r\n    else if (delegatedRoots) {\r\n        var items = delegatedRoots.items;\r\n        if (items.delete(dom)) {\r\n            // If any items were deleted, check if listener need to be removed\r\n            if (items.size === 0) {\r\n                document.removeEventListener(normalizeEventName(name), delegatedRoots.docEvent);\r\n                delegatedEvents$1.delete(name);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction dispatchEvents(event, target, items, count, isClick, eventData) {\r\n    var dom = target;\r\n    while (count > 0) {\r\n        var eventsToTrigger = items.get(dom);\r\n        if (eventsToTrigger) {\r\n            count--;\r\n            // linkEvent object\r\n            eventData.dom = dom;\r\n            if (eventsToTrigger.event) {\r\n                eventsToTrigger.event(eventsToTrigger.data, event);\r\n            }\r\n            else {\r\n                eventsToTrigger(event);\r\n            }\r\n            if (event.cancelBubble) {\r\n                return;\r\n            }\r\n        }\r\n        dom = dom.parentNode;\r\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\r\n        // because the event listener is on document.body\r\n        // Don't process clicks on disabled elements\r\n        if (dom === null || (isClick && dom.disabled)) {\r\n            return;\r\n        }\r\n    }\r\n}\r\nfunction normalizeEventName(name) {\r\n    return name.substr(2).toLowerCase();\r\n}\r\nfunction stopPropagation() {\r\n    this.cancelBubble = true;\r\n    this.stopImmediatePropagation();\r\n}\r\nfunction attachEventToDocument(name, delegatedRoots) {\r\n    var docEvent = function (event) {\r\n        var count = delegatedRoots.items.size;\r\n        if (count > 0) {\r\n            event.stopPropagation = stopPropagation;\r\n            // Event data needs to be object to save reference to currentTarget getter\r\n            var eventData = {\r\n                dom: document\r\n            };\r\n            try {\r\n                Object.defineProperty(event, \"currentTarget\", {\r\n                    configurable: true,\r\n                    get: function get() {\r\n                        return eventData.dom;\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                /* safari7 and phantomJS will crash */\r\n            }\r\n            dispatchEvents(event, event.target, delegatedRoots.items, count, event.type === \"click\", eventData);\r\n        }\r\n    };\r\n    document.addEventListener(normalizeEventName(name), docEvent);\r\n    return docEvent;\r\n}\r\n// tslint:disable-next-line:no-empty\r\nfunction emptyFn() { }\r\nfunction trapClickOnNonInteractiveElement(dom) {\r\n    // Mobile Safari does not fire properly bubble click events on\r\n    // non-interactive elements, which means delegated click listeners do not\r\n    // fire. The workaround for this bug involves attaching an empty click\r\n    // listener on the target node.\r\n    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\r\n    // Just set it using the onclick property so that we don't have to manage any\r\n    // bookkeeping for it. Not sure if we need to clear it when the listener is\r\n    // removed.\r\n    // TODO: Only do this for the relevant Safaris maybe?\r\n    dom.onclick = emptyFn;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction isCheckedType(type) {\r\n    return type === \"checkbox\" || type === \"radio\";\r\n}\r\nfunction onTextInputChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    var previousValue = props.value;\r\n    if (props.onInput) {\r\n        var event = props.onInput;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.oninput) {\r\n        props.oninput(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue(newProps, dom);\r\n    }\r\n}\r\nfunction wrappedOnChange(e) {\r\n    var props = this.vNode.props || EMPTY_OBJ;\r\n    var event = props.onChange;\r\n    if (event.event) {\r\n        event.event(event.data, e);\r\n    }\r\n    else {\r\n        event(e);\r\n    }\r\n}\r\nfunction onCheckboxChange(e) {\r\n    e.stopPropagation(); // This click should not propagate its for internal use\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    if (props.onClick) {\r\n        var event = props.onClick;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.onclick) {\r\n        props.onclick(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    applyValue(newProps, dom);\r\n}\r\nfunction processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue(nextPropsOrEmpty, dom);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            if (isCheckedType(nextPropsOrEmpty.type)) {\r\n                dom.onclick = onCheckboxChange;\r\n                dom.onclick.wrapped = true;\r\n            }\r\n            else {\r\n                dom.oninput = onTextInputChange;\r\n                dom.oninput.wrapped = true;\r\n            }\r\n            if (nextPropsOrEmpty.onChange) {\r\n                dom.onchange = wrappedOnChange;\r\n                dom.onchange.wrapped = true;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyValue(nextPropsOrEmpty, dom) {\r\n    var type = nextPropsOrEmpty.type;\r\n    var value = nextPropsOrEmpty.value;\r\n    var checked = nextPropsOrEmpty.checked;\r\n    var multiple = nextPropsOrEmpty.multiple;\r\n    var defaultValue = nextPropsOrEmpty.defaultValue;\r\n    var hasValue = !isNullOrUndef(value);\r\n    if (type && type !== dom.type) {\r\n        dom.setAttribute(\"type\", type);\r\n    }\r\n    if (multiple && multiple !== dom.multiple) {\r\n        dom.multiple = multiple;\r\n    }\r\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\r\n        dom.defaultValue = defaultValue + \"\";\r\n    }\r\n    if (isCheckedType(type)) {\r\n        if (hasValue) {\r\n            dom.value = value;\r\n        }\r\n        if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n    else {\r\n        if (hasValue && dom.value !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n        else if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction updateChildOptionGroup(vNode, value) {\r\n    var type = vNode.type;\r\n    if (type === \"optgroup\") {\r\n        var children = vNode.children;\r\n        if (isArray(children)) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOption(children[i], value);\r\n            }\r\n        }\r\n        else if (isVNode(children)) {\r\n            updateChildOption(children, value);\r\n        }\r\n    }\r\n    else {\r\n        updateChildOption(vNode, value);\r\n    }\r\n}\r\nfunction updateChildOption(vNode, value) {\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    // we do this as multiple may have changed\r\n    dom.value = props.value;\r\n    if ((isArray(value) && value.indexOf(props.value) !== -1) ||\r\n        props.value === value) {\r\n        dom.selected = true;\r\n    }\r\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\r\n        dom.selected = props.selected || false;\r\n    }\r\n}\r\nfunction onSelectChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    var previousValue = props.value;\r\n    if (props.onChange) {\r\n        var event = props.onChange;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.onchange) {\r\n        props.onchange(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue$1(newVNode, dom, newProps, false);\r\n    }\r\n}\r\nfunction processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue$1(vNode, dom, nextPropsOrEmpty, mounting);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            dom.onchange = onSelectChange;\r\n            dom.onchange.wrapped = true;\r\n        }\r\n    }\r\n}\r\nfunction applyValue$1(vNode, dom, nextPropsOrEmpty, mounting) {\r\n    if (nextPropsOrEmpty.multiple !== dom.multiple) {\r\n        dom.multiple = nextPropsOrEmpty.multiple;\r\n    }\r\n    var children = vNode.children;\r\n    if (!isInvalid(children)) {\r\n        var value = nextPropsOrEmpty.value;\r\n        if (mounting && isNullOrUndef(value)) {\r\n            value = nextPropsOrEmpty.defaultValue;\r\n        }\r\n        if (isArray(children)) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOptionGroup(children[i], value);\r\n            }\r\n        }\r\n        else if (isVNode(children)) {\r\n            updateChildOptionGroup(children, value);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction wrappedOnChange$1(e) {\r\n    var props = this.vNode.props || EMPTY_OBJ;\r\n    var event = props.onChange;\r\n    if (event.event) {\r\n        event.event(event.data, e);\r\n    }\r\n    else {\r\n        event(e);\r\n    }\r\n}\r\nfunction onTextareaInputChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var previousValue = props.value;\r\n    if (props.onInput) {\r\n        var event = props.onInput;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.oninput) {\r\n        props.oninput(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue$2(newVNode, vNode.dom, false);\r\n    }\r\n}\r\nfunction processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue$2(nextPropsOrEmpty, dom, mounting);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            dom.oninput = onTextareaInputChange;\r\n            dom.oninput.wrapped = true;\r\n            if (nextPropsOrEmpty.onChange) {\r\n                dom.onchange = wrappedOnChange$1;\r\n                dom.onchange.wrapped = true;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyValue$2(nextPropsOrEmpty, dom, mounting) {\r\n    var value = nextPropsOrEmpty.value;\r\n    var domValue = dom.value;\r\n    if (isNullOrUndef(value)) {\r\n        if (mounting) {\r\n            var defaultValue = nextPropsOrEmpty.defaultValue;\r\n            if (!isNullOrUndef(defaultValue)) {\r\n                if (defaultValue !== domValue) {\r\n                    dom.defaultValue = defaultValue;\r\n                    dom.value = defaultValue;\r\n                }\r\n            }\r\n            else if (domValue !== \"\") {\r\n                dom.defaultValue = \"\";\r\n                dom.value = \"\";\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        /* There is value so keep it controlled */\r\n        if (domValue !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * There is currently no support for switching same input between controlled and nonControlled\r\n * If that ever becomes a real issue, then re design controlled elements\r\n * Currently user must choose either controlled or non-controlled and stick with that\r\n */\r\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    if (flags & 512 /* InputElement */) {\r\n        processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n    if (flags & 2048 /* SelectElement */) {\r\n        processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n    if (flags & 1024 /* TextareaElement */) {\r\n        processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n}\r\nfunction isControlledFormElement(nextPropsOrEmpty) {\r\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type)\r\n        ? !isNullOrUndef(nextPropsOrEmpty.checked)\r\n        : !isNullOrUndef(nextPropsOrEmpty.value);\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction normalizeChildNodes(parentDom) {\r\n    var dom = parentDom.firstChild;\r\n    while (dom) {\r\n        if (dom.nodeType === 8) {\r\n            if (dom.data === \"!\") {\r\n                var placeholder = document.createTextNode(\"\");\r\n                parentDom.replaceChild(placeholder, dom);\r\n                dom = dom.nextSibling;\r\n            }\r\n            else {\r\n                var lastDom = dom.previousSibling;\r\n                parentDom.removeChild(dom);\r\n                dom = lastDom || parentDom.firstChild;\r\n            }\r\n        }\r\n        else {\r\n            dom = dom.nextSibling;\r\n        }\r\n    }\r\n}\r\nfunction hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {\r\n    var type = vNode.type;\r\n    var ref = vNode.ref;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    if (isClass) {\r\n        var _isSVG = dom.namespaceURI === svgNS;\r\n        var instance = createClassComponentInstance(vNode, type, props, context, _isSVG, lifecycle);\r\n        var input = instance._lastInput;\r\n        instance._vNode = vNode;\r\n        hydrate(input, dom, lifecycle, instance._childContext, _isSVG);\r\n        vNode.dom = input.dom;\r\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\r\n        instance._updating = false; // Mount finished allow going sync\r\n        if (options.findDOMNodeEnabled) {\r\n            componentToDOMNodeMap.set(instance, dom);\r\n        }\r\n    }\r\n    else {\r\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\r\n        hydrate(input$1, dom, lifecycle, context, isSVG);\r\n        vNode.children = input$1;\r\n        vNode.dom = input$1.dom;\r\n        mountFunctionalComponentCallbacks(props, ref, dom, lifecycle);\r\n    }\r\n    return dom;\r\n}\r\nfunction hydrateElement(vNode, dom, lifecycle, context, isSVG) {\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var flags = vNode.flags;\r\n    var ref = vNode.ref;\r\n    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;\r\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warning(\"Inferno hydration: Server-side markup doesn't match client-side markup or Initial render target is not empty\");\r\n        }\r\n        var newDom = mountElement(vNode, null, lifecycle, context, isSVG);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n        return newDom;\r\n    }\r\n    vNode.dom = dom;\r\n    if (!isInvalid(children)) {\r\n        hydrateChildren(children, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (dom.firstChild !== null) {\r\n        dom.textContent = \"\"; // dom has content, but VNode has no children remove everything from DOM\r\n    }\r\n    if (props) {\r\n        var hasControlledValue = false;\r\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\r\n        if (isFormElement) {\r\n            hasControlledValue = isControlledFormElement(props);\r\n        }\r\n        for (var prop in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\r\n        }\r\n        if (isFormElement) {\r\n            processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n        }\r\n    }\r\n    if (!isNullOrUndef(className)) {\r\n        if (isSVG) {\r\n            dom.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    else {\r\n        if (dom.className !== \"\") {\r\n            dom.removeAttribute(\"class\");\r\n        }\r\n    }\r\n    if (ref) {\r\n        mountRef(dom, ref, lifecycle);\r\n    }\r\n    return dom;\r\n}\r\nfunction hydrateChildren(children, parentDom, lifecycle, context, isSVG) {\r\n    normalizeChildNodes(parentDom);\r\n    var dom = parentDom.firstChild;\r\n    if (isStringOrNumber(children)) {\r\n        if (!isNull(dom) && dom.nodeType === 3) {\r\n            if (dom.nodeValue !== children) {\r\n                dom.nodeValue = children;\r\n            }\r\n        }\r\n        else if (children === \"\") {\r\n            parentDom.appendChild(document.createTextNode(\"\"));\r\n        }\r\n        else {\r\n            parentDom.textContent = children;\r\n        }\r\n        if (!isNull(dom)) {\r\n            dom = dom.nextSibling;\r\n        }\r\n    }\r\n    else if (isArray(children)) {\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            if (!isNull(child) && isObject(child)) {\r\n                if (!isNull(dom)) {\r\n                    var nextSibling = dom.nextSibling;\r\n                    hydrate(child, dom, lifecycle, context, isSVG);\r\n                    dom = nextSibling;\r\n                }\r\n                else {\r\n                    mount(child, parentDom, lifecycle, context, isSVG);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // It's VNode\r\n        if (!isNull(dom)) {\r\n            hydrate(children, dom, lifecycle, context, isSVG);\r\n            dom = dom.nextSibling;\r\n        }\r\n        else {\r\n            mount(children, parentDom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    // clear any other DOM nodes, there should be only a single entry for the root\r\n    while (dom) {\r\n        var nextSibling$1 = dom.nextSibling;\r\n        parentDom.removeChild(dom);\r\n        dom = nextSibling$1;\r\n    }\r\n}\r\nfunction hydrateText(vNode, dom) {\r\n    if (dom.nodeType !== 3) {\r\n        var newDom = mountText(vNode, null);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n        return newDom;\r\n    }\r\n    var text = vNode.children;\r\n    if (dom.nodeValue !== text) {\r\n        dom.nodeValue = text;\r\n    }\r\n    vNode.dom = dom;\r\n    return dom;\r\n}\r\nfunction hydrateVoid(vNode, dom) {\r\n    vNode.dom = dom;\r\n    return dom;\r\n}\r\nfunction hydrate(vNode, dom, lifecycle, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 28 /* Component */) {\r\n        hydrateComponent(vNode, dom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        hydrateElement(vNode, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        hydrateText(vNode, dom);\r\n    }\r\n    else if (flags & 4096 /* Void */) {\r\n        hydrateVoid(vNode, dom);\r\n    }\r\n    else {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError((\"hydrate() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\r\n        }\r\n        throwError();\r\n    }\r\n}\r\nfunction hydrateRoot(input, parentDom, lifecycle) {\r\n    if (!isNull(parentDom)) {\r\n        var dom = parentDom.firstChild;\r\n        if (!isNull(dom)) {\r\n            hydrate(input, dom, lifecycle, EMPTY_OBJ, false);\r\n            dom = parentDom.firstChild;\r\n            // clear any other DOM nodes, there should be only a single entry for the root\r\n            while ((dom = dom.nextSibling)) {\r\n                parentDom.removeChild(dom);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar componentPools = new Map();\r\nvar elementPools = new Map();\r\nfunction recycleElement(vNode, lifecycle, context, isSVG) {\r\n    var tag = vNode.type;\r\n    var pools = elementPools.get(tag);\r\n    if (!isUndefined(pools)) {\r\n        var key = vNode.key;\r\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\r\n        if (!isUndefined(pool)) {\r\n            var recycledVNode = pool.pop();\r\n            if (!isUndefined(recycledVNode)) {\r\n                patchElement(recycledVNode, vNode, null, lifecycle, context, isSVG, true);\r\n                return vNode.dom;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction poolElement(vNode) {\r\n    var tag = vNode.type;\r\n    var key = vNode.key;\r\n    var pools = elementPools.get(tag);\r\n    if (isUndefined(pools)) {\r\n        pools = {\r\n            keyed: new Map(),\r\n            nonKeyed: []\r\n        };\r\n        elementPools.set(tag, pools);\r\n    }\r\n    if (isNull(key)) {\r\n        pools.nonKeyed.push(vNode);\r\n    }\r\n    else {\r\n        var pool = pools.keyed.get(key);\r\n        if (isUndefined(pool)) {\r\n            pool = [];\r\n            pools.keyed.set(key, pool);\r\n        }\r\n        pool.push(vNode);\r\n    }\r\n}\r\nfunction recycleComponent(vNode, lifecycle, context, isSVG) {\r\n    var type = vNode.type;\r\n    var pools = componentPools.get(type);\r\n    if (!isUndefined(pools)) {\r\n        var key = vNode.key;\r\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\r\n        if (!isUndefined(pool)) {\r\n            var recycledVNode = pool.pop();\r\n            if (!isUndefined(recycledVNode)) {\r\n                var flags = vNode.flags;\r\n                var failed = patchComponent(recycledVNode, vNode, null, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0, true);\r\n                if (!failed) {\r\n                    return vNode.dom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction poolComponent(vNode) {\r\n    var hooks = vNode.ref;\r\n    var nonRecycleHooks = hooks &&\r\n        (hooks.onComponentWillMount ||\r\n            hooks.onComponentWillUnmount ||\r\n            hooks.onComponentDidMount ||\r\n            hooks.onComponentWillUpdate ||\r\n            hooks.onComponentDidUpdate);\r\n    if (nonRecycleHooks) {\r\n        return;\r\n    }\r\n    var type = vNode.type;\r\n    var key = vNode.key;\r\n    var pools = componentPools.get(type);\r\n    if (isUndefined(pools)) {\r\n        pools = {\r\n            keyed: new Map(),\r\n            nonKeyed: []\r\n        };\r\n        componentPools.set(type, pools);\r\n    }\r\n    if (isNull(key)) {\r\n        pools.nonKeyed.push(vNode);\r\n    }\r\n    else {\r\n        var pool = pools.keyed.get(key);\r\n        if (isUndefined(pool)) {\r\n            pool = [];\r\n            pools.keyed.set(key, pool);\r\n        }\r\n        pool.push(vNode);\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction unmount(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var flags = vNode.flags;\r\n    if (flags & 28 /* Component */) {\r\n        unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling);\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling);\r\n    }\r\n    else if (flags & (1 /* Text */ | 4096 /* Void */)) {\r\n        unmountVoidOrText(vNode, parentDom);\r\n    }\r\n}\r\nfunction unmountVoidOrText(vNode, parentDom) {\r\n    if (!isNull(parentDom)) {\r\n        removeChild(parentDom, vNode.dom);\r\n    }\r\n}\r\nfunction unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var instance = vNode.children;\r\n    var flags = vNode.flags;\r\n    var isStatefulComponent$$1 = flags & 4;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var ref = vNode.ref;\r\n    var dom = vNode.dom;\r\n    if (!isRecycling) {\r\n        if (isStatefulComponent$$1) {\r\n            if (!instance._unmounted) {\r\n                if (!isNull(options.beforeUnmount)) {\r\n                    options.beforeUnmount(vNode);\r\n                }\r\n                if (!isUndefined(instance.componentWillUnmount)) {\r\n                    instance.componentWillUnmount();\r\n                }\r\n                if (ref && !isRecycling) {\r\n                    ref(null);\r\n                }\r\n                instance._unmounted = true;\r\n                if (options.findDOMNodeEnabled) {\r\n                    componentToDOMNodeMap.delete(instance);\r\n                }\r\n                unmount(instance._lastInput, null, instance._lifecycle, false, isRecycling);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndef(ref)) {\r\n                if (!isNullOrUndef(ref.onComponentWillUnmount)) {\r\n                    ref.onComponentWillUnmount(dom, props);\r\n                }\r\n            }\r\n            unmount(instance, null, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n    if (parentDom) {\r\n        removeChild(parentDom, dom);\r\n    }\r\n    if (options.recyclingEnabled &&\r\n        !isStatefulComponent$$1 &&\r\n        (parentDom || canRecycle)) {\r\n        poolComponent(vNode);\r\n    }\r\n}\r\nfunction unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var dom = vNode.dom;\r\n    var ref = vNode.ref;\r\n    var props = vNode.props;\r\n    if (ref && !isRecycling) {\r\n        unmountRef(ref);\r\n    }\r\n    var children = vNode.children;\r\n    if (!isNullOrUndef(children)) {\r\n        unmountChildren$1(children, lifecycle, isRecycling);\r\n    }\r\n    if (!isNull(props)) {\r\n        for (var name in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            if (props[name] !== null && isAttrAnEvent(name)) {\r\n                patchEvent(name, props[name], null, dom);\r\n                // We need to set this null, because same props otherwise come back if SCU returns false and we are recyling\r\n                props[name] = null;\r\n            }\r\n        }\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        removeChild(parentDom, dom);\r\n    }\r\n    if (options.recyclingEnabled && (parentDom || canRecycle)) {\r\n        poolElement(vNode);\r\n    }\r\n}\r\nfunction unmountChildren$1(children, lifecycle, isRecycling) {\r\n    if (isArray(children)) {\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            if (!isInvalid(child) && isObject(child)) {\r\n                unmount(child, null, lifecycle, false, isRecycling);\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(children)) {\r\n        unmount(children, null, lifecycle, false, isRecycling);\r\n    }\r\n}\r\nfunction unmountRef(ref) {\r\n    if (isFunction(ref)) {\r\n        ref(null);\r\n    }\r\n    else {\r\n        if (isInvalid(ref)) {\r\n            return;\r\n        }\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n        }\r\n        throwError();\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n// rather than use a Map, like we did before, we can use an array here\r\n// given there shouldn't be THAT many roots on the page, the difference\r\n// in performance is huge: https://esbench.com/bench/5802a691330ab09900a1a2da\r\nvar componentToDOMNodeMap = new Map();\r\nvar roots = options.roots;\r\n/**\r\n * When inferno.options.findDOMNOdeEnabled is true, this function will return DOM Node by component instance\r\n * @param ref Component instance\r\n * @returns {*|null} returns dom node\r\n */\r\nfunction findDOMNode(ref) {\r\n    if (!options.findDOMNodeEnabled) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(\"findDOMNode() has been disabled, use Inferno.options.findDOMNodeEnabled = true; enabled findDOMNode(). Warning this can significantly impact performance!\");\r\n        }\r\n        throwError();\r\n    }\r\n    var dom = ref && ref.nodeType ? ref : null;\r\n    return componentToDOMNodeMap.get(ref) || dom;\r\n}\r\nfunction getRoot(dom) {\r\n    for (var i = 0, len = roots.length; i < len; i++) {\r\n        var root = roots[i];\r\n        if (root.dom === dom) {\r\n            return root;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction setRoot(dom, input, lifecycle) {\r\n    var root = {\r\n        dom: dom,\r\n        input: input,\r\n        lifecycle: lifecycle\r\n    };\r\n    roots.push(root);\r\n    return root;\r\n}\r\nfunction removeRoot(root) {\r\n    for (var i = 0, len = roots.length; i < len; i++) {\r\n        if (roots[i] === root) {\r\n            roots.splice(i, 1);\r\n            return;\r\n        }\r\n    }\r\n}\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    if (isBrowser && document.body === null) {\r\n        warning('Inferno warning: you cannot initialize inferno without \"document.body\". Wait on \"DOMContentLoaded\" event, add script to bottom of body, or use async/defer attributes on script tag.');\r\n    }\r\n}\r\nvar documentBody = isBrowser ? document.body : null;\r\n/**\r\n * Renders virtual node tree into parent node.\r\n * @param {VNode | null | string | number} input vNode to be rendered\r\n * @param parentDom DOM node which content will be replaced by virtual node\r\n * @returns {InfernoChildren} rendered virtual node\r\n */\r\nfunction render(input, parentDom) {\r\n    if (documentBody === parentDom) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError('you cannot render() to the \"document.body\". Use an empty element as a container instead.');\r\n        }\r\n        throwError();\r\n    }\r\n    if (input === NO_OP) {\r\n        return;\r\n    }\r\n    var root = getRoot(parentDom);\r\n    if (isNull(root)) {\r\n        var lifecycle = new Lifecycle();\r\n        if (!isInvalid(input)) {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            if (!hydrateRoot(input, parentDom, lifecycle)) {\r\n                mount(input, parentDom, lifecycle, EMPTY_OBJ, false);\r\n            }\r\n            root = setRoot(parentDom, input, lifecycle);\r\n            lifecycle.trigger();\r\n        }\r\n    }\r\n    else {\r\n        var lifecycle$1 = root.lifecycle;\r\n        lifecycle$1.listeners = [];\r\n        if (isNullOrUndef(input)) {\r\n            unmount(root.input, parentDom, lifecycle$1, false, false);\r\n            removeRoot(root);\r\n        }\r\n        else {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            patch(root.input, input, parentDom, lifecycle$1, EMPTY_OBJ, false, false);\r\n        }\r\n        root.input = input;\r\n        lifecycle$1.trigger();\r\n    }\r\n    if (root) {\r\n        var rootInput = root.input;\r\n        if (rootInput && rootInput.flags & 28 /* Component */) {\r\n            return rootInput.children;\r\n        }\r\n    }\r\n}\r\nfunction createRenderer(parentDom) {\r\n    return function renderer(lastInput, nextInput) {\r\n        if (!parentDom) {\r\n            parentDom = lastInput;\r\n        }\r\n        render(nextInput, parentDom);\r\n    };\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    if (lastVNode !== nextVNode) {\r\n        var lastFlags = lastVNode.flags;\r\n        var nextFlags = nextVNode.flags;\r\n        if (nextFlags & 28 /* Component */) {\r\n            var isClass = (nextFlags & 4 /* ComponentClass */) > 0;\r\n            if (lastFlags & 28 /* Component */) {\r\n                patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, isClass), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 3970 /* Element */) {\r\n            if (lastFlags & 3970 /* Element */) {\r\n                patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountElement(nextVNode, null, lifecycle, context, isSVG), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 1 /* Text */) {\r\n            if (lastFlags & 1 /* Text */) {\r\n                patchText(lastVNode, nextVNode);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountText(nextVNode, null), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 4096 /* Void */) {\r\n            if (lastFlags & 4096 /* Void */) {\r\n                patchVoid(lastVNode, nextVNode);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountVoid(nextVNode, null), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else {\r\n            // Error case: mount new one replacing old one\r\n            replaceLastChildAndUnmount(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction unmountChildren(children, dom, lifecycle, isRecycling) {\r\n    if (isVNode(children)) {\r\n        unmount(children, dom, lifecycle, true, isRecycling);\r\n    }\r\n    else if (isArray(children)) {\r\n        removeAllChildren(dom, children, lifecycle, isRecycling);\r\n    }\r\n    else {\r\n        dom.textContent = \"\";\r\n    }\r\n}\r\nfunction patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    var nextTag = nextVNode.type;\r\n    var lastTag = lastVNode.type;\r\n    if (lastTag !== nextTag) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n    }\r\n    else {\r\n        var dom = lastVNode.dom;\r\n        var lastProps = lastVNode.props;\r\n        var nextProps = nextVNode.props;\r\n        var lastChildren = lastVNode.children;\r\n        var nextChildren = nextVNode.children;\r\n        var lastFlags = lastVNode.flags;\r\n        var nextFlags = nextVNode.flags;\r\n        var nextRef = nextVNode.ref;\r\n        var lastClassName = lastVNode.className;\r\n        var nextClassName = nextVNode.className;\r\n        nextVNode.dom = dom;\r\n        isSVG = isSVG || (nextFlags & 128 /* SvgElement */) > 0;\r\n        if (lastChildren !== nextChildren) {\r\n            var childrenIsSVG = isSVG === true && nextVNode.type !== \"foreignObject\";\r\n            patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, childrenIsSVG, isRecycling);\r\n        }\r\n        // inlined patchProps  -- starts --\r\n        if (lastProps !== nextProps) {\r\n            var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\r\n            var nextPropsOrEmpty = nextProps || EMPTY_OBJ;\r\n            var hasControlledValue = false;\r\n            if (nextPropsOrEmpty !== EMPTY_OBJ) {\r\n                var isFormElement = (nextFlags & 3584 /* FormElement */) > 0;\r\n                if (isFormElement) {\r\n                    hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\r\n                }\r\n                for (var prop in nextPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    var nextValue = nextPropsOrEmpty[prop];\r\n                    var lastValue = lastPropsOrEmpty[prop];\r\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue);\r\n                }\r\n                if (isFormElement) {\r\n                    // When inferno is recycling form element, we need to process it like it would be mounting\r\n                    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, isRecycling, hasControlledValue);\r\n                }\r\n            }\r\n            if (lastPropsOrEmpty !== EMPTY_OBJ) {\r\n                for (var prop$1 in lastPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    if (isNullOrUndef(nextPropsOrEmpty[prop$1]) &&\r\n                        !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\r\n                        removeProp(prop$1, lastPropsOrEmpty[prop$1], dom, nextFlags);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // inlined patchProps  -- ends --\r\n        if (lastClassName !== nextClassName) {\r\n            if (isNullOrUndef(nextClassName)) {\r\n                dom.removeAttribute(\"class\");\r\n            }\r\n            else {\r\n                if (isSVG) {\r\n                    dom.setAttribute(\"class\", nextClassName);\r\n                }\r\n                else {\r\n                    dom.className = nextClassName;\r\n                }\r\n            }\r\n        }\r\n        if (nextRef) {\r\n            if (lastVNode.ref !== nextRef || isRecycling) {\r\n                mountRef(dom, nextRef, lifecycle);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var patchArray = false;\r\n    var patchKeyed = false;\r\n    if (nextFlags & 64 /* HasNonKeyedChildren */) {\r\n        patchArray = true;\r\n    }\r\n    else if ((lastFlags & 32 /* HasKeyedChildren */) > 0 &&\r\n        (nextFlags & 32 /* HasKeyedChildren */) > 0) {\r\n        patchKeyed = true;\r\n        patchArray = true;\r\n    }\r\n    else if (isInvalid(nextChildren)) {\r\n        unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n    }\r\n    else if (isInvalid(lastChildren)) {\r\n        if (isStringOrNumber(nextChildren)) {\r\n            setTextContent(dom, nextChildren);\r\n        }\r\n        else {\r\n            if (isArray(nextChildren)) {\r\n                mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\r\n            }\r\n            else {\r\n                mount(nextChildren, dom, lifecycle, context, isSVG);\r\n            }\r\n        }\r\n    }\r\n    else if (isStringOrNumber(nextChildren)) {\r\n        if (isStringOrNumber(lastChildren)) {\r\n            updateTextContent(dom, nextChildren);\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            setTextContent(dom, nextChildren);\r\n        }\r\n    }\r\n    else if (isArray(nextChildren)) {\r\n        if (isArray(lastChildren)) {\r\n            patchArray = true;\r\n            if (isKeyed(lastChildren, nextChildren)) {\r\n                patchKeyed = true;\r\n            }\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    else if (isArray(lastChildren)) {\r\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\r\n        mount(nextChildren, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (isVNode(nextChildren)) {\r\n        if (isVNode(lastChildren)) {\r\n            patch(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            mount(nextChildren, dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    if (patchArray) {\r\n        if (patchKeyed) {\r\n            patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n        else {\r\n            patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling) {\r\n    var lastType = lastVNode.type;\r\n    var nextType = nextVNode.type;\r\n    var lastKey = lastVNode.key;\r\n    var nextKey = nextVNode.key;\r\n    if (lastType !== nextType || lastKey !== nextKey) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n        return false;\r\n    }\r\n    else {\r\n        var nextProps = nextVNode.props || EMPTY_OBJ;\r\n        if (isClass) {\r\n            var instance = lastVNode.children;\r\n            instance._updating = true;\r\n            if (instance._unmounted) {\r\n                if (isNull(parentDom)) {\r\n                    return true;\r\n                }\r\n                replaceChild(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, (nextVNode.flags & 4 /* ComponentClass */) > 0), lastVNode.dom);\r\n            }\r\n            else {\r\n                var hasComponentDidUpdate = !isUndefined(instance.componentDidUpdate);\r\n                var nextState = instance.state;\r\n                // When component has componentDidUpdate hook, we need to clone lastState or will be modified by reference during update\r\n                var lastState = hasComponentDidUpdate\r\n                    ? combineFrom(nextState, null)\r\n                    : nextState;\r\n                var lastProps = instance.props;\r\n                var childContext;\r\n                if (!isNullOrUndef(instance.getChildContext)) {\r\n                    childContext = instance.getChildContext();\r\n                }\r\n                nextVNode.children = instance;\r\n                instance._isSVG = isSVG;\r\n                if (isNullOrUndef(childContext)) {\r\n                    childContext = context;\r\n                }\r\n                else {\r\n                    childContext = combineFrom(context, childContext);\r\n                }\r\n                var lastInput = instance._lastInput;\r\n                var nextInput = instance._updateComponent(lastState, nextState, lastProps, nextProps, context, false, false);\r\n                var didUpdate = true;\r\n                instance._childContext = childContext;\r\n                if (isInvalid(nextInput)) {\r\n                    nextInput = createVoidVNode();\r\n                }\r\n                else if (nextInput === NO_OP) {\r\n                    nextInput = lastInput;\r\n                    didUpdate = false;\r\n                }\r\n                else if (isStringOrNumber(nextInput)) {\r\n                    nextInput = createTextVNode(nextInput, null);\r\n                }\r\n                else if (isArray(nextInput)) {\r\n                    if (process.env.NODE_ENV !== \"production\") {\r\n                        throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n                    }\r\n                    throwError();\r\n                }\r\n                else if (isObject(nextInput)) {\r\n                    if (!isNull(nextInput.dom)) {\r\n                        nextInput = directClone(nextInput);\r\n                    }\r\n                }\r\n                if (nextInput.flags & 28 /* Component */) {\r\n                    nextInput.parentVNode = nextVNode;\r\n                }\r\n                else if (lastInput.flags & 28 /* Component */) {\r\n                    lastInput.parentVNode = nextVNode;\r\n                }\r\n                instance._lastInput = nextInput;\r\n                instance._vNode = nextVNode;\r\n                if (didUpdate) {\r\n                    patch(lastInput, nextInput, parentDom, lifecycle, childContext, isSVG, isRecycling);\r\n                    if (hasComponentDidUpdate && instance.componentDidUpdate) {\r\n                        instance.componentDidUpdate(lastProps, lastState);\r\n                    }\r\n                    if (!isNull(options.afterUpdate)) {\r\n                        options.afterUpdate(nextVNode);\r\n                    }\r\n                    if (options.findDOMNodeEnabled) {\r\n                        componentToDOMNodeMap.set(instance, nextInput.dom);\r\n                    }\r\n                }\r\n                nextVNode.dom = nextInput.dom;\r\n            }\r\n            instance._updating = false;\r\n        }\r\n        else {\r\n            var shouldUpdate = true;\r\n            var lastProps$1 = lastVNode.props;\r\n            var nextHooks = nextVNode.ref;\r\n            var nextHooksDefined = !isNullOrUndef(nextHooks);\r\n            var lastInput$1 = lastVNode.children;\r\n            var nextInput$1 = lastInput$1;\r\n            nextVNode.dom = lastVNode.dom;\r\n            nextVNode.children = lastInput$1;\r\n            if (lastKey !== nextKey) {\r\n                shouldUpdate = true;\r\n            }\r\n            else {\r\n                if (nextHooksDefined &&\r\n                    !isNullOrUndef(nextHooks.onComponentShouldUpdate)) {\r\n                    shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps$1, nextProps);\r\n                }\r\n            }\r\n            if (shouldUpdate !== false) {\r\n                if (nextHooksDefined &&\r\n                    !isNullOrUndef(nextHooks.onComponentWillUpdate)) {\r\n                    nextHooks.onComponentWillUpdate(lastProps$1, nextProps);\r\n                }\r\n                nextInput$1 = nextType(nextProps, context);\r\n                if (isInvalid(nextInput$1)) {\r\n                    nextInput$1 = createVoidVNode();\r\n                }\r\n                else if (isStringOrNumber(nextInput$1) && nextInput$1 !== NO_OP) {\r\n                    nextInput$1 = createTextVNode(nextInput$1, null);\r\n                }\r\n                else if (isArray(nextInput$1)) {\r\n                    if (process.env.NODE_ENV !== \"production\") {\r\n                        throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n                    }\r\n                    throwError();\r\n                }\r\n                else if (isObject(nextInput$1)) {\r\n                    if (!isNull(nextInput$1.dom)) {\r\n                        nextInput$1 = directClone(nextInput$1);\r\n                    }\r\n                }\r\n                if (nextInput$1 !== NO_OP) {\r\n                    patch(lastInput$1, nextInput$1, parentDom, lifecycle, context, isSVG, isRecycling);\r\n                    nextVNode.children = nextInput$1;\r\n                    if (nextHooksDefined &&\r\n                        !isNullOrUndef(nextHooks.onComponentDidUpdate)) {\r\n                        nextHooks.onComponentDidUpdate(lastProps$1, nextProps);\r\n                    }\r\n                    nextVNode.dom = nextInput$1.dom;\r\n                }\r\n            }\r\n            if (nextInput$1.flags & 28 /* Component */) {\r\n                nextInput$1.parentVNode = nextVNode;\r\n            }\r\n            else if (lastInput$1.flags & 28 /* Component */) {\r\n                lastInput$1.parentVNode = nextVNode;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction patchText(lastVNode, nextVNode) {\r\n    var nextText = nextVNode.children;\r\n    var dom = lastVNode.dom;\r\n    nextVNode.dom = dom;\r\n    if (lastVNode.children !== nextText) {\r\n        dom.nodeValue = nextText;\r\n    }\r\n}\r\nfunction patchVoid(lastVNode, nextVNode) {\r\n    nextVNode.dom = lastVNode.dom;\r\n}\r\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var lastChildrenLength = lastChildren.length;\r\n    var nextChildrenLength = nextChildren.length;\r\n    var commonLength = lastChildrenLength > nextChildrenLength\r\n        ? nextChildrenLength\r\n        : lastChildrenLength;\r\n    var i = 0;\r\n    for (; i < commonLength; i++) {\r\n        var nextChild = nextChildren[i];\r\n        if (nextChild.dom) {\r\n            nextChild = nextChildren[i] = directClone(nextChild);\r\n        }\r\n        patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG, isRecycling);\r\n    }\r\n    if (lastChildrenLength < nextChildrenLength) {\r\n        for (i = commonLength; i < nextChildrenLength; i++) {\r\n            var nextChild$1 = nextChildren[i];\r\n            if (nextChild$1.dom) {\r\n                nextChild$1 = nextChildren[i] = directClone(nextChild$1);\r\n            }\r\n            appendChild(dom, mount(nextChild$1, null, lifecycle, context, isSVG));\r\n        }\r\n    }\r\n    else if (nextChildrenLength === 0) {\r\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\r\n    }\r\n    else if (lastChildrenLength > nextChildrenLength) {\r\n        for (i = commonLength; i < lastChildrenLength; i++) {\r\n            unmount(lastChildren[i], dom, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var aLength = a.length;\r\n    var bLength = b.length;\r\n    var aEnd = aLength - 1;\r\n    var bEnd = bLength - 1;\r\n    var aStart = 0;\r\n    var bStart = 0;\r\n    var i;\r\n    var j;\r\n    var aNode;\r\n    var bNode;\r\n    var nextNode;\r\n    var nextPos;\r\n    var node;\r\n    if (aLength === 0) {\r\n        if (bLength > 0) {\r\n            mountArrayChildren(b, dom, lifecycle, context, isSVG);\r\n        }\r\n        return;\r\n    }\r\n    else if (bLength === 0) {\r\n        removeAllChildren(dom, a, lifecycle, isRecycling);\r\n        return;\r\n    }\r\n    var aStartNode = a[aStart];\r\n    var bStartNode = b[bStart];\r\n    var aEndNode = a[aEnd];\r\n    var bEndNode = b[bEnd];\r\n    if (bStartNode.dom) {\r\n        b[bStart] = bStartNode = directClone(bStartNode);\r\n    }\r\n    if (bEndNode.dom) {\r\n        b[bEnd] = bEndNode = directClone(bEndNode);\r\n    }\r\n    // Step 1\r\n    /* eslint no-constant-condition: 0 */\r\n    outer: while (true) {\r\n        // Sync nodes with the same key at the beginning.\r\n        while (aStartNode.key === bStartNode.key) {\r\n            patch(aStartNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            aStart++;\r\n            bStart++;\r\n            if (aStart > aEnd || bStart > bEnd) {\r\n                break outer;\r\n            }\r\n            aStartNode = a[aStart];\r\n            bStartNode = b[bStart];\r\n            if (bStartNode.dom) {\r\n                b[bStart] = bStartNode = directClone(bStartNode);\r\n            }\r\n        }\r\n        // Sync nodes with the same key at the end.\r\n        while (aEndNode.key === bEndNode.key) {\r\n            patch(aEndNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            aEnd--;\r\n            bEnd--;\r\n            if (aStart > aEnd || bStart > bEnd) {\r\n                break outer;\r\n            }\r\n            aEndNode = a[aEnd];\r\n            bEndNode = b[bEnd];\r\n            if (bEndNode.dom) {\r\n                b[bEnd] = bEndNode = directClone(bEndNode);\r\n            }\r\n        }\r\n        // Move and sync nodes from right to left.\r\n        if (aEndNode.key === bStartNode.key) {\r\n            patch(aEndNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            insertOrAppend(dom, bStartNode.dom, aStartNode.dom);\r\n            aEnd--;\r\n            bStart++;\r\n            aEndNode = a[aEnd];\r\n            bStartNode = b[bStart];\r\n            if (bStartNode.dom) {\r\n                b[bStart] = bStartNode = directClone(bStartNode);\r\n            }\r\n            continue;\r\n        }\r\n        // Move and sync nodes from left to right.\r\n        if (aStartNode.key === bEndNode.key) {\r\n            patch(aStartNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            nextPos = bEnd + 1;\r\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n            insertOrAppend(dom, bEndNode.dom, nextNode);\r\n            aStart++;\r\n            bEnd--;\r\n            aStartNode = a[aStart];\r\n            bEndNode = b[bEnd];\r\n            if (bEndNode.dom) {\r\n                b[bEnd] = bEndNode = directClone(bEndNode);\r\n            }\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    if (aStart > aEnd) {\r\n        if (bStart <= bEnd) {\r\n            nextPos = bEnd + 1;\r\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n            while (bStart <= bEnd) {\r\n                node = b[bStart];\r\n                if (node.dom) {\r\n                    b[bStart] = node = directClone(node);\r\n                }\r\n                bStart++;\r\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n            }\r\n        }\r\n    }\r\n    else if (bStart > bEnd) {\r\n        while (aStart <= aEnd) {\r\n            unmount(a[aStart++], dom, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n    else {\r\n        aLength = aEnd - aStart + 1;\r\n        bLength = bEnd - bStart + 1;\r\n        var sources = new Array(bLength);\r\n        // Mark all nodes as inserted.\r\n        for (i = 0; i < bLength; i++) {\r\n            sources[i] = -1;\r\n        }\r\n        var moved = false;\r\n        var pos = 0;\r\n        var patched = 0;\r\n        // When sizes are small, just loop them through\r\n        if (bLength <= 4 || aLength * bLength <= 16) {\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLength) {\r\n                    for (j = bStart; j <= bEnd; j++) {\r\n                        bNode = b[j];\r\n                        if (aNode.key === bNode.key) {\r\n                            sources[j - bStart] = i;\r\n                            if (pos > j) {\r\n                                moved = true;\r\n                            }\r\n                            else {\r\n                                pos = j;\r\n                            }\r\n                            if (bNode.dom) {\r\n                                b[j] = bNode = directClone(bNode);\r\n                            }\r\n                            patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\r\n                            patched++;\r\n                            a[i] = null;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var keyIndex = new Map();\r\n            // Map keys by their index in array\r\n            for (i = bStart; i <= bEnd; i++) {\r\n                keyIndex.set(b[i].key, i);\r\n            }\r\n            // Try to patch same keys\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLength) {\r\n                    j = keyIndex.get(aNode.key);\r\n                    if (!isUndefined(j)) {\r\n                        bNode = b[j];\r\n                        sources[j - bStart] = i;\r\n                        if (pos > j) {\r\n                            moved = true;\r\n                        }\r\n                        else {\r\n                            pos = j;\r\n                        }\r\n                        if (bNode.dom) {\r\n                            b[j] = bNode = directClone(bNode);\r\n                        }\r\n                        patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\r\n                        patched++;\r\n                        a[i] = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // fast-path: if nothing patched remove all old and add all new\r\n        if (aLength === a.length && patched === 0) {\r\n            removeAllChildren(dom, a, lifecycle, isRecycling);\r\n            while (bStart < bLength) {\r\n                node = b[bStart];\r\n                if (node.dom) {\r\n                    b[bStart] = node = directClone(node);\r\n                }\r\n                bStart++;\r\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), null);\r\n            }\r\n        }\r\n        else {\r\n            i = aLength - patched;\r\n            while (i > 0) {\r\n                aNode = a[aStart++];\r\n                if (!isNull(aNode)) {\r\n                    unmount(aNode, dom, lifecycle, true, isRecycling);\r\n                    i--;\r\n                }\r\n            }\r\n            if (moved) {\r\n                var seq = lis_algorithm(sources);\r\n                j = seq.length - 1;\r\n                for (i = bLength - 1; i >= 0; i--) {\r\n                    if (sources[i] === -1) {\r\n                        pos = i + bStart;\r\n                        node = b[pos];\r\n                        if (node.dom) {\r\n                            b[pos] = node = directClone(node);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n                    }\r\n                    else {\r\n                        if (j < 0 || i !== seq[j]) {\r\n                            pos = i + bStart;\r\n                            node = b[pos];\r\n                            nextPos = pos + 1;\r\n                            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                            insertOrAppend(dom, node.dom, nextNode);\r\n                        }\r\n                        else {\r\n                            j--;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (patched !== bLength) {\r\n                // when patched count doesn't match b length we need to insert those new ones\r\n                // loop backwards so we can use insertBefore\r\n                for (i = bLength - 1; i >= 0; i--) {\r\n                    if (sources[i] === -1) {\r\n                        pos = i + bStart;\r\n                        node = b[pos];\r\n                        if (node.dom) {\r\n                            b[pos] = node = directClone(node);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n// // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction lis_algorithm(arr) {\r\n    var p = arr.slice(0);\r\n    var result = [0];\r\n    var i;\r\n    var j;\r\n    var u;\r\n    var v;\r\n    var c;\r\n    var len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var arrI = arr[i];\r\n        if (arrI === -1) {\r\n            continue;\r\n        }\r\n        j = result[result.length - 1];\r\n        if (arr[j] < arrI) {\r\n            p[i] = j;\r\n            result.push(i);\r\n            continue;\r\n        }\r\n        u = 0;\r\n        v = result.length - 1;\r\n        while (u < v) {\r\n            c = ((u + v) / 2) | 0;\r\n            if (arr[result[c]] < arrI) {\r\n                u = c + 1;\r\n            }\r\n            else {\r\n                v = c;\r\n            }\r\n        }\r\n        if (arrI < arr[result[u]]) {\r\n            if (u > 0) {\r\n                p[i] = result[u - 1];\r\n            }\r\n            result[u] = i;\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\r\nfunction isAttrAnEvent(attr) {\r\n    return attr[0] === \"o\" && attr[1] === \"n\";\r\n}\r\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue) {\r\n    if (lastValue !== nextValue) {\r\n        if (skipProps.has(prop) || (hasControlledValue && prop === \"value\")) {\r\n            return;\r\n        }\r\n        else if (booleanProps.has(prop)) {\r\n            prop = prop === \"autoFocus\" ? prop.toLowerCase() : prop;\r\n            dom[prop] = !!nextValue;\r\n        }\r\n        else if (strictProps.has(prop)) {\r\n            var value = isNullOrUndef(nextValue) ? \"\" : nextValue;\r\n            if (dom[prop] !== value) {\r\n                dom[prop] = value;\r\n            }\r\n        }\r\n        else if (isAttrAnEvent(prop)) {\r\n            patchEvent(prop, lastValue, nextValue, dom);\r\n        }\r\n        else if (isNullOrUndef(nextValue)) {\r\n            dom.removeAttribute(prop);\r\n        }\r\n        else if (prop === \"style\") {\r\n            patchStyle(lastValue, nextValue, dom);\r\n        }\r\n        else if (prop === \"dangerouslySetInnerHTML\") {\r\n            var lastHtml = lastValue && lastValue.__html;\r\n            var nextHtml = nextValue && nextValue.__html;\r\n            if (lastHtml !== nextHtml) {\r\n                if (!isNullOrUndef(nextHtml)) {\r\n                    dom.innerHTML = nextHtml;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // We optimize for NS being boolean. Its 99.9% time false\r\n            if (isSVG && namespaces.has(prop)) {\r\n                // If we end up in this path we can read property again\r\n                dom.setAttributeNS(namespaces.get(prop), prop, nextValue);\r\n            }\r\n            else {\r\n                dom.setAttribute(prop, nextValue);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchEvent(name, lastValue, nextValue, dom) {\r\n    if (lastValue !== nextValue) {\r\n        if (delegatedEvents.has(name)) {\r\n            handleEvent(name, lastValue, nextValue, dom);\r\n        }\r\n        else {\r\n            var nameLowerCase = name.toLowerCase();\r\n            var domEvent = dom[nameLowerCase];\r\n            // if the function is wrapped, that means it's been controlled by a wrapper\r\n            if (domEvent && domEvent.wrapped) {\r\n                return;\r\n            }\r\n            if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {\r\n                var linkEvent = nextValue.event;\r\n                if (linkEvent && isFunction(linkEvent)) {\r\n                    dom[nameLowerCase] = function (e) {\r\n                        linkEvent(nextValue.data, e);\r\n                    };\r\n                }\r\n                else {\r\n                    if (process.env.NODE_ENV !== \"production\") {\r\n                        throwError((\"an event on a VNode \\\"\" + name + \"\\\". was not a function or a valid linkEvent.\"));\r\n                    }\r\n                    throwError();\r\n                }\r\n            }\r\n            else {\r\n                dom[nameLowerCase] = nextValue;\r\n            }\r\n        }\r\n    }\r\n}\r\n// We are assuming here that we come from patchProp routine\r\n// -nextAttrValue cannot be null or undefined\r\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\r\n    var domStyle = dom.style;\r\n    var style;\r\n    var value;\r\n    if (isString(nextAttrValue)) {\r\n        domStyle.cssText = nextAttrValue;\r\n        return;\r\n    }\r\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\r\n        for (style in nextAttrValue) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            value = nextAttrValue[style];\r\n            if (value !== lastAttrValue[style]) {\r\n                domStyle[style] =\r\n                    !isNumber(value) || isUnitlessNumber.has(style)\r\n                        ? value\r\n                        : value + \"px\";\r\n            }\r\n        }\r\n        for (style in lastAttrValue) {\r\n            if (isNullOrUndef(nextAttrValue[style])) {\r\n                domStyle[style] = \"\";\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (style in nextAttrValue) {\r\n            value = nextAttrValue[style];\r\n            domStyle[style] =\r\n                !isNumber(value) || isUnitlessNumber.has(style) ? value : value + \"px\";\r\n        }\r\n    }\r\n}\r\nfunction removeProp(prop, lastValue, dom, nextFlags) {\r\n    if (prop === \"value\") {\r\n        // When removing value of select element, it needs to be set to null instead empty string, because empty string is valid value for option which makes that option selected\r\n        // MS IE/Edge don't follow html spec for textArea and input elements and we need to set empty string to value in those cases to avoid \"null\" and \"undefined\" texts\r\n        dom.value = nextFlags & 2048 /* SelectElement */ ? null : \"\";\r\n    }\r\n    else if (prop === \"style\") {\r\n        dom.removeAttribute(\"style\");\r\n    }\r\n    else if (isAttrAnEvent(prop)) {\r\n        handleEvent(prop, lastValue, null, dom);\r\n    }\r\n    else {\r\n        dom.removeAttribute(prop);\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction mount(vNode, parentDom, lifecycle, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 3970 /* Element */) {\r\n        return mountElement(vNode, parentDom, lifecycle, context, isSVG);\r\n    }\r\n    else if (flags & 28 /* Component */) {\r\n        return mountComponent(vNode, parentDom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 4096 /* Void */) {\r\n        return mountVoid(vNode, parentDom);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        return mountText(vNode, parentDom);\r\n    }\r\n    else {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            if (typeof vNode === \"object\") {\r\n                throwError((\"mount() received an object that's not a valid VNode, you should stringify it first. Object: \\\"\" + (JSON.stringify(vNode)) + \"\\\".\"));\r\n            }\r\n            else {\r\n                throwError((\"mount() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\r\n            }\r\n        }\r\n        throwError();\r\n    }\r\n}\r\nfunction mountText(vNode, parentDom) {\r\n    var dom = document.createTextNode(vNode.children);\r\n    vNode.dom = dom;\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountVoid(vNode, parentDom) {\r\n    var dom = document.createTextNode(\"\");\r\n    vNode.dom = dom;\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountElement(vNode, parentDom, lifecycle, context, isSVG) {\r\n    var dom;\r\n    if (options.recyclingEnabled) {\r\n        dom = recycleElement(vNode, lifecycle, context, isSVG);\r\n        if (!isNull(dom)) {\r\n            if (!isNull(parentDom)) {\r\n                appendChild(parentDom, dom);\r\n            }\r\n            return dom;\r\n        }\r\n    }\r\n    var flags = vNode.flags;\r\n    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;\r\n    dom = documentCreateElement(vNode.type, isSVG);\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var ref = vNode.ref;\r\n    vNode.dom = dom;\r\n    if (!isInvalid(children)) {\r\n        if (isStringOrNumber(children)) {\r\n            setTextContent(dom, children);\r\n        }\r\n        else {\r\n            var childrenIsSVG = isSVG === true && vNode.type !== \"foreignObject\";\r\n            if (isArray(children)) {\r\n                mountArrayChildren(children, dom, lifecycle, context, childrenIsSVG);\r\n            }\r\n            else if (isVNode(children)) {\r\n                mount(children, dom, lifecycle, context, childrenIsSVG);\r\n            }\r\n        }\r\n    }\r\n    if (!isNull(props)) {\r\n        var hasControlledValue = false;\r\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\r\n        if (isFormElement) {\r\n            hasControlledValue = isControlledFormElement(props);\r\n        }\r\n        for (var prop in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\r\n        }\r\n        if (isFormElement) {\r\n            processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n        }\r\n    }\r\n    if (className !== null) {\r\n        if (isSVG) {\r\n            dom.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    if (!isNull(ref)) {\r\n        mountRef(dom, ref, lifecycle);\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountArrayChildren(children, dom, lifecycle, context, isSVG) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        // Verify can string/number be here. might cause de-opt. - Normalization takes care of it.\r\n        if (!isInvalid(child)) {\r\n            if (child.dom) {\r\n                children[i] = child = directClone(child);\r\n            }\r\n            mount(children[i], dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n}\r\nfunction mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {\r\n    var dom;\r\n    if (options.recyclingEnabled) {\r\n        dom = recycleComponent(vNode, lifecycle, context, isSVG);\r\n        if (!isNull(dom)) {\r\n            if (!isNull(parentDom)) {\r\n                appendChild(parentDom, dom);\r\n            }\r\n            return dom;\r\n        }\r\n    }\r\n    var type = vNode.type;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var ref = vNode.ref;\r\n    if (isClass) {\r\n        var instance = createClassComponentInstance(vNode, type, props, context, isSVG, lifecycle);\r\n        var input = instance._lastInput;\r\n        instance._vNode = vNode;\r\n        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);\r\n        if (!isNull(parentDom)) {\r\n            appendChild(parentDom, dom);\r\n        }\r\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\r\n        instance._updating = false;\r\n        if (options.findDOMNodeEnabled) {\r\n            componentToDOMNodeMap.set(instance, dom);\r\n        }\r\n    }\r\n    else {\r\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\r\n        vNode.dom = dom = mount(input$1, null, lifecycle, context, isSVG);\r\n        vNode.children = input$1;\r\n        mountFunctionalComponentCallbacks(props, ref, dom, lifecycle);\r\n        if (!isNull(parentDom)) {\r\n            appendChild(parentDom, dom);\r\n        }\r\n    }\r\n    return dom;\r\n}\r\nfunction mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {\r\n    if (ref) {\r\n        if (isFunction(ref)) {\r\n            ref(instance);\r\n        }\r\n        else {\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                if (isStringOrNumber(ref)) {\r\n                    throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n                }\r\n                else if (isObject(ref) && vNode.flags & 4 /* ComponentClass */) {\r\n                    throwError(\"functional component lifecycle events are not supported on ES2015 class components.\");\r\n                }\r\n                else {\r\n                    throwError((\"a bad value for \\\"ref\\\" was used on component: \\\"\" + (JSON.stringify(ref)) + \"\\\"\"));\r\n                }\r\n            }\r\n            throwError();\r\n        }\r\n    }\r\n    var hasDidMount = !isUndefined(instance.componentDidMount);\r\n    var afterMount = options.afterMount;\r\n    if (hasDidMount || !isNull(afterMount)) {\r\n        lifecycle.addListener((function () {\r\n            instance._updating = true;\r\n            if (afterMount) {\r\n                afterMount(vNode);\r\n            }\r\n            if (hasDidMount) {\r\n                instance.componentDidMount();\r\n            }\r\n            instance._updating = false;\r\n        }));\r\n    }\r\n}\r\nfunction mountFunctionalComponentCallbacks(props, ref, dom, lifecycle) {\r\n    if (ref) {\r\n        if (!isNullOrUndef(ref.onComponentWillMount)) {\r\n            ref.onComponentWillMount(props);\r\n        }\r\n        if (!isNullOrUndef(ref.onComponentDidMount)) {\r\n            lifecycle.addListener((function () { return ref.onComponentDidMount(dom, props); }));\r\n        }\r\n    }\r\n}\r\nfunction mountRef(dom, value, lifecycle) {\r\n    if (isFunction(value)) {\r\n        lifecycle.addListener((function () { return value(dom); }));\r\n    }\r\n    else {\r\n        if (isInvalid(value)) {\r\n            return;\r\n        }\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n        }\r\n        throwError();\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n// We need EMPTY_OBJ defined in one place.\r\n// Its used for comparison so we cant inline it into shared\r\nvar EMPTY_OBJ = {};\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    Object.freeze(EMPTY_OBJ);\r\n}\r\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\r\n    if (isUndefined(context)) {\r\n        context = EMPTY_OBJ; // Context should not be mutable\r\n    }\r\n    var instance = new Component(props, context);\r\n    vNode.children = instance;\r\n    instance._blockSetState = false;\r\n    instance.context = context;\r\n    if (instance.props === EMPTY_OBJ) {\r\n        instance.props = props;\r\n    }\r\n    // setState callbacks must fire after render is done when called from componentWillReceiveProps or componentWillMount\r\n    instance._lifecycle = lifecycle;\r\n    instance._unmounted = false;\r\n    instance._pendingSetState = true;\r\n    instance._isSVG = isSVG;\r\n    if (!isNullOrUndef(instance.componentWillMount)) {\r\n        instance._blockRender = true;\r\n        instance.componentWillMount();\r\n        instance._blockRender = false;\r\n    }\r\n    var childContext;\r\n    if (!isNullOrUndef(instance.getChildContext)) {\r\n        childContext = instance.getChildContext();\r\n    }\r\n    if (isNullOrUndef(childContext)) {\r\n        instance._childContext = context;\r\n    }\r\n    else {\r\n        instance._childContext = combineFrom(context, childContext);\r\n    }\r\n    if (!isNull(options.beforeRender)) {\r\n        options.beforeRender(instance);\r\n    }\r\n    var input = instance.render(props, instance.state, context);\r\n    if (!isNull(options.afterRender)) {\r\n        options.afterRender(instance);\r\n    }\r\n    if (isArray(input)) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n        }\r\n        throwError();\r\n    }\r\n    else if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 28 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = vNode;\r\n        }\r\n    }\r\n    instance._pendingSetState = false;\r\n    instance._lastInput = input;\r\n    return instance;\r\n}\r\nfunction replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    replaceVNode(parentDom, mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);\r\n}\r\nfunction replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {\r\n    unmount(vNode, null, lifecycle, false, isRecycling);\r\n    replaceChild(parentDom, dom, vNode.dom);\r\n}\r\nfunction createFunctionalComponentInput(vNode, component, props, context) {\r\n    var input = component(props, context);\r\n    if (isArray(input)) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n        }\r\n        throwError();\r\n    }\r\n    else if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 28 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = vNode;\r\n        }\r\n    }\r\n    return input;\r\n}\r\nfunction setTextContent(dom, text) {\r\n    if (text !== \"\") {\r\n        dom.textContent = text;\r\n    }\r\n    else {\r\n        dom.appendChild(document.createTextNode(\"\"));\r\n    }\r\n}\r\nfunction updateTextContent(dom, text) {\r\n    dom.firstChild.nodeValue = text;\r\n}\r\nfunction appendChild(parentDom, dom) {\r\n    parentDom.appendChild(dom);\r\n}\r\nfunction insertOrAppend(parentDom, newNode, nextNode) {\r\n    if (isNullOrUndef(nextNode)) {\r\n        appendChild(parentDom, newNode);\r\n    }\r\n    else {\r\n        parentDom.insertBefore(newNode, nextNode);\r\n    }\r\n}\r\nfunction documentCreateElement(tag, isSVG) {\r\n    if (isSVG === true) {\r\n        return document.createElementNS(svgNS, tag);\r\n    }\r\n    else {\r\n        return document.createElement(tag);\r\n    }\r\n}\r\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    unmount(lastNode, null, lifecycle, false, isRecycling);\r\n    var dom = mount(nextNode, null, lifecycle, context, isSVG);\r\n    nextNode.dom = dom;\r\n    replaceChild(parentDom, dom, lastNode.dom);\r\n}\r\nfunction replaceChild(parentDom, nextDom, lastDom) {\r\n    if (!parentDom) {\r\n        parentDom = lastDom.parentNode;\r\n    }\r\n    parentDom.replaceChild(nextDom, lastDom);\r\n}\r\nfunction removeChild(parentDom, dom) {\r\n    parentDom.removeChild(dom);\r\n}\r\nfunction removeAllChildren(dom, children, lifecycle, isRecycling) {\r\n    if (!options.recyclingEnabled || (options.recyclingEnabled && !isRecycling)) {\r\n        removeChildren(null, children, lifecycle, isRecycling);\r\n    }\r\n    dom.textContent = \"\";\r\n}\r\nfunction removeChildren(dom, children, lifecycle, isRecycling) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        if (!isInvalid(child)) {\r\n            unmount(child, dom, lifecycle, true, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction isKeyed(lastChildren, nextChildren) {\r\n    return (nextChildren.length > 0 &&\r\n        !isNullOrUndef(nextChildren[0]) &&\r\n        !isNullOrUndef(nextChildren[0].key) &&\r\n        lastChildren.length > 0 &&\r\n        !isNullOrUndef(lastChildren[0]) &&\r\n        !isNullOrUndef(lastChildren[0].key));\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction VNode(children, className, flags, key, props, ref, type) {\r\n    this.children = children;\r\n    this.className = className;\r\n    this.dom = null;\r\n    this.flags = flags;\r\n    this.key = key;\r\n    this.props = props;\r\n    this.ref = ref;\r\n    this.type = type;\r\n}\r\n/**\r\n * Creates virtual node\r\n * @param {number} flags\r\n * @param {string|Function|null} type\r\n * @param {string|null=} className\r\n * @param {object=} children\r\n * @param {object=} props\r\n * @param {*=} key\r\n * @param {object|Function=} ref\r\n * @param {boolean=} noNormalise\r\n * @returns {VNode} returns new virtual node\r\n */\r\nfunction createVNode(flags, type, className, children, props, key, ref, noNormalise) {\r\n    if (flags & 16 /* ComponentUnknown */) {\r\n        flags = isStatefulComponent(type)\r\n            ? 4 /* ComponentClass */\r\n            : 8 /* ComponentFunction */;\r\n    }\r\n    var vNode = new VNode(children === void 0 ? null : children, className === void 0 ? null : className, flags, key === void 0 ? null : key, props === void 0 ? null : props, ref === void 0 ? null : ref, type);\r\n    if (noNormalise !== true) {\r\n        normalize(vNode);\r\n    }\r\n    if (options.createVNode !== null) {\r\n        options.createVNode(vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction directClone(vNodeToClone) {\r\n    var newVNode;\r\n    var flags = vNodeToClone.flags;\r\n    if (flags & 28 /* Component */) {\r\n        var props;\r\n        var propsToClone = vNodeToClone.props;\r\n        if (isNull(propsToClone)) {\r\n            props = EMPTY_OBJ;\r\n        }\r\n        else {\r\n            props = {};\r\n            for (var key in propsToClone) {\r\n                props[key] = propsToClone[key];\r\n            }\r\n        }\r\n        newVNode = createVNode(flags, vNodeToClone.type, null, null, props, vNodeToClone.key, vNodeToClone.ref, true);\r\n        var newProps = newVNode.props;\r\n        var newChildren = newProps.children;\r\n        // we need to also clone component children that are in props\r\n        // as the children may also have been hoisted\r\n        if (newChildren) {\r\n            if (isArray(newChildren)) {\r\n                var len = newChildren.length;\r\n                if (len > 0) {\r\n                    var tmpArray = [];\r\n                    for (var i = 0; i < len; i++) {\r\n                        var child = newChildren[i];\r\n                        if (isStringOrNumber(child)) {\r\n                            tmpArray.push(child);\r\n                        }\r\n                        else if (!isInvalid(child) && isVNode(child)) {\r\n                            tmpArray.push(directClone(child));\r\n                        }\r\n                    }\r\n                    newProps.children = tmpArray;\r\n                }\r\n            }\r\n            else if (isVNode(newChildren)) {\r\n                newProps.children = directClone(newChildren);\r\n            }\r\n        }\r\n        newVNode.children = null;\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        var children = vNodeToClone.children;\r\n        var props$1;\r\n        var propsToClone$1 = vNodeToClone.props;\r\n        if (propsToClone$1 === null) {\r\n            props$1 = EMPTY_OBJ;\r\n        }\r\n        else {\r\n            props$1 = {};\r\n            for (var key$1 in propsToClone$1) {\r\n                props$1[key$1] = propsToClone$1[key$1];\r\n            }\r\n        }\r\n        newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, children, props$1, vNodeToClone.key, vNodeToClone.ref, !children);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);\r\n    }\r\n    return newVNode;\r\n}\r\n/*\r\n directClone is preferred over cloneVNode and used internally also.\r\n This function makes Inferno backwards compatible.\r\n And can be tree-shaked by modern bundlers\r\n\n Would be nice to combine this with directClone but could not do it without breaking change\r\n */\r\n/**\r\n * Clones given virtual node by creating new instance of it\r\n * @param {VNode} vNodeToClone virtual node to be cloned\r\n * @param {Props=} props additional props for new virtual node\r\n * @param {...*} _children new children for new virtual node\r\n * @returns {VNode} new virtual node\r\n */\r\nfunction cloneVNode(vNodeToClone, props) {\n    var _children = [], len$2 = arguments.length - 2;\n    while ( len$2-- > 0 ) _children[ len$2 ] = arguments[ len$2 + 2 ];\n\r\n    var children = _children;\r\n    var childrenLen = _children.length;\r\n    if (childrenLen > 0 && !isUndefined(_children[0])) {\r\n        if (!props) {\r\n            props = {};\r\n        }\r\n        if (childrenLen === 1) {\r\n            children = _children[0];\r\n        }\r\n        if (!isUndefined(children)) {\r\n            props.children = children;\r\n        }\r\n    }\r\n    var newVNode;\r\n    if (isArray(vNodeToClone)) {\r\n        var tmpArray = [];\r\n        for (var i = 0, len = vNodeToClone.length; i < len; i++) {\r\n            tmpArray.push(directClone(vNodeToClone[i]));\r\n        }\r\n        newVNode = tmpArray;\r\n    }\r\n    else {\r\n        var flags = vNodeToClone.flags;\r\n        var className = vNodeToClone.className;\r\n        var key = vNodeToClone.key;\r\n        var ref = vNodeToClone.ref;\r\n        if (props) {\r\n            if (props.hasOwnProperty(\"className\")) {\r\n                className = props.className;\r\n            }\r\n            if (props.hasOwnProperty(\"ref\")) {\r\n                ref = props.ref;\r\n            }\r\n            if (props.hasOwnProperty(\"key\")) {\r\n                key = props.key;\r\n            }\r\n        }\r\n        if (flags & 28 /* Component */) {\r\n            newVNode = createVNode(flags, vNodeToClone.type, className, null, !vNodeToClone.props && !props\r\n                ? EMPTY_OBJ\r\n                : combineFrom(vNodeToClone.props, props), key, ref, true);\r\n            var newProps = newVNode.props;\r\n            if (newProps) {\r\n                var newChildren = newProps.children;\r\n                // we need to also clone component children that are in props\r\n                // as the children may also have been hoisted\r\n                if (newChildren) {\r\n                    if (isArray(newChildren)) {\r\n                        var len$1 = newChildren.length;\r\n                        if (len$1 > 0) {\r\n                            var tmpArray$1 = [];\r\n                            for (var i$1 = 0; i$1 < len$1; i$1++) {\r\n                                var child = newChildren[i$1];\r\n                                if (isStringOrNumber(child)) {\r\n                                    tmpArray$1.push(child);\r\n                                }\r\n                                else if (!isInvalid(child) && isVNode(child)) {\r\n                                    tmpArray$1.push(directClone(child));\r\n                                }\r\n                            }\r\n                            newProps.children = tmpArray$1;\r\n                        }\r\n                    }\r\n                    else if (isVNode(newChildren)) {\r\n                        newProps.children = directClone(newChildren);\r\n                    }\r\n                }\r\n            }\r\n            newVNode.children = null;\r\n        }\r\n        else if (flags & 3970 /* Element */) {\r\n            children =\r\n                props && !isUndefined(props.children)\r\n                    ? props.children\r\n                    : vNodeToClone.children;\r\n            newVNode = createVNode(flags, vNodeToClone.type, className, children, !vNodeToClone.props && !props\r\n                ? EMPTY_OBJ\r\n                : combineFrom(vNodeToClone.props, props), key, ref, false);\r\n        }\r\n        else if (flags & 1 /* Text */) {\r\n            newVNode = createTextVNode(vNodeToClone.children, key);\r\n        }\r\n    }\r\n    return newVNode;\r\n}\r\nfunction createVoidVNode() {\r\n    return createVNode(4096 /* Void */, null);\r\n}\r\nfunction createTextVNode(text, key) {\r\n    return createVNode(1 /* Text */, null, null, text, null, key);\r\n}\r\nfunction isVNode(o) {\r\n    return !!o.flags;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction applyKey(key, vNode) {\r\n    vNode.key = key;\r\n    return vNode;\r\n}\r\nfunction applyKeyIfMissing(key, vNode) {\r\n    if (isNumber(key)) {\r\n        key = \".\" + key;\r\n    }\r\n    if (isNull(vNode.key) || vNode.key[0] === \".\") {\r\n        return applyKey(key, vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction applyKeyPrefix(key, vNode) {\r\n    vNode.key = key + vNode.key;\r\n    return vNode;\r\n}\r\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\r\n    for (var len = nodes.length; index < len; index++) {\r\n        var n = nodes[index];\r\n        var key = currentKey + \".\" + index;\r\n        if (!isInvalid(n)) {\r\n            if (isArray(n)) {\r\n                _normalizeVNodes(n, result, 0, key);\r\n            }\r\n            else {\r\n                if (isStringOrNumber(n)) {\r\n                    n = createTextVNode(n, null);\r\n                }\r\n                else if ((isVNode(n) && n.dom) || (n.key && n.key[0] === \".\")) {\r\n                    n = directClone(n);\r\n                }\r\n                if (isNull(n.key) || n.key[0] === \".\") {\r\n                    n = applyKey(key, n);\r\n                }\r\n                else {\r\n                    n = applyKeyPrefix(currentKey, n);\r\n                }\r\n                result.push(n);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction normalizeVNodes(nodes) {\r\n    var newNodes;\r\n    // we assign $ which basically means we've flagged this array for future note\r\n    // if it comes back again, we need to clone it, as people are using it\r\n    // in an immutable way\r\n    // tslint:disable\r\n    if (nodes[\"$\"] === true) {\r\n        nodes = nodes.slice();\r\n    }\r\n    else {\r\n        nodes[\"$\"] = true;\r\n    }\r\n    // tslint:enable\r\n    for (var i = 0, len = nodes.length; i < len; i++) {\r\n        var n = nodes[i];\r\n        if (isInvalid(n) || isArray(n)) {\r\n            var result = (newNodes || nodes).slice(0, i);\r\n            _normalizeVNodes(nodes, result, i, \"\");\r\n            return result;\r\n        }\r\n        else if (isStringOrNumber(n)) {\r\n            if (!newNodes) {\r\n                newNodes = nodes.slice(0, i);\r\n            }\r\n            newNodes.push(applyKeyIfMissing(i, createTextVNode(n, null)));\r\n        }\r\n        else if ((isVNode(n) && n.dom !== null) ||\r\n            (isNull(n.key) && (n.flags & 64 /* HasNonKeyedChildren */) === 0)) {\r\n            if (!newNodes) {\r\n                newNodes = nodes.slice(0, i);\r\n            }\r\n            newNodes.push(applyKeyIfMissing(i, directClone(n)));\r\n        }\r\n        else if (newNodes) {\r\n            newNodes.push(applyKeyIfMissing(i, directClone(n)));\r\n        }\r\n    }\r\n    return newNodes || nodes;\r\n}\r\nfunction normalizeChildren(children) {\r\n    if (isArray(children)) {\r\n        return normalizeVNodes(children);\r\n    }\r\n    else if (isVNode(children) && children.dom !== null) {\r\n        return directClone(children);\r\n    }\r\n    return children;\r\n}\r\nfunction normalizeProps(vNode, props, children) {\r\n    if (vNode.flags & 3970 /* Element */) {\r\n        if (isNullOrUndef(children) && props.hasOwnProperty(\"children\")) {\r\n            vNode.children = props.children;\r\n        }\r\n        if (props.hasOwnProperty(\"className\")) {\r\n            vNode.className = props.className || null;\r\n            delete props.className;\r\n        }\r\n    }\r\n    if (props.hasOwnProperty(\"ref\")) {\r\n        vNode.ref = props.ref;\r\n        delete props.ref;\r\n    }\r\n    if (props.hasOwnProperty(\"key\")) {\r\n        vNode.key = props.key;\r\n        delete props.key;\r\n    }\r\n}\r\nfunction getFlagsForElementVnode(type) {\r\n    if (type === \"svg\") {\r\n        return 128 /* SvgElement */;\r\n    }\r\n    else if (type === \"input\") {\r\n        return 512 /* InputElement */;\r\n    }\r\n    else if (type === \"select\") {\r\n        return 2048 /* SelectElement */;\r\n    }\r\n    else if (type === \"textarea\") {\r\n        return 1024 /* TextareaElement */;\r\n    }\r\n    else if (type === \"media\") {\r\n        return 256 /* MediaElement */;\r\n    }\r\n    return 2 /* HtmlElement */;\r\n}\r\nfunction normalize(vNode) {\r\n    var props = vNode.props;\r\n    var children = vNode.children;\r\n    // convert a wrongly created type back to element\r\n    // Primitive node doesn't have defaultProps, only Component\r\n    if (vNode.flags & 28 /* Component */) {\r\n        // set default props\r\n        var type = vNode.type;\r\n        var defaultProps = type.defaultProps;\r\n        if (!isNullOrUndef(defaultProps)) {\r\n            if (!props) {\r\n                props = vNode.props = defaultProps; // Create new object if only defaultProps given\r\n            }\r\n            else {\r\n                for (var prop in defaultProps) {\r\n                    if (isUndefined(props[prop])) {\r\n                        props[prop] = defaultProps[prop];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (isString(type)) {\r\n            vNode.flags = getFlagsForElementVnode(type);\r\n            if (props && props.children) {\r\n                vNode.children = props.children;\r\n                children = props.children;\r\n            }\r\n        }\r\n    }\r\n    if (props) {\r\n        normalizeProps(vNode, props, children);\r\n        if (!isInvalid(props.children)) {\r\n            props.children = normalizeChildren(props.children);\r\n        }\r\n    }\r\n    if (!isInvalid(children)) {\r\n        vNode.children = normalizeChildren(children);\r\n    }\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n        // This code will be stripped out from production CODE\r\n        // It helps users to track errors in their applications.\r\n        var verifyKeys = function (vNodes) {\r\n            var keyValues = vNodes.map((function (vnode) {\r\n                return vnode.key;\r\n            }));\r\n            keyValues.some((function (item, idx) {\r\n                var hasDuplicate = keyValues.indexOf(item) !== idx;\r\n                if (hasDuplicate) {\r\n                    warning(\"Inferno normalisation(...): Encountered two children with same key, all keys must be unique within its siblings. Duplicated key is:\" +\r\n                        item);\r\n                }\r\n                return hasDuplicate;\r\n            }));\r\n        };\r\n        if (vNode.children && Array.isArray(vNode.children)) {\r\n            verifyKeys(vNode.children);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * Links given data to event as first parameter\r\n * @param {*} data data to be linked, it will be available in function as first parameter\r\n * @param {Function} event Function to be called when event occurs\r\n * @returns {{data: *, event: Function}}\r\n */\r\nfunction linkEvent(data, event) {\r\n    if (isFunction(event)) {\r\n        return { data: data, event: event };\r\n    }\r\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/* tslint:disable:object-literal-sort-keys */\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    /* tslint:disable-next-line:no-empty */\r\n    var testFunc = function testFn() { };\r\n    if ((testFunc.name || testFunc.toString()).indexOf(\"testFn\") ===\r\n        -1) {\r\n        warning(\"It looks like you're using a minified copy of the development build \" +\r\n            \"of Inferno. When deploying Inferno apps to production, make sure to use \" +\r\n            \"the production build which skips development warnings and is faster. \" +\r\n            \"See http://infernojs.org for more details.\");\r\n    }\r\n}\r\nvar version = \"3.7.1\";\r\n// we duplicate it so it plays nicely with different module loading systems\r\nvar index = {\r\n    EMPTY_OBJ: EMPTY_OBJ,\r\n    NO_OP: NO_OP,\r\n    cloneVNode: cloneVNode,\r\n    createRenderer: createRenderer,\r\n    createVNode: createVNode,\r\n    findDOMNode: findDOMNode,\r\n    getFlagsForElementVnode: getFlagsForElementVnode,\r\n    internal_DOMNodeMap: componentToDOMNodeMap,\r\n    internal_isUnitlessNumber: isUnitlessNumber,\r\n    internal_normalize: normalize,\r\n    internal_patch: patch,\r\n    linkEvent: linkEvent,\r\n    options: options,\r\n    render: render,\r\n    version: version\r\n};\n\nexports['default'] = index;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nexports.NO_OP = NO_OP;\nexports.cloneVNode = cloneVNode;\nexports.createRenderer = createRenderer;\nexports.createVNode = createVNode;\nexports.findDOMNode = findDOMNode;\nexports.getFlagsForElementVnode = getFlagsForElementVnode;\nexports.internal_DOMNodeMap = componentToDOMNodeMap;\nexports.internal_isUnitlessNumber = isUnitlessNumber;\nexports.internal_normalize = normalize;\nexports.internal_patch = patch;\nexports.linkEvent = linkEvent;\nexports.options = options;\nexports.render = render;\nexports.version = version;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_inferno@3.7.1@inferno/dist/index.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}