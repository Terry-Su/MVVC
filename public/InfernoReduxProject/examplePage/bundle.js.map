{"version":3,"sources":["webpack:///webpack/bootstrap b38654a1c959fc46af0d","webpack:///./node_modules/_process@0.11.10@process/browser.js","webpack:///./node_modules/_inferno@3.7.1@inferno/index.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/_inferno-component@3.7.1@inferno-component/index.js","webpack:///./node_modules/_inferno-redux@3.7.1@inferno-redux/index.js","webpack:///./node_modules/_redux@3.7.2@redux/es/index.js","webpack:///./node_modules/_redux@3.7.2@redux/es/createStore.js","webpack:///./node_modules/_lodash-es@4.17.4@lodash-es/isPlainObject.js","webpack:///./node_modules/_lodash-es@4.17.4@lodash-es/_Symbol.js","webpack:///./node_modules/_redux@3.7.2@redux/es/utils/warning.js","webpack:///./node_modules/_redux@3.7.2@redux/es/compose.js","webpack:///./src/InfernoReduxProject/examplePage/controller/index.js","webpack:///./src/InfernoReduxProject/examplePage/controller/entry.js","webpack:///./src/InfernoReduxProject/examplePage/component/App.js","webpack:///./node_modules/_inferno@3.7.1@inferno/dist/index.js","webpack:///./node_modules/_inferno-component@3.7.1@inferno-component/dist/index.js","webpack:///./node_modules/_inferno-redux@3.7.1@inferno-redux/dist/index.js","webpack:///./node_modules/_hoist-non-inferno-statics@1.1.3@hoist-non-inferno-statics/index.js","webpack:///./node_modules/_inferno-create-element@3.7.1@inferno-create-element/index.js","webpack:///./node_modules/_inferno-create-element@3.7.1@inferno-create-element/dist/index.js","webpack:///./node_modules/_lodash-es@4.17.4@lodash-es/_baseGetTag.js","webpack:///./node_modules/_lodash-es@4.17.4@lodash-es/_root.js","webpack:///./node_modules/_lodash-es@4.17.4@lodash-es/_freeGlobal.js","webpack:///./node_modules/_lodash-es@4.17.4@lodash-es/_getRawTag.js","webpack:///./node_modules/_lodash-es@4.17.4@lodash-es/_objectToString.js","webpack:///./node_modules/_lodash-es@4.17.4@lodash-es/_getPrototype.js","webpack:///./node_modules/_lodash-es@4.17.4@lodash-es/_overArg.js","webpack:///./node_modules/_lodash-es@4.17.4@lodash-es/isObjectLike.js","webpack:///./node_modules/_symbol-observable@1.0.4@symbol-observable/index.js","webpack:///./node_modules/_symbol-observable@1.0.4@symbol-observable/lib/index.js","webpack:///(webpack)/buildin/module.js","webpack:///./node_modules/_symbol-observable@1.0.4@symbol-observable/lib/ponyfill.js","webpack:///./node_modules/_redux@3.7.2@redux/es/combineReducers.js","webpack:///./node_modules/_redux@3.7.2@redux/es/bindActionCreators.js","webpack:///./node_modules/_redux@3.7.2@redux/es/applyMiddleware.js","webpack:///./src/InfernoReduxProject/examplePage/selector/index.js","webpack:///./src/InfernoReduxProject/examplePage/action/index.js","webpack:///./src/share/action/actionCreator.js","webpack:///./src/InfernoReduxProject/share/controller/index.js","webpack:///./src/share/controller/index.js","webpack:///./src/InfernoReduxProject/examplePage/reducer/index.js","webpack:///./src/InfernoReduxProject/examplePage/util/middlewareLogger.js","webpack:///./src/InfernoReduxProject/examplePage/model/index.js","webpack:///./src/share/util/fetch.js"],"names":["Controller","fetchJquery","then","response","text","alert","App","window","reduxStore","document","getElementById","init","onAddClick","e","props","addNumber","addFontSize","onReduceClick","reduceNumber","reduceFontSize","onFetchJqueryClick","number","fontSize","padding","textAlign","color","state","ownProps","dispatch","ADD_NUMBER","ADD_FONT_SIZE","REDUCE_FONT_SIZE","REDUCE_NUMBER","getNumber","getFontSize","store","getState","foo","actions","value","createActions","createAction","Object","keys","map","defaultAction","key","name","type","defaultState","action","middlewareLogger","console","group","info","result","next","log","groupEnd","FETCH_JQUERY","fetch","self","support","searchParams","iterable","Symbol","blob","Blob","formData","arrayBuffer","viewClasses","isDataView","obj","DataView","prototype","isPrototypeOf","isArrayBufferView","ArrayBuffer","isView","indexOf","toString","call","normalizeName","String","test","TypeError","toLowerCase","normalizeValue","iteratorFor","items","iterator","shift","done","undefined","Headers","headers","forEach","append","Array","isArray","header","getOwnPropertyNames","oldValue","get","has","hasOwnProperty","set","callback","thisArg","push","values","entries","consumed","body","bodyUsed","Promise","reject","fileReaderReady","reader","resolve","onload","onerror","error","readBlobAsArrayBuffer","FileReader","promise","readAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","buf","view","Uint8Array","chars","length","i","fromCharCode","join","bufferClone","slice","byteLength","buffer","Body","_initBody","_bodyInit","_bodyText","_bodyBlob","FormData","_bodyFormData","URLSearchParams","_bodyArrayBuffer","Error","rejected","decode","json","JSON","parse","methods","normalizeMethod","method","upcased","toUpperCase","Request","input","options","url","credentials","mode","referrer","clone","form","trim","split","bytes","replace","decodeURIComponent","parseHeaders","rawHeaders","preProcessedHeaders","line","parts","Response","bodyInit","status","ok","statusText","redirectStatuses","redirect","RangeError","location","request","xhr","XMLHttpRequest","getAllResponseHeaders","responseURL","responseText","ontimeout","open","withCredentials","responseType","setRequestHeader","send","polyfill"],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AC7DA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;ACvLtC;AACA;;;;;;;;ACDA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;ACpBA;AACA;;;;;;;;ACDA;AACA;;;;;;;;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;ACfA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,IAAI;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,yBAAyB;AACvC;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,YAAY,yBAAyB;;AAErC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,C;;;;;;;;;;ACvPA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC7DA;;AAEA;AACA;;AAEA;;;;;;;;ACLA;AAAA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,C;;;;;;;ACpBA;AAAA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA,kEAAkE,aAAa;AAC/E;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,C;;;;;;;;;;;;;;;;AC/BA;;AACA;;;;AAEA;;AAKA;;AAGA;;;;AAEA;;;;AAEA;;;;;;;;;AAbA;;AAKA;;;;;IAYaA,U,WAAAA,U;;;;;;;;;;;;;;8LACXC,W,GAAc,YAAM;;AAElB,kCACGC,IADH,CACQ;AAAA,eAAYC,SAASC,IAAT,EAAZ;AAAA,OADR,EAEGF,IAFH,CAEQ;AAAA,eAAQG,sDAEZD,IAFY,cAAR;AAAA,OAFR;AAMD,K;;;;;yBAEIE,G,EAAK;AACRC,aAAOC,UAAP,GAAoB,yCAAqB,uDAArB,CAApB;;AAEA;AAAA,iBACmBA,UADnB;AAAA,kCAEK,GAFL;AAAA,UAIEC,SAASC,cAAT,CAAwB,KAAxB,CAJF;AAOD;;;;;;kBAKY,IAAIV,UAAJ,E;;;;;;;;;AC7Cf;;;;AACA;;;;;;AAGA;AACA,gBAAWW,IAAX,gB;;;;;;;;;;;;;;;ACLA;;;;AACA;;;;AACA;;AACA;;AAIA;;;;AACA;;;;;;;;;;;;IAGEV,W,mBAAAA,W;;;IAIIK,G;;;;;;;;;;;;;;gLACJM,U,GAAa,UAACC,CAAD,EAAO;AAClB,YAAKC,KAAL,CAAWC,SAAX;AACA,YAAKD,KAAL,CAAWE,WAAX;AACD,K,QAEDC,a,GAAgB,UAACJ,CAAD,EAAO;AACrB,YAAKC,KAAL,CAAWI,YAAX;AACA,YAAKJ,KAAL,CAAWK,cAAX;AACD,K,QAEDC,kB,GAAqB,UAACP,CAAD,EAAO;AAC1B,YAAKC,KAAL,CAAWb,WAAX;AACD,K;;;;;6BAEQ;AAAA,mBAIH,KAAKa,KAJF;AAAA,UAELO,MAFK,UAELA,MAFK;AAAA,UAGLC,QAHK,UAGLA,QAHK;;;AAMP;AAAA,mBAOuB,KAAKF;AAP5B;AAAA,mBAWuB,KAAKH;AAX5B;AAAA,mBAaqB,KAAKL;AAb1B,oEAqBUS,MArBV;AAAA,iBAmBmB;AACXC,qBAAaA,WAAW,CAAX,GAAeA,QAAf,GAA0B,CAAC,CAAD,GAAKA,QAA5C;AADW;AAnBnB;AAAA,iBACc;AACVC,mBAAS,MADC;AAEVC,qBAAW,QAFD;AAGVC,iBAAO;AAHG;AADd;AAyBD;;;;;;kBAKY,2BACb,UAACC,KAAD,EAAQC,QAAR,EAAqB;AACnB,SAAO;AACLN,YAAQ,uBADH;AAELC,cAAU;AAFL,GAAP;AAID,CANY,EAOb,UAACM,QAAD,EAAWD,QAAX,EAAwB;AACtB,SAAO;AACLZ,aADK,uBACO;AACV,sBAAOc,UAAP,CAAkB,CAAlB;AACD,KAHI;AAILb,eAJK,yBAIS;AACZ,sBAAOc,aAAP,CAAqB,CAArB;AACD,KANI;AAOLX,kBAPK,4BAOY;AACf,sBAAOY,gBAAP,CAAwB,CAAxB;AACD,KATI;AAULb,gBAVK,0BAUU;AACb,sBAAOc,aAAP,CAAqB,CAArB;AACD,KAZI;;AAaL/B;AAbK,GAAP;AAeD,CAvBY,EAwBbK,GAxBa,C;;;;;;;+CClEf;;AAEA,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,uGAAuG;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAkB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,4CAA4C,EAAE;AAC9F;AACA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB,EAAE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,WAAW,iBAAiB;AAC5B,WAAW,SAAS;AACpB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,SAAS;AACpB,cAAc;AACd;AACA;AACA;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;+CC7yFA;;AAEA,8CAA8C,cAAc;;AAE5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,eAAe,OAAO;AACtB,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;;AAElF;;;;;;;;;uDCtUA;;AAEA,8CAA8C,cAAc;;AAE5D,+BAA+B,iFAAiF;;AAEhH;AACA;AACA;AACA;;AAEA;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA,sBAAsB;AACtB,SAAS,aAAa,EAAE;AACxB;AACA,SAAS,qDAAqD,cAAc,OAAO;AACnF,aAAa,mBAAmB,EAAE,EAAE;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,wBAAwB,EAAE;AAC1B;AACA,yBAAyB,EAAE;AAC3B,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,2BAA2B,sBAAsB;AACjD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,mCAAmC;AACnC,6CAA6C;AAC7C,+DAA+D;AAC/D,+BAA+B;AAC/B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,mBAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0DAA0D;AAC1D;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sEAAsE;AACtE;AACA,gBAAgB;AAChB,qEAAqE;AACrE,mDAAmD,UAAU,qBAAqB,EAAE,EAAE;AACtF,gBAAgB;AAChB,oEAAoE;AACpE,mDAAmD,+DAA+D,EAAE;AACpH,gBAAgB;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,gBAAgB;AAChB,+DAA+D,gEAAgE,WAAW,EAAE,EAAE,eAAe;AAC7J;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wEAAwE,yBAAyB,wCAAwC;AACzI;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,sFAAsF;AAC5I,qDAAqD,mCAAmC,0BAA0B,EAAE,aAAa;AACjI;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA,oCAAoC;AACpC,gEAAgE;AAChE,sEAAsE;AACtE,sDAAsD;AACtD,8CAA8C;;AAE9C;AACA;;AAEA,uBAAuB;AACvB,2CAA2C;AAC3C,+CAA+C;AAC/C,mDAAmD;AACnD,qDAAqD;AACrD;AACA;AACA;AACA;AACA,sD;AACA;AACA;AACA;AACA;AACA,yCAAyC,kCAAkC,EAAE;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;AACA;;;;;;;;;AC/9BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,8CAA8C;AAC9C;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;AC/CA;AACA;;;;;;;;;ACDA;;AAEA,8CAA8C,cAAc;;AAE5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,WAAW,QAAQ;AACnB,WAAW,IAAI,OAAO,EAAE;AACxB,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;AC1HA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;AC3BA;;AAEA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACRA;AACA;;AAEA;;;;;;;;;;ACHA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7CA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;;;;;;;;;ACrBA;;AAEA;AACA;;AAEA;;;;;;;;ACLA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,aAAa,QAAQ;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AC5BA;;;;;;;;sDCAA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;;AAEA,sCAAsC,uCAAuC,kBAAkB;;AAE/F,SAAS;;;AAGT;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;;AAEA;AACA,4B;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;;;;;;ACrBA;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA,E;;;;;;;;;;;ACtBsB;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mEAAmE;AACnE;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2CAA2C,+EAAyB;;AAEpE;AACA;AACA;;AAEA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;ACjIA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;AC9CA;AAAA,mDAAmD,gBAAgB,sBAAsB,OAAO,2BAA2B,0BAA0B,yDAAyD,2BAA2B,EAAE,EAAE,EAAE,eAAe;;AAE9P;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,aAAa,SAAS;AACtB;AACA;AACA,wEAAwE,aAAa;AACrF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,wBAAwB;AACxB;AACA,OAAO;AACP;AACA;AACA,C;;;;;;;;;;;;QC/CgB2B,S,GAAAA,S;QAMAC,W,GAAAA,W;AANT,SAASD,SAAT,GAAqB;AAC1B,MAAME,QAAQC,UAAd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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 12);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b38654a1c959fc46af0d","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_process@0.11.10@process/browser.js\n// module id = 0\n// module chunks = 0","module.exports = require('./dist').default;\nmodule.exports.default = module.exports;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_inferno@3.7.1@inferno/index.js\n// module id = 1\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 2\n// module chunks = 0","module.exports = require('./dist').default;\nmodule.exports.default = module.exports;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_inferno-component@3.7.1@inferno-component/index.js\n// module id = 3\n// module chunks = 0","module.exports = require('./dist').default;\nmodule.exports.default = module.exports;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_inferno-redux@3.7.1@inferno-redux/index.js\n// module id = 4\n// module chunks = 0","import createStore from './createStore';\nimport combineReducers from './combineReducers';\nimport bindActionCreators from './bindActionCreators';\nimport applyMiddleware from './applyMiddleware';\nimport compose from './compose';\nimport warning from './utils/warning';\n\n/*\n* This is a dummy function to check if the function name has been altered by minification.\n* If the function has been minified and NODE_ENV !== 'production', warn the user.\n*/\nfunction isCrushed() {}\n\nif (process.env.NODE_ENV !== 'production' && typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {\n  warning('You are currently using minified code outside of NODE_ENV === \\'production\\'. ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or DefinePlugin for webpack (http://stackoverflow.com/questions/30030031) ' + 'to ensure you have the correct code for your production build.');\n}\n\nexport { createStore, combineReducers, bindActionCreators, applyMiddleware, compose };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_redux@3.7.2@redux/es/index.js\n// module id = 5\n// module chunks = 0","import isPlainObject from 'lodash-es/isPlainObject';\nimport $$observable from 'symbol-observable';\n\n/**\n * These are private action types reserved by Redux.\n * For any unknown actions, you must return the current state.\n * If the current state is undefined, you must return the initial state.\n * Do not reference these action types directly in your code.\n */\nexport var ActionTypes = {\n  INIT: '@@redux/INIT'\n\n  /**\n   * Creates a Redux store that holds the state tree.\n   * The only way to change the data in the store is to call `dispatch()` on it.\n   *\n   * There should only be a single store in your app. To specify how different\n   * parts of the state tree respond to actions, you may combine several reducers\n   * into a single reducer function by using `combineReducers`.\n   *\n   * @param {Function} reducer A function that returns the next state tree, given\n   * the current state tree and the action to handle.\n   *\n   * @param {any} [preloadedState] The initial state. You may optionally specify it\n   * to hydrate the state from the server in universal apps, or to restore a\n   * previously serialized user session.\n   * If you use `combineReducers` to produce the root reducer function, this must be\n   * an object with the same shape as `combineReducers` keys.\n   *\n   * @param {Function} [enhancer] The store enhancer. You may optionally specify it\n   * to enhance the store with third-party capabilities such as middleware,\n   * time travel, persistence, etc. The only store enhancer that ships with Redux\n   * is `applyMiddleware()`.\n   *\n   * @returns {Store} A Redux store that lets you read the state, dispatch actions\n   * and subscribe to changes.\n   */\n};export default function createStore(reducer, preloadedState, enhancer) {\n  var _ref2;\n\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.');\n    }\n\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.');\n  }\n\n  var currentReducer = reducer;\n  var currentState = preloadedState;\n  var currentListeners = [];\n  var nextListeners = currentListeners;\n  var isDispatching = false;\n\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  /**\n   * Reads the state tree managed by the store.\n   *\n   * @returns {any} The current state tree of your application.\n   */\n  function getState() {\n    return currentState;\n  }\n\n  /**\n   * Adds a change listener. It will be called any time an action is dispatched,\n   * and some part of the state tree may potentially have changed. You may then\n   * call `getState()` to read the current state tree inside the callback.\n   *\n   * You may call `dispatch()` from a change listener, with the following\n   * caveats:\n   *\n   * 1. The subscriptions are snapshotted just before every `dispatch()` call.\n   * If you subscribe or unsubscribe while the listeners are being invoked, this\n   * will not have any effect on the `dispatch()` that is currently in progress.\n   * However, the next `dispatch()` call, whether nested or not, will use a more\n   * recent snapshot of the subscription list.\n   *\n   * 2. The listener should not expect to see all state changes, as the state\n   * might have been updated multiple times during a nested `dispatch()` before\n   * the listener is called. It is, however, guaranteed that all subscribers\n   * registered before the `dispatch()` started will be called with the latest\n   * state by the time it exits.\n   *\n   * @param {Function} listener A callback to be invoked on every dispatch.\n   * @returns {Function} A function to remove this change listener.\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected listener to be a function.');\n    }\n\n    var isSubscribed = true;\n\n    ensureCanMutateNextListeners();\n    nextListeners.push(listener);\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return;\n      }\n\n      isSubscribed = false;\n\n      ensureCanMutateNextListeners();\n      var index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  /**\n   * Dispatches an action. It is the only way to trigger a state change.\n   *\n   * The `reducer` function, used to create the store, will be called with the\n   * current state tree and the given `action`. Its return value will\n   * be considered the **next** state of the tree, and the change listeners\n   * will be notified.\n   *\n   * The base implementation only supports plain object actions. If you want to\n   * dispatch a Promise, an Observable, a thunk, or something else, you need to\n   * wrap your store creating function into the corresponding middleware. For\n   * example, see the documentation for the `redux-thunk` package. Even the\n   * middleware will eventually dispatch plain object actions using this method.\n   *\n   * @param {Object} action A plain object representing what changed. It is\n   * a good idea to keep actions serializable so you can record and replay user\n   * sessions, or use the time travelling `redux-devtools`. An action must have\n   * a `type` property which may not be `undefined`. It is a good idea to use\n   * string constants for action types.\n   *\n   * @returns {Object} For convenience, the same action object you dispatched.\n   *\n   * Note that, if you use a custom middleware, it may wrap `dispatch()` to\n   * return something else (for example, a Promise you can await).\n   */\n  function dispatch(action) {\n    if (!isPlainObject(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.');\n    }\n\n    try {\n      isDispatching = true;\n      currentState = currentReducer(currentState, action);\n    } finally {\n      isDispatching = false;\n    }\n\n    var listeners = currentListeners = nextListeners;\n    for (var i = 0; i < listeners.length; i++) {\n      var listener = listeners[i];\n      listener();\n    }\n\n    return action;\n  }\n\n  /**\n   * Replaces the reducer currently used by the store to calculate the state.\n   *\n   * You might need this if your app implements code splitting and you want to\n   * load some of the reducers dynamically. You might also need this if you\n   * implement a hot reloading mechanism for Redux.\n   *\n   * @param {Function} nextReducer The reducer for the store to use instead.\n   * @returns {void}\n   */\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.');\n    }\n\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.INIT });\n  }\n\n  /**\n   * Interoperability point for observable/reactive libraries.\n   * @returns {observable} A minimal observable of state changes.\n   * For more information, see the observable proposal:\n   * https://github.com/tc39/proposal-observable\n   */\n  function observable() {\n    var _ref;\n\n    var outerSubscribe = subscribe;\n    return _ref = {\n      /**\n       * The minimal observable subscription method.\n       * @param {Object} observer Any object that can be used as an observer.\n       * The observer object should have a `next` method.\n       * @returns {subscription} An object with an `unsubscribe` method that can\n       * be used to unsubscribe the observable from the store, and prevent further\n       * emission of values from the observable.\n       */\n      subscribe: function subscribe(observer) {\n        if (typeof observer !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = outerSubscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    }, _ref[$$observable] = function () {\n      return this;\n    }, _ref;\n  }\n\n  // When a store is created, an \"INIT\" action is dispatched so that every\n  // reducer returns their initial state. This effectively populates\n  // the initial state tree.\n  dispatch({ type: ActionTypes.INIT });\n\n  return _ref2 = {\n    dispatch: dispatch,\n    subscribe: subscribe,\n    getState: getState,\n    replaceReducer: replaceReducer\n  }, _ref2[$$observable] = observable, _ref2;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_redux@3.7.2@redux/es/createStore.js\n// module id = 6\n// module chunks = 0","import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_lodash-es@4.17.4@lodash-es/isPlainObject.js\n// module id = 7\n// module chunks = 0","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_lodash-es@4.17.4@lodash-es/_Symbol.js\n// module id = 8\n// module chunks = 0","/**\n * Prints a warning in the console if it exists.\n *\n * @param {String} message The warning message.\n * @returns {void}\n */\nexport default function warning(message) {\n  /* eslint-disable no-console */\n  if (typeof console !== 'undefined' && typeof console.error === 'function') {\n    console.error(message);\n  }\n  /* eslint-enable no-console */\n  try {\n    // This error was thrown as a convenience so that if you enable\n    // \"break on all exceptions\" in your console,\n    // it would pause the execution at this line.\n    throw new Error(message);\n    /* eslint-disable no-empty */\n  } catch (e) {}\n  /* eslint-enable no-empty */\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_redux@3.7.2@redux/es/utils/warning.js\n// module id = 9\n// module chunks = 0","/**\n * Composes single-argument functions from right to left. The rightmost\n * function can take multiple arguments as it provides the signature for\n * the resulting composite function.\n *\n * @param {...Function} funcs The functions to compose.\n * @returns {Function} A function obtained by composing the argument functions\n * from right to left. For example, compose(f, g, h) is identical to doing\n * (...args) => f(g(h(...args))).\n */\n\nexport default function compose() {\n  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {\n    funcs[_key] = arguments[_key];\n  }\n\n  if (funcs.length === 0) {\n    return function (arg) {\n      return arg;\n    };\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n\n  return funcs.reduce(function (a, b) {\n    return function () {\n      return a(b.apply(undefined, arguments));\n    };\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_redux@3.7.2@redux/es/compose.js\n// module id = 10\n// module chunks = 0","import { Controller as SuperController } from '../../share/controller/index'\nimport Inferno, { render } from 'inferno'\n// redux\nimport {\n  createStore,\n  applyMiddleware\n} from 'redux'\n// inferno-redux\nimport {\n  Provider\n} from 'inferno-redux'\nimport reducer from '../reducer/index'\n\nimport middlewareLogger from '../util/middlewareLogger'\n\nimport {\n  FETCH_JQUERY\n} from '../model/index'\n\nexport class Controller extends SuperController{\n  fetchJquery = () => {\n\n    FETCH_JQUERY()\n      .then(response => response.text())\n      .then(text => alert(`Fetch jQuery successfully! \n      \n      ${text}\n      `))\n  }\n\n  init(App) {\n    window.reduxStore = createStore(reducer, applyMiddleware(middlewareLogger))\n\n    render(\n      <Provider store={reduxStore}>\n        <App />\n      </Provider>,\n      document.getElementById('app')\n    )\n\n  }\n}\n\n\n\nexport default new Controller()\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/InfernoReduxProject/examplePage/controller/index.js","import App from '../component/App'\nimport controller from './index'\n\n\n// initialize\ncontroller.init(App)\n\n\n// WEBPACK FOOTER //\n// ./src/InfernoReduxProject/examplePage/controller/entry.js","import Inferno from 'inferno'\nimport Component from 'inferno-component'\nimport { connect } from 'inferno-redux'\nimport {\n  getNumber,\n  getFontSize\n} from '../selector/index'\nimport action from '../action/index'\nimport controller from '../controller/index'\n\nconst {\n  fetchJquery \n} = controller\n\n\nclass App extends Component {\n  onAddClick = (e) => {\n    this.props.addNumber()\n    this.props.addFontSize()\n  }\n\n  onReduceClick = (e) => {\n    this.props.reduceNumber()\n    this.props.reduceFontSize()\n  }\n\n  onFetchJqueryClick = (e) => {\n    this.props.fetchJquery()\n  }\n\n  render() {\n    const {\n      number,\n      fontSize\n    } = this.props\n\n    return (\n      <div style={{\n        padding: '10px',\n        textAlign: 'center',\n        color: 'blue'\n      }}>\n        <div>\n          <button onClick={this.onFetchJqueryClick}>Fetch jQuery.js</button>\n        </div>\n        <br />\n        <div>\n          <button onClick={this.onReduceClick}>-</button>\n          &nbsp;&nbsp;\n        <button onClick={this.onAddClick}>+</button>\n        </div>\n\n\n\n        <h1>\n          <span style={{\n            fontSize: `${fontSize > 0 ? fontSize : -1 * fontSize}px`\n          }}>{number}</span>\n        </h1>\n      </div>\n    )\n  }\n}\n\n\n\nexport default connect(\n  (state, ownProps) => {\n    return {\n      number: getNumber(),\n      fontSize: getFontSize()\n    }\n  },\n  (dispatch, ownProps) => {\n    return {\n      addNumber() {\n        action.ADD_NUMBER(1)\n      },\n      addFontSize() {\n        action.ADD_FONT_SIZE(5)\n      },\n      reduceFontSize() {\n        action.REDUCE_FONT_SIZE(5)\n      },\n      reduceNumber() {\n        action.REDUCE_NUMBER(1)\n      },\n      fetchJquery\n    }\n  },\n)(App)\n\n\n// WEBPACK FOOTER //\n// ./src/InfernoReduxProject/examplePage/component/App.js","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/**\r\n * @module Inferno-Shared\r\n */ /** TypeDoc Comment */\r\nvar NO_OP = \"$NO_OP\";\r\nvar ERROR_MSG = \"a runtime error occured! Use Inferno in development environment to find the error.\";\r\n// This should be boolean and not reference to window.document\r\nvar isBrowser = !!(typeof window !== \"undefined\" && window.document);\r\n// this is MUCH faster than .constructor === Array and instanceof Array\r\n// in Node 7 and the later versions of V8, slower in older versions though\r\nvar isArray = Array.isArray;\r\nfunction isStatefulComponent(o) {\r\n    return !isUndefined(o.prototype) && !isUndefined(o.prototype.render);\r\n}\r\nfunction isStringOrNumber(o) {\r\n    var type = typeof o;\r\n    return type === \"string\" || type === \"number\";\r\n}\r\nfunction isNullOrUndef(o) {\r\n    return isUndefined(o) || isNull(o);\r\n}\r\nfunction isInvalid(o) {\r\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\r\n}\r\nfunction isFunction(o) {\r\n    return typeof o === \"function\";\r\n}\r\nfunction isString(o) {\r\n    return typeof o === \"string\";\r\n}\r\nfunction isNumber(o) {\r\n    return typeof o === \"number\";\r\n}\r\nfunction isNull(o) {\r\n    return o === null;\r\n}\r\nfunction isTrue(o) {\r\n    return o === true;\r\n}\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\r\nfunction isObject(o) {\r\n    return typeof o === \"object\";\r\n}\r\nfunction throwError(message) {\r\n    if (!message) {\r\n        message = ERROR_MSG;\r\n    }\r\n    throw new Error((\"Inferno Error: \" + message));\r\n}\r\nfunction warning(message) {\r\n    // tslint:disable-next-line:no-console\r\n    console.warn(message);\r\n}\r\nfunction combineFrom(first, second) {\r\n    var out = {};\r\n    if (first) {\r\n        for (var key in first) {\r\n            out[key] = first[key];\r\n        }\r\n    }\r\n    if (second) {\r\n        for (var key$1 in second) {\r\n            out[key$1] = second[key$1];\r\n        }\r\n    }\r\n    return out;\r\n}\r\nfunction Lifecycle() {\r\n    this.listeners = [];\r\n}\r\nLifecycle.prototype.addListener = function addListener(callback) {\r\n    this.listeners.push(callback);\r\n};\r\nLifecycle.prototype.trigger = function trigger() {\r\n    var listeners = this.listeners;\r\n    var listener;\r\n    // We need to remove current listener from array when calling it, because more listeners might be added\r\n    while ((listener = listeners.shift())) {\r\n        listener();\r\n    }\r\n};\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar options = {\r\n    afterMount: null,\r\n    afterRender: null,\r\n    afterUpdate: null,\r\n    beforeRender: null,\r\n    beforeUnmount: null,\r\n    createVNode: null,\r\n    findDOMNodeEnabled: false,\r\n    recyclingEnabled: false,\r\n    roots: []\r\n};\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar xlinkNS = \"http://www.w3.org/1999/xlink\";\r\nvar xmlNS = \"http://www.w3.org/XML/1998/namespace\";\r\nvar svgNS = \"http://www.w3.org/2000/svg\";\r\nvar strictProps = new Set();\r\nstrictProps.add(\"volume\");\r\nstrictProps.add(\"defaultChecked\");\r\nvar booleanProps = new Set();\r\nbooleanProps.add(\"muted\");\r\nbooleanProps.add(\"scoped\");\r\nbooleanProps.add(\"loop\");\r\nbooleanProps.add(\"open\");\r\nbooleanProps.add(\"checked\");\r\nbooleanProps.add(\"default\");\r\nbooleanProps.add(\"capture\");\r\nbooleanProps.add(\"disabled\");\r\nbooleanProps.add(\"readOnly\");\r\nbooleanProps.add(\"required\");\r\nbooleanProps.add(\"autoplay\");\r\nbooleanProps.add(\"controls\");\r\nbooleanProps.add(\"seamless\");\r\nbooleanProps.add(\"reversed\");\r\nbooleanProps.add(\"allowfullscreen\");\r\nbooleanProps.add(\"novalidate\");\r\nbooleanProps.add(\"hidden\");\r\nbooleanProps.add(\"autoFocus\");\r\nbooleanProps.add(\"selected\");\r\nbooleanProps.add(\"indeterminate\");\r\nvar namespaces = new Map();\r\nnamespaces.set(\"xlink:href\", xlinkNS);\r\nnamespaces.set(\"xlink:arcrole\", xlinkNS);\r\nnamespaces.set(\"xlink:actuate\", xlinkNS);\r\nnamespaces.set(\"xlink:show\", xlinkNS);\r\nnamespaces.set(\"xlink:role\", xlinkNS);\r\nnamespaces.set(\"xlink:title\", xlinkNS);\r\nnamespaces.set(\"xlink:type\", xlinkNS);\r\nnamespaces.set(\"xml:base\", xmlNS);\r\nnamespaces.set(\"xml:lang\", xmlNS);\r\nnamespaces.set(\"xml:space\", xmlNS);\r\nvar isUnitlessNumber = new Set();\r\nisUnitlessNumber.add(\"animationIterationCount\");\r\nisUnitlessNumber.add(\"borderImageOutset\");\r\nisUnitlessNumber.add(\"borderImageSlice\");\r\nisUnitlessNumber.add(\"borderImageWidth\");\r\nisUnitlessNumber.add(\"boxFlex\");\r\nisUnitlessNumber.add(\"boxFlexGroup\");\r\nisUnitlessNumber.add(\"boxOrdinalGroup\");\r\nisUnitlessNumber.add(\"columnCount\");\r\nisUnitlessNumber.add(\"flex\");\r\nisUnitlessNumber.add(\"flexGrow\");\r\nisUnitlessNumber.add(\"flexPositive\");\r\nisUnitlessNumber.add(\"flexShrink\");\r\nisUnitlessNumber.add(\"flexNegative\");\r\nisUnitlessNumber.add(\"flexOrder\");\r\nisUnitlessNumber.add(\"gridRow\");\r\nisUnitlessNumber.add(\"gridColumn\");\r\nisUnitlessNumber.add(\"fontWeight\");\r\nisUnitlessNumber.add(\"lineClamp\");\r\nisUnitlessNumber.add(\"lineHeight\");\r\nisUnitlessNumber.add(\"opacity\");\r\nisUnitlessNumber.add(\"order\");\r\nisUnitlessNumber.add(\"orphans\");\r\nisUnitlessNumber.add(\"tabSize\");\r\nisUnitlessNumber.add(\"widows\");\r\nisUnitlessNumber.add(\"zIndex\");\r\nisUnitlessNumber.add(\"zoom\");\r\nisUnitlessNumber.add(\"fillOpacity\");\r\nisUnitlessNumber.add(\"floodOpacity\");\r\nisUnitlessNumber.add(\"stopOpacity\");\r\nisUnitlessNumber.add(\"strokeDasharray\");\r\nisUnitlessNumber.add(\"strokeDashoffset\");\r\nisUnitlessNumber.add(\"strokeMiterlimit\");\r\nisUnitlessNumber.add(\"strokeOpacity\");\r\nisUnitlessNumber.add(\"strokeWidth\");\r\nvar skipProps = new Set();\r\nskipProps.add(\"children\");\r\nskipProps.add(\"childrenType\");\r\nskipProps.add(\"defaultValue\");\r\nskipProps.add(\"ref\");\r\nskipProps.add(\"key\");\r\nskipProps.add(\"checked\");\r\nskipProps.add(\"multiple\");\r\nvar delegatedEvents = new Set();\r\ndelegatedEvents.add(\"onClick\");\r\ndelegatedEvents.add(\"onMouseDown\");\r\ndelegatedEvents.add(\"onMouseUp\");\r\ndelegatedEvents.add(\"onMouseMove\");\r\ndelegatedEvents.add(\"onSubmit\");\r\ndelegatedEvents.add(\"onDblClick\");\r\ndelegatedEvents.add(\"onKeyDown\");\r\ndelegatedEvents.add(\"onKeyUp\");\r\ndelegatedEvents.add(\"onKeyPress\");\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar isiOS = isBrowser &&\r\n    !!navigator.platform &&\r\n    /iPad|iPhone|iPod/.test(navigator.platform);\r\nvar delegatedEvents$1 = new Map();\r\nfunction handleEvent(name, lastEvent, nextEvent, dom) {\r\n    var delegatedRoots = delegatedEvents$1.get(name);\r\n    if (nextEvent) {\r\n        if (!delegatedRoots) {\r\n            delegatedRoots = { items: new Map(), docEvent: null };\r\n            delegatedRoots.docEvent = attachEventToDocument(name, delegatedRoots);\r\n            delegatedEvents$1.set(name, delegatedRoots);\r\n        }\r\n        if (!lastEvent) {\r\n            if (isiOS && name === \"onClick\") {\r\n                trapClickOnNonInteractiveElement(dom);\r\n            }\r\n        }\r\n        delegatedRoots.items.set(dom, nextEvent);\r\n    }\r\n    else if (delegatedRoots) {\r\n        var items = delegatedRoots.items;\r\n        if (items.delete(dom)) {\r\n            // If any items were deleted, check if listener need to be removed\r\n            if (items.size === 0) {\r\n                document.removeEventListener(normalizeEventName(name), delegatedRoots.docEvent);\r\n                delegatedEvents$1.delete(name);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction dispatchEvents(event, target, items, count, isClick, eventData) {\r\n    var dom = target;\r\n    while (count > 0) {\r\n        var eventsToTrigger = items.get(dom);\r\n        if (eventsToTrigger) {\r\n            count--;\r\n            // linkEvent object\r\n            eventData.dom = dom;\r\n            if (eventsToTrigger.event) {\r\n                eventsToTrigger.event(eventsToTrigger.data, event);\r\n            }\r\n            else {\r\n                eventsToTrigger(event);\r\n            }\r\n            if (event.cancelBubble) {\r\n                return;\r\n            }\r\n        }\r\n        dom = dom.parentNode;\r\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\r\n        // because the event listener is on document.body\r\n        // Don't process clicks on disabled elements\r\n        if (dom === null || (isClick && dom.disabled)) {\r\n            return;\r\n        }\r\n    }\r\n}\r\nfunction normalizeEventName(name) {\r\n    return name.substr(2).toLowerCase();\r\n}\r\nfunction stopPropagation() {\r\n    this.cancelBubble = true;\r\n    this.stopImmediatePropagation();\r\n}\r\nfunction attachEventToDocument(name, delegatedRoots) {\r\n    var docEvent = function (event) {\r\n        var count = delegatedRoots.items.size;\r\n        if (count > 0) {\r\n            event.stopPropagation = stopPropagation;\r\n            // Event data needs to be object to save reference to currentTarget getter\r\n            var eventData = {\r\n                dom: document\r\n            };\r\n            try {\r\n                Object.defineProperty(event, \"currentTarget\", {\r\n                    configurable: true,\r\n                    get: function get() {\r\n                        return eventData.dom;\r\n                    }\r\n                });\r\n            }\r\n            catch (e) {\r\n                /* safari7 and phantomJS will crash */\r\n            }\r\n            dispatchEvents(event, event.target, delegatedRoots.items, count, event.type === \"click\", eventData);\r\n        }\r\n    };\r\n    document.addEventListener(normalizeEventName(name), docEvent);\r\n    return docEvent;\r\n}\r\n// tslint:disable-next-line:no-empty\r\nfunction emptyFn() { }\r\nfunction trapClickOnNonInteractiveElement(dom) {\r\n    // Mobile Safari does not fire properly bubble click events on\r\n    // non-interactive elements, which means delegated click listeners do not\r\n    // fire. The workaround for this bug involves attaching an empty click\r\n    // listener on the target node.\r\n    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html\r\n    // Just set it using the onclick property so that we don't have to manage any\r\n    // bookkeeping for it. Not sure if we need to clear it when the listener is\r\n    // removed.\r\n    // TODO: Only do this for the relevant Safaris maybe?\r\n    dom.onclick = emptyFn;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction isCheckedType(type) {\r\n    return type === \"checkbox\" || type === \"radio\";\r\n}\r\nfunction onTextInputChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    var previousValue = props.value;\r\n    if (props.onInput) {\r\n        var event = props.onInput;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.oninput) {\r\n        props.oninput(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue(newProps, dom);\r\n    }\r\n}\r\nfunction wrappedOnChange(e) {\r\n    var props = this.vNode.props || EMPTY_OBJ;\r\n    var event = props.onChange;\r\n    if (event.event) {\r\n        event.event(event.data, e);\r\n    }\r\n    else {\r\n        event(e);\r\n    }\r\n}\r\nfunction onCheckboxChange(e) {\r\n    e.stopPropagation(); // This click should not propagate its for internal use\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    if (props.onClick) {\r\n        var event = props.onClick;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.onclick) {\r\n        props.onclick(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    applyValue(newProps, dom);\r\n}\r\nfunction processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue(nextPropsOrEmpty, dom);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            if (isCheckedType(nextPropsOrEmpty.type)) {\r\n                dom.onclick = onCheckboxChange;\r\n                dom.onclick.wrapped = true;\r\n            }\r\n            else {\r\n                dom.oninput = onTextInputChange;\r\n                dom.oninput.wrapped = true;\r\n            }\r\n            if (nextPropsOrEmpty.onChange) {\r\n                dom.onchange = wrappedOnChange;\r\n                dom.onchange.wrapped = true;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyValue(nextPropsOrEmpty, dom) {\r\n    var type = nextPropsOrEmpty.type;\r\n    var value = nextPropsOrEmpty.value;\r\n    var checked = nextPropsOrEmpty.checked;\r\n    var multiple = nextPropsOrEmpty.multiple;\r\n    var defaultValue = nextPropsOrEmpty.defaultValue;\r\n    var hasValue = !isNullOrUndef(value);\r\n    if (type && type !== dom.type) {\r\n        dom.setAttribute(\"type\", type);\r\n    }\r\n    if (multiple && multiple !== dom.multiple) {\r\n        dom.multiple = multiple;\r\n    }\r\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\r\n        dom.defaultValue = defaultValue + \"\";\r\n    }\r\n    if (isCheckedType(type)) {\r\n        if (hasValue) {\r\n            dom.value = value;\r\n        }\r\n        if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n    else {\r\n        if (hasValue && dom.value !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n        else if (!isNullOrUndef(checked)) {\r\n            dom.checked = checked;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction updateChildOptionGroup(vNode, value) {\r\n    var type = vNode.type;\r\n    if (type === \"optgroup\") {\r\n        var children = vNode.children;\r\n        if (isArray(children)) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOption(children[i], value);\r\n            }\r\n        }\r\n        else if (isVNode(children)) {\r\n            updateChildOption(children, value);\r\n        }\r\n    }\r\n    else {\r\n        updateChildOption(vNode, value);\r\n    }\r\n}\r\nfunction updateChildOption(vNode, value) {\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    // we do this as multiple may have changed\r\n    dom.value = props.value;\r\n    if ((isArray(value) && value.indexOf(props.value) !== -1) ||\r\n        props.value === value) {\r\n        dom.selected = true;\r\n    }\r\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\r\n        dom.selected = props.selected || false;\r\n    }\r\n}\r\nfunction onSelectChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var dom = vNode.dom;\r\n    var previousValue = props.value;\r\n    if (props.onChange) {\r\n        var event = props.onChange;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.onchange) {\r\n        props.onchange(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue$1(newVNode, dom, newProps, false);\r\n    }\r\n}\r\nfunction processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue$1(vNode, dom, nextPropsOrEmpty, mounting);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            dom.onchange = onSelectChange;\r\n            dom.onchange.wrapped = true;\r\n        }\r\n    }\r\n}\r\nfunction applyValue$1(vNode, dom, nextPropsOrEmpty, mounting) {\r\n    if (nextPropsOrEmpty.multiple !== dom.multiple) {\r\n        dom.multiple = nextPropsOrEmpty.multiple;\r\n    }\r\n    var children = vNode.children;\r\n    if (!isInvalid(children)) {\r\n        var value = nextPropsOrEmpty.value;\r\n        if (mounting && isNullOrUndef(value)) {\r\n            value = nextPropsOrEmpty.defaultValue;\r\n        }\r\n        if (isArray(children)) {\r\n            for (var i = 0, len = children.length; i < len; i++) {\r\n                updateChildOptionGroup(children[i], value);\r\n            }\r\n        }\r\n        else if (isVNode(children)) {\r\n            updateChildOptionGroup(children, value);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction wrappedOnChange$1(e) {\r\n    var props = this.vNode.props || EMPTY_OBJ;\r\n    var event = props.onChange;\r\n    if (event.event) {\r\n        event.event(event.data, e);\r\n    }\r\n    else {\r\n        event(e);\r\n    }\r\n}\r\nfunction onTextareaInputChange(e) {\r\n    var vNode = this.vNode;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var previousValue = props.value;\r\n    if (props.onInput) {\r\n        var event = props.onInput;\r\n        if (event.event) {\r\n            event.event(event.data, e);\r\n        }\r\n        else {\r\n            event(e);\r\n        }\r\n    }\r\n    else if (props.oninput) {\r\n        props.oninput(e);\r\n    }\r\n    // the user may have updated the vNode from the above onInput events syncronously\r\n    // so we need to get it from the context of `this` again\r\n    var newVNode = this.vNode;\r\n    var newProps = newVNode.props || EMPTY_OBJ;\r\n    // If render is going async there is no value change yet, it will come back to process input soon\r\n    if (previousValue !== newProps.value) {\r\n        // When this happens we need to store current cursor position and restore it, to avoid jumping\r\n        applyValue$2(newVNode, vNode.dom, false);\r\n    }\r\n}\r\nfunction processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    applyValue$2(nextPropsOrEmpty, dom, mounting);\r\n    if (isControlled) {\r\n        dom.vNode = vNode; // TODO: Remove this when implementing Fiber's\r\n        if (mounting) {\r\n            dom.oninput = onTextareaInputChange;\r\n            dom.oninput.wrapped = true;\r\n            if (nextPropsOrEmpty.onChange) {\r\n                dom.onchange = wrappedOnChange$1;\r\n                dom.onchange.wrapped = true;\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyValue$2(nextPropsOrEmpty, dom, mounting) {\r\n    var value = nextPropsOrEmpty.value;\r\n    var domValue = dom.value;\r\n    if (isNullOrUndef(value)) {\r\n        if (mounting) {\r\n            var defaultValue = nextPropsOrEmpty.defaultValue;\r\n            if (!isNullOrUndef(defaultValue)) {\r\n                if (defaultValue !== domValue) {\r\n                    dom.defaultValue = defaultValue;\r\n                    dom.value = defaultValue;\r\n                }\r\n            }\r\n            else if (domValue !== \"\") {\r\n                dom.defaultValue = \"\";\r\n                dom.value = \"\";\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        /* There is value so keep it controlled */\r\n        if (domValue !== value) {\r\n            dom.defaultValue = value;\r\n            dom.value = value;\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * There is currently no support for switching same input between controlled and nonControlled\r\n * If that ever becomes a real issue, then re design controlled elements\r\n * Currently user must choose either controlled or non-controlled and stick with that\r\n */\r\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\r\n    if (flags & 512 /* InputElement */) {\r\n        processInput(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n    if (flags & 2048 /* SelectElement */) {\r\n        processSelect(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n    if (flags & 1024 /* TextareaElement */) {\r\n        processTextarea(vNode, dom, nextPropsOrEmpty, mounting, isControlled);\r\n    }\r\n}\r\nfunction isControlledFormElement(nextPropsOrEmpty) {\r\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type)\r\n        ? !isNullOrUndef(nextPropsOrEmpty.checked)\r\n        : !isNullOrUndef(nextPropsOrEmpty.value);\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction normalizeChildNodes(parentDom) {\r\n    var dom = parentDom.firstChild;\r\n    while (dom) {\r\n        if (dom.nodeType === 8) {\r\n            if (dom.data === \"!\") {\r\n                var placeholder = document.createTextNode(\"\");\r\n                parentDom.replaceChild(placeholder, dom);\r\n                dom = dom.nextSibling;\r\n            }\r\n            else {\r\n                var lastDom = dom.previousSibling;\r\n                parentDom.removeChild(dom);\r\n                dom = lastDom || parentDom.firstChild;\r\n            }\r\n        }\r\n        else {\r\n            dom = dom.nextSibling;\r\n        }\r\n    }\r\n}\r\nfunction hydrateComponent(vNode, dom, lifecycle, context, isSVG, isClass) {\r\n    var type = vNode.type;\r\n    var ref = vNode.ref;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    if (isClass) {\r\n        var _isSVG = dom.namespaceURI === svgNS;\r\n        var instance = createClassComponentInstance(vNode, type, props, context, _isSVG, lifecycle);\r\n        var input = instance._lastInput;\r\n        instance._vNode = vNode;\r\n        hydrate(input, dom, lifecycle, instance._childContext, _isSVG);\r\n        vNode.dom = input.dom;\r\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\r\n        instance._updating = false; // Mount finished allow going sync\r\n        if (options.findDOMNodeEnabled) {\r\n            componentToDOMNodeMap.set(instance, dom);\r\n        }\r\n    }\r\n    else {\r\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\r\n        hydrate(input$1, dom, lifecycle, context, isSVG);\r\n        vNode.children = input$1;\r\n        vNode.dom = input$1.dom;\r\n        mountFunctionalComponentCallbacks(props, ref, dom, lifecycle);\r\n    }\r\n    return dom;\r\n}\r\nfunction hydrateElement(vNode, dom, lifecycle, context, isSVG) {\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var flags = vNode.flags;\r\n    var ref = vNode.ref;\r\n    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;\r\n    if (dom.nodeType !== 1 || dom.tagName.toLowerCase() !== vNode.type) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            warning(\"Inferno hydration: Server-side markup doesn't match client-side markup or Initial render target is not empty\");\r\n        }\r\n        var newDom = mountElement(vNode, null, lifecycle, context, isSVG);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n        return newDom;\r\n    }\r\n    vNode.dom = dom;\r\n    if (!isInvalid(children)) {\r\n        hydrateChildren(children, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (dom.firstChild !== null) {\r\n        dom.textContent = \"\"; // dom has content, but VNode has no children remove everything from DOM\r\n    }\r\n    if (props) {\r\n        var hasControlledValue = false;\r\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\r\n        if (isFormElement) {\r\n            hasControlledValue = isControlledFormElement(props);\r\n        }\r\n        for (var prop in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\r\n        }\r\n        if (isFormElement) {\r\n            processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n        }\r\n    }\r\n    if (!isNullOrUndef(className)) {\r\n        if (isSVG) {\r\n            dom.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    else {\r\n        if (dom.className !== \"\") {\r\n            dom.removeAttribute(\"class\");\r\n        }\r\n    }\r\n    if (ref) {\r\n        mountRef(dom, ref, lifecycle);\r\n    }\r\n    return dom;\r\n}\r\nfunction hydrateChildren(children, parentDom, lifecycle, context, isSVG) {\r\n    normalizeChildNodes(parentDom);\r\n    var dom = parentDom.firstChild;\r\n    if (isStringOrNumber(children)) {\r\n        if (!isNull(dom) && dom.nodeType === 3) {\r\n            if (dom.nodeValue !== children) {\r\n                dom.nodeValue = children;\r\n            }\r\n        }\r\n        else if (children === \"\") {\r\n            parentDom.appendChild(document.createTextNode(\"\"));\r\n        }\r\n        else {\r\n            parentDom.textContent = children;\r\n        }\r\n        if (!isNull(dom)) {\r\n            dom = dom.nextSibling;\r\n        }\r\n    }\r\n    else if (isArray(children)) {\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            if (!isNull(child) && isObject(child)) {\r\n                if (!isNull(dom)) {\r\n                    var nextSibling = dom.nextSibling;\r\n                    hydrate(child, dom, lifecycle, context, isSVG);\r\n                    dom = nextSibling;\r\n                }\r\n                else {\r\n                    mount(child, parentDom, lifecycle, context, isSVG);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // It's VNode\r\n        if (!isNull(dom)) {\r\n            hydrate(children, dom, lifecycle, context, isSVG);\r\n            dom = dom.nextSibling;\r\n        }\r\n        else {\r\n            mount(children, parentDom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    // clear any other DOM nodes, there should be only a single entry for the root\r\n    while (dom) {\r\n        var nextSibling$1 = dom.nextSibling;\r\n        parentDom.removeChild(dom);\r\n        dom = nextSibling$1;\r\n    }\r\n}\r\nfunction hydrateText(vNode, dom) {\r\n    if (dom.nodeType !== 3) {\r\n        var newDom = mountText(vNode, null);\r\n        vNode.dom = newDom;\r\n        replaceChild(dom.parentNode, newDom, dom);\r\n        return newDom;\r\n    }\r\n    var text = vNode.children;\r\n    if (dom.nodeValue !== text) {\r\n        dom.nodeValue = text;\r\n    }\r\n    vNode.dom = dom;\r\n    return dom;\r\n}\r\nfunction hydrateVoid(vNode, dom) {\r\n    vNode.dom = dom;\r\n    return dom;\r\n}\r\nfunction hydrate(vNode, dom, lifecycle, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 28 /* Component */) {\r\n        hydrateComponent(vNode, dom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        hydrateElement(vNode, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        hydrateText(vNode, dom);\r\n    }\r\n    else if (flags & 4096 /* Void */) {\r\n        hydrateVoid(vNode, dom);\r\n    }\r\n    else {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError((\"hydrate() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\r\n        }\r\n        throwError();\r\n    }\r\n}\r\nfunction hydrateRoot(input, parentDom, lifecycle) {\r\n    if (!isNull(parentDom)) {\r\n        var dom = parentDom.firstChild;\r\n        if (!isNull(dom)) {\r\n            hydrate(input, dom, lifecycle, EMPTY_OBJ, false);\r\n            dom = parentDom.firstChild;\r\n            // clear any other DOM nodes, there should be only a single entry for the root\r\n            while ((dom = dom.nextSibling)) {\r\n                parentDom.removeChild(dom);\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nvar componentPools = new Map();\r\nvar elementPools = new Map();\r\nfunction recycleElement(vNode, lifecycle, context, isSVG) {\r\n    var tag = vNode.type;\r\n    var pools = elementPools.get(tag);\r\n    if (!isUndefined(pools)) {\r\n        var key = vNode.key;\r\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\r\n        if (!isUndefined(pool)) {\r\n            var recycledVNode = pool.pop();\r\n            if (!isUndefined(recycledVNode)) {\r\n                patchElement(recycledVNode, vNode, null, lifecycle, context, isSVG, true);\r\n                return vNode.dom;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction poolElement(vNode) {\r\n    var tag = vNode.type;\r\n    var key = vNode.key;\r\n    var pools = elementPools.get(tag);\r\n    if (isUndefined(pools)) {\r\n        pools = {\r\n            keyed: new Map(),\r\n            nonKeyed: []\r\n        };\r\n        elementPools.set(tag, pools);\r\n    }\r\n    if (isNull(key)) {\r\n        pools.nonKeyed.push(vNode);\r\n    }\r\n    else {\r\n        var pool = pools.keyed.get(key);\r\n        if (isUndefined(pool)) {\r\n            pool = [];\r\n            pools.keyed.set(key, pool);\r\n        }\r\n        pool.push(vNode);\r\n    }\r\n}\r\nfunction recycleComponent(vNode, lifecycle, context, isSVG) {\r\n    var type = vNode.type;\r\n    var pools = componentPools.get(type);\r\n    if (!isUndefined(pools)) {\r\n        var key = vNode.key;\r\n        var pool = key === null ? pools.nonKeyed : pools.keyed.get(key);\r\n        if (!isUndefined(pool)) {\r\n            var recycledVNode = pool.pop();\r\n            if (!isUndefined(recycledVNode)) {\r\n                var flags = vNode.flags;\r\n                var failed = patchComponent(recycledVNode, vNode, null, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0, true);\r\n                if (!failed) {\r\n                    return vNode.dom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction poolComponent(vNode) {\r\n    var hooks = vNode.ref;\r\n    var nonRecycleHooks = hooks &&\r\n        (hooks.onComponentWillMount ||\r\n            hooks.onComponentWillUnmount ||\r\n            hooks.onComponentDidMount ||\r\n            hooks.onComponentWillUpdate ||\r\n            hooks.onComponentDidUpdate);\r\n    if (nonRecycleHooks) {\r\n        return;\r\n    }\r\n    var type = vNode.type;\r\n    var key = vNode.key;\r\n    var pools = componentPools.get(type);\r\n    if (isUndefined(pools)) {\r\n        pools = {\r\n            keyed: new Map(),\r\n            nonKeyed: []\r\n        };\r\n        componentPools.set(type, pools);\r\n    }\r\n    if (isNull(key)) {\r\n        pools.nonKeyed.push(vNode);\r\n    }\r\n    else {\r\n        var pool = pools.keyed.get(key);\r\n        if (isUndefined(pool)) {\r\n            pool = [];\r\n            pools.keyed.set(key, pool);\r\n        }\r\n        pool.push(vNode);\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction unmount(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var flags = vNode.flags;\r\n    if (flags & 28 /* Component */) {\r\n        unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling);\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling);\r\n    }\r\n    else if (flags & (1 /* Text */ | 4096 /* Void */)) {\r\n        unmountVoidOrText(vNode, parentDom);\r\n    }\r\n}\r\nfunction unmountVoidOrText(vNode, parentDom) {\r\n    if (!isNull(parentDom)) {\r\n        removeChild(parentDom, vNode.dom);\r\n    }\r\n}\r\nfunction unmountComponent(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var instance = vNode.children;\r\n    var flags = vNode.flags;\r\n    var isStatefulComponent$$1 = flags & 4;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var ref = vNode.ref;\r\n    var dom = vNode.dom;\r\n    if (!isRecycling) {\r\n        if (isStatefulComponent$$1) {\r\n            if (!instance._unmounted) {\r\n                if (!isNull(options.beforeUnmount)) {\r\n                    options.beforeUnmount(vNode);\r\n                }\r\n                if (!isUndefined(instance.componentWillUnmount)) {\r\n                    instance.componentWillUnmount();\r\n                }\r\n                if (ref && !isRecycling) {\r\n                    ref(null);\r\n                }\r\n                instance._unmounted = true;\r\n                if (options.findDOMNodeEnabled) {\r\n                    componentToDOMNodeMap.delete(instance);\r\n                }\r\n                unmount(instance._lastInput, null, instance._lifecycle, false, isRecycling);\r\n            }\r\n        }\r\n        else {\r\n            if (!isNullOrUndef(ref)) {\r\n                if (!isNullOrUndef(ref.onComponentWillUnmount)) {\r\n                    ref.onComponentWillUnmount(dom, props);\r\n                }\r\n            }\r\n            unmount(instance, null, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n    if (parentDom) {\r\n        removeChild(parentDom, dom);\r\n    }\r\n    if (options.recyclingEnabled &&\r\n        !isStatefulComponent$$1 &&\r\n        (parentDom || canRecycle)) {\r\n        poolComponent(vNode);\r\n    }\r\n}\r\nfunction unmountElement(vNode, parentDom, lifecycle, canRecycle, isRecycling) {\r\n    var dom = vNode.dom;\r\n    var ref = vNode.ref;\r\n    var props = vNode.props;\r\n    if (ref && !isRecycling) {\r\n        unmountRef(ref);\r\n    }\r\n    var children = vNode.children;\r\n    if (!isNullOrUndef(children)) {\r\n        unmountChildren$1(children, lifecycle, isRecycling);\r\n    }\r\n    if (!isNull(props)) {\r\n        for (var name in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            if (props[name] !== null && isAttrAnEvent(name)) {\r\n                patchEvent(name, props[name], null, dom);\r\n                // We need to set this null, because same props otherwise come back if SCU returns false and we are recyling\r\n                props[name] = null;\r\n            }\r\n        }\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        removeChild(parentDom, dom);\r\n    }\r\n    if (options.recyclingEnabled && (parentDom || canRecycle)) {\r\n        poolElement(vNode);\r\n    }\r\n}\r\nfunction unmountChildren$1(children, lifecycle, isRecycling) {\r\n    if (isArray(children)) {\r\n        for (var i = 0, len = children.length; i < len; i++) {\r\n            var child = children[i];\r\n            if (!isInvalid(child) && isObject(child)) {\r\n                unmount(child, null, lifecycle, false, isRecycling);\r\n            }\r\n        }\r\n    }\r\n    else if (isObject(children)) {\r\n        unmount(children, null, lifecycle, false, isRecycling);\r\n    }\r\n}\r\nfunction unmountRef(ref) {\r\n    if (isFunction(ref)) {\r\n        ref(null);\r\n    }\r\n    else {\r\n        if (isInvalid(ref)) {\r\n            return;\r\n        }\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n        }\r\n        throwError();\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n// rather than use a Map, like we did before, we can use an array here\r\n// given there shouldn't be THAT many roots on the page, the difference\r\n// in performance is huge: https://esbench.com/bench/5802a691330ab09900a1a2da\r\nvar componentToDOMNodeMap = new Map();\r\nvar roots = options.roots;\r\n/**\r\n * When inferno.options.findDOMNOdeEnabled is true, this function will return DOM Node by component instance\r\n * @param ref Component instance\r\n * @returns {*|null} returns dom node\r\n */\r\nfunction findDOMNode(ref) {\r\n    if (!options.findDOMNodeEnabled) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(\"findDOMNode() has been disabled, use Inferno.options.findDOMNodeEnabled = true; enabled findDOMNode(). Warning this can significantly impact performance!\");\r\n        }\r\n        throwError();\r\n    }\r\n    var dom = ref && ref.nodeType ? ref : null;\r\n    return componentToDOMNodeMap.get(ref) || dom;\r\n}\r\nfunction getRoot(dom) {\r\n    for (var i = 0, len = roots.length; i < len; i++) {\r\n        var root = roots[i];\r\n        if (root.dom === dom) {\r\n            return root;\r\n        }\r\n    }\r\n    return null;\r\n}\r\nfunction setRoot(dom, input, lifecycle) {\r\n    var root = {\r\n        dom: dom,\r\n        input: input,\r\n        lifecycle: lifecycle\r\n    };\r\n    roots.push(root);\r\n    return root;\r\n}\r\nfunction removeRoot(root) {\r\n    for (var i = 0, len = roots.length; i < len; i++) {\r\n        if (roots[i] === root) {\r\n            roots.splice(i, 1);\r\n            return;\r\n        }\r\n    }\r\n}\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    if (isBrowser && document.body === null) {\r\n        warning('Inferno warning: you cannot initialize inferno without \"document.body\". Wait on \"DOMContentLoaded\" event, add script to bottom of body, or use async/defer attributes on script tag.');\r\n    }\r\n}\r\nvar documentBody = isBrowser ? document.body : null;\r\n/**\r\n * Renders virtual node tree into parent node.\r\n * @param {VNode | null | string | number} input vNode to be rendered\r\n * @param parentDom DOM node which content will be replaced by virtual node\r\n * @returns {InfernoChildren} rendered virtual node\r\n */\r\nfunction render(input, parentDom) {\r\n    if (documentBody === parentDom) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError('you cannot render() to the \"document.body\". Use an empty element as a container instead.');\r\n        }\r\n        throwError();\r\n    }\r\n    if (input === NO_OP) {\r\n        return;\r\n    }\r\n    var root = getRoot(parentDom);\r\n    if (isNull(root)) {\r\n        var lifecycle = new Lifecycle();\r\n        if (!isInvalid(input)) {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            if (!hydrateRoot(input, parentDom, lifecycle)) {\r\n                mount(input, parentDom, lifecycle, EMPTY_OBJ, false);\r\n            }\r\n            root = setRoot(parentDom, input, lifecycle);\r\n            lifecycle.trigger();\r\n        }\r\n    }\r\n    else {\r\n        var lifecycle$1 = root.lifecycle;\r\n        lifecycle$1.listeners = [];\r\n        if (isNullOrUndef(input)) {\r\n            unmount(root.input, parentDom, lifecycle$1, false, false);\r\n            removeRoot(root);\r\n        }\r\n        else {\r\n            if (input.dom) {\r\n                input = directClone(input);\r\n            }\r\n            patch(root.input, input, parentDom, lifecycle$1, EMPTY_OBJ, false, false);\r\n        }\r\n        root.input = input;\r\n        lifecycle$1.trigger();\r\n    }\r\n    if (root) {\r\n        var rootInput = root.input;\r\n        if (rootInput && rootInput.flags & 28 /* Component */) {\r\n            return rootInput.children;\r\n        }\r\n    }\r\n}\r\nfunction createRenderer(parentDom) {\r\n    return function renderer(lastInput, nextInput) {\r\n        if (!parentDom) {\r\n            parentDom = lastInput;\r\n        }\r\n        render(nextInput, parentDom);\r\n    };\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction patch(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    if (lastVNode !== nextVNode) {\r\n        var lastFlags = lastVNode.flags;\r\n        var nextFlags = nextVNode.flags;\r\n        if (nextFlags & 28 /* Component */) {\r\n            var isClass = (nextFlags & 4 /* ComponentClass */) > 0;\r\n            if (lastFlags & 28 /* Component */) {\r\n                patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, isClass), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 3970 /* Element */) {\r\n            if (lastFlags & 3970 /* Element */) {\r\n                patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountElement(nextVNode, null, lifecycle, context, isSVG), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 1 /* Text */) {\r\n            if (lastFlags & 1 /* Text */) {\r\n                patchText(lastVNode, nextVNode);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountText(nextVNode, null), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else if (nextFlags & 4096 /* Void */) {\r\n            if (lastFlags & 4096 /* Void */) {\r\n                patchVoid(lastVNode, nextVNode);\r\n            }\r\n            else {\r\n                replaceVNode(parentDom, mountVoid(nextVNode, null), lastVNode, lifecycle, isRecycling);\r\n            }\r\n        }\r\n        else {\r\n            // Error case: mount new one replacing old one\r\n            replaceLastChildAndUnmount(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction unmountChildren(children, dom, lifecycle, isRecycling) {\r\n    if (isVNode(children)) {\r\n        unmount(children, dom, lifecycle, true, isRecycling);\r\n    }\r\n    else if (isArray(children)) {\r\n        removeAllChildren(dom, children, lifecycle, isRecycling);\r\n    }\r\n    else {\r\n        dom.textContent = \"\";\r\n    }\r\n}\r\nfunction patchElement(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    var nextTag = nextVNode.type;\r\n    var lastTag = lastVNode.type;\r\n    if (lastTag !== nextTag) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n    }\r\n    else {\r\n        var dom = lastVNode.dom;\r\n        var lastProps = lastVNode.props;\r\n        var nextProps = nextVNode.props;\r\n        var lastChildren = lastVNode.children;\r\n        var nextChildren = nextVNode.children;\r\n        var lastFlags = lastVNode.flags;\r\n        var nextFlags = nextVNode.flags;\r\n        var nextRef = nextVNode.ref;\r\n        var lastClassName = lastVNode.className;\r\n        var nextClassName = nextVNode.className;\r\n        nextVNode.dom = dom;\r\n        isSVG = isSVG || (nextFlags & 128 /* SvgElement */) > 0;\r\n        if (lastChildren !== nextChildren) {\r\n            var childrenIsSVG = isSVG === true && nextVNode.type !== \"foreignObject\";\r\n            patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, childrenIsSVG, isRecycling);\r\n        }\r\n        // inlined patchProps  -- starts --\r\n        if (lastProps !== nextProps) {\r\n            var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\r\n            var nextPropsOrEmpty = nextProps || EMPTY_OBJ;\r\n            var hasControlledValue = false;\r\n            if (nextPropsOrEmpty !== EMPTY_OBJ) {\r\n                var isFormElement = (nextFlags & 3584 /* FormElement */) > 0;\r\n                if (isFormElement) {\r\n                    hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\r\n                }\r\n                for (var prop in nextPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    var nextValue = nextPropsOrEmpty[prop];\r\n                    var lastValue = lastPropsOrEmpty[prop];\r\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue);\r\n                }\r\n                if (isFormElement) {\r\n                    // When inferno is recycling form element, we need to process it like it would be mounting\r\n                    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, isRecycling, hasControlledValue);\r\n                }\r\n            }\r\n            if (lastPropsOrEmpty !== EMPTY_OBJ) {\r\n                for (var prop$1 in lastPropsOrEmpty) {\r\n                    // do not add a hasOwnProperty check here, it affects performance\r\n                    if (isNullOrUndef(nextPropsOrEmpty[prop$1]) &&\r\n                        !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\r\n                        removeProp(prop$1, lastPropsOrEmpty[prop$1], dom, nextFlags);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // inlined patchProps  -- ends --\r\n        if (lastClassName !== nextClassName) {\r\n            if (isNullOrUndef(nextClassName)) {\r\n                dom.removeAttribute(\"class\");\r\n            }\r\n            else {\r\n                if (isSVG) {\r\n                    dom.setAttribute(\"class\", nextClassName);\r\n                }\r\n                else {\r\n                    dom.className = nextClassName;\r\n                }\r\n            }\r\n        }\r\n        if (nextRef) {\r\n            if (lastVNode.ref !== nextRef || isRecycling) {\r\n                mountRef(dom, nextRef, lifecycle);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchChildren(lastFlags, nextFlags, lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var patchArray = false;\r\n    var patchKeyed = false;\r\n    if (nextFlags & 64 /* HasNonKeyedChildren */) {\r\n        patchArray = true;\r\n    }\r\n    else if ((lastFlags & 32 /* HasKeyedChildren */) > 0 &&\r\n        (nextFlags & 32 /* HasKeyedChildren */) > 0) {\r\n        patchKeyed = true;\r\n        patchArray = true;\r\n    }\r\n    else if (isInvalid(nextChildren)) {\r\n        unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n    }\r\n    else if (isInvalid(lastChildren)) {\r\n        if (isStringOrNumber(nextChildren)) {\r\n            setTextContent(dom, nextChildren);\r\n        }\r\n        else {\r\n            if (isArray(nextChildren)) {\r\n                mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\r\n            }\r\n            else {\r\n                mount(nextChildren, dom, lifecycle, context, isSVG);\r\n            }\r\n        }\r\n    }\r\n    else if (isStringOrNumber(nextChildren)) {\r\n        if (isStringOrNumber(lastChildren)) {\r\n            updateTextContent(dom, nextChildren);\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            setTextContent(dom, nextChildren);\r\n        }\r\n    }\r\n    else if (isArray(nextChildren)) {\r\n        if (isArray(lastChildren)) {\r\n            patchArray = true;\r\n            if (isKeyed(lastChildren, nextChildren)) {\r\n                patchKeyed = true;\r\n            }\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            mountArrayChildren(nextChildren, dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    else if (isArray(lastChildren)) {\r\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\r\n        mount(nextChildren, dom, lifecycle, context, isSVG);\r\n    }\r\n    else if (isVNode(nextChildren)) {\r\n        if (isVNode(lastChildren)) {\r\n            patch(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n        else {\r\n            unmountChildren(lastChildren, dom, lifecycle, isRecycling);\r\n            mount(nextChildren, dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n    if (patchArray) {\r\n        if (patchKeyed) {\r\n            patchKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n        else {\r\n            patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction patchComponent(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isClass, isRecycling) {\r\n    var lastType = lastVNode.type;\r\n    var nextType = nextVNode.type;\r\n    var lastKey = lastVNode.key;\r\n    var nextKey = nextVNode.key;\r\n    if (lastType !== nextType || lastKey !== nextKey) {\r\n        replaceWithNewNode(lastVNode, nextVNode, parentDom, lifecycle, context, isSVG, isRecycling);\r\n        return false;\r\n    }\r\n    else {\r\n        var nextProps = nextVNode.props || EMPTY_OBJ;\r\n        if (isClass) {\r\n            var instance = lastVNode.children;\r\n            instance._updating = true;\r\n            if (instance._unmounted) {\r\n                if (isNull(parentDom)) {\r\n                    return true;\r\n                }\r\n                replaceChild(parentDom, mountComponent(nextVNode, null, lifecycle, context, isSVG, (nextVNode.flags & 4 /* ComponentClass */) > 0), lastVNode.dom);\r\n            }\r\n            else {\r\n                var hasComponentDidUpdate = !isUndefined(instance.componentDidUpdate);\r\n                var nextState = instance.state;\r\n                // When component has componentDidUpdate hook, we need to clone lastState or will be modified by reference during update\r\n                var lastState = hasComponentDidUpdate\r\n                    ? combineFrom(nextState, null)\r\n                    : nextState;\r\n                var lastProps = instance.props;\r\n                var childContext;\r\n                if (!isNullOrUndef(instance.getChildContext)) {\r\n                    childContext = instance.getChildContext();\r\n                }\r\n                nextVNode.children = instance;\r\n                instance._isSVG = isSVG;\r\n                if (isNullOrUndef(childContext)) {\r\n                    childContext = context;\r\n                }\r\n                else {\r\n                    childContext = combineFrom(context, childContext);\r\n                }\r\n                var lastInput = instance._lastInput;\r\n                var nextInput = instance._updateComponent(lastState, nextState, lastProps, nextProps, context, false, false);\r\n                var didUpdate = true;\r\n                instance._childContext = childContext;\r\n                if (isInvalid(nextInput)) {\r\n                    nextInput = createVoidVNode();\r\n                }\r\n                else if (nextInput === NO_OP) {\r\n                    nextInput = lastInput;\r\n                    didUpdate = false;\r\n                }\r\n                else if (isStringOrNumber(nextInput)) {\r\n                    nextInput = createTextVNode(nextInput, null);\r\n                }\r\n                else if (isArray(nextInput)) {\r\n                    if (process.env.NODE_ENV !== \"production\") {\r\n                        throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n                    }\r\n                    throwError();\r\n                }\r\n                else if (isObject(nextInput)) {\r\n                    if (!isNull(nextInput.dom)) {\r\n                        nextInput = directClone(nextInput);\r\n                    }\r\n                }\r\n                if (nextInput.flags & 28 /* Component */) {\r\n                    nextInput.parentVNode = nextVNode;\r\n                }\r\n                else if (lastInput.flags & 28 /* Component */) {\r\n                    lastInput.parentVNode = nextVNode;\r\n                }\r\n                instance._lastInput = nextInput;\r\n                instance._vNode = nextVNode;\r\n                if (didUpdate) {\r\n                    patch(lastInput, nextInput, parentDom, lifecycle, childContext, isSVG, isRecycling);\r\n                    if (hasComponentDidUpdate && instance.componentDidUpdate) {\r\n                        instance.componentDidUpdate(lastProps, lastState);\r\n                    }\r\n                    if (!isNull(options.afterUpdate)) {\r\n                        options.afterUpdate(nextVNode);\r\n                    }\r\n                    if (options.findDOMNodeEnabled) {\r\n                        componentToDOMNodeMap.set(instance, nextInput.dom);\r\n                    }\r\n                }\r\n                nextVNode.dom = nextInput.dom;\r\n            }\r\n            instance._updating = false;\r\n        }\r\n        else {\r\n            var shouldUpdate = true;\r\n            var lastProps$1 = lastVNode.props;\r\n            var nextHooks = nextVNode.ref;\r\n            var nextHooksDefined = !isNullOrUndef(nextHooks);\r\n            var lastInput$1 = lastVNode.children;\r\n            var nextInput$1 = lastInput$1;\r\n            nextVNode.dom = lastVNode.dom;\r\n            nextVNode.children = lastInput$1;\r\n            if (lastKey !== nextKey) {\r\n                shouldUpdate = true;\r\n            }\r\n            else {\r\n                if (nextHooksDefined &&\r\n                    !isNullOrUndef(nextHooks.onComponentShouldUpdate)) {\r\n                    shouldUpdate = nextHooks.onComponentShouldUpdate(lastProps$1, nextProps);\r\n                }\r\n            }\r\n            if (shouldUpdate !== false) {\r\n                if (nextHooksDefined &&\r\n                    !isNullOrUndef(nextHooks.onComponentWillUpdate)) {\r\n                    nextHooks.onComponentWillUpdate(lastProps$1, nextProps);\r\n                }\r\n                nextInput$1 = nextType(nextProps, context);\r\n                if (isInvalid(nextInput$1)) {\r\n                    nextInput$1 = createVoidVNode();\r\n                }\r\n                else if (isStringOrNumber(nextInput$1) && nextInput$1 !== NO_OP) {\r\n                    nextInput$1 = createTextVNode(nextInput$1, null);\r\n                }\r\n                else if (isArray(nextInput$1)) {\r\n                    if (process.env.NODE_ENV !== \"production\") {\r\n                        throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n                    }\r\n                    throwError();\r\n                }\r\n                else if (isObject(nextInput$1)) {\r\n                    if (!isNull(nextInput$1.dom)) {\r\n                        nextInput$1 = directClone(nextInput$1);\r\n                    }\r\n                }\r\n                if (nextInput$1 !== NO_OP) {\r\n                    patch(lastInput$1, nextInput$1, parentDom, lifecycle, context, isSVG, isRecycling);\r\n                    nextVNode.children = nextInput$1;\r\n                    if (nextHooksDefined &&\r\n                        !isNullOrUndef(nextHooks.onComponentDidUpdate)) {\r\n                        nextHooks.onComponentDidUpdate(lastProps$1, nextProps);\r\n                    }\r\n                    nextVNode.dom = nextInput$1.dom;\r\n                }\r\n            }\r\n            if (nextInput$1.flags & 28 /* Component */) {\r\n                nextInput$1.parentVNode = nextVNode;\r\n            }\r\n            else if (lastInput$1.flags & 28 /* Component */) {\r\n                lastInput$1.parentVNode = nextVNode;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction patchText(lastVNode, nextVNode) {\r\n    var nextText = nextVNode.children;\r\n    var dom = lastVNode.dom;\r\n    nextVNode.dom = dom;\r\n    if (lastVNode.children !== nextText) {\r\n        dom.nodeValue = nextText;\r\n    }\r\n}\r\nfunction patchVoid(lastVNode, nextVNode) {\r\n    nextVNode.dom = lastVNode.dom;\r\n}\r\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var lastChildrenLength = lastChildren.length;\r\n    var nextChildrenLength = nextChildren.length;\r\n    var commonLength = lastChildrenLength > nextChildrenLength\r\n        ? nextChildrenLength\r\n        : lastChildrenLength;\r\n    var i = 0;\r\n    for (; i < commonLength; i++) {\r\n        var nextChild = nextChildren[i];\r\n        if (nextChild.dom) {\r\n            nextChild = nextChildren[i] = directClone(nextChild);\r\n        }\r\n        patch(lastChildren[i], nextChild, dom, lifecycle, context, isSVG, isRecycling);\r\n    }\r\n    if (lastChildrenLength < nextChildrenLength) {\r\n        for (i = commonLength; i < nextChildrenLength; i++) {\r\n            var nextChild$1 = nextChildren[i];\r\n            if (nextChild$1.dom) {\r\n                nextChild$1 = nextChildren[i] = directClone(nextChild$1);\r\n            }\r\n            appendChild(dom, mount(nextChild$1, null, lifecycle, context, isSVG));\r\n        }\r\n    }\r\n    else if (nextChildrenLength === 0) {\r\n        removeAllChildren(dom, lastChildren, lifecycle, isRecycling);\r\n    }\r\n    else if (lastChildrenLength > nextChildrenLength) {\r\n        for (i = commonLength; i < lastChildrenLength; i++) {\r\n            unmount(lastChildren[i], dom, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction patchKeyedChildren(a, b, dom, lifecycle, context, isSVG, isRecycling) {\r\n    var aLength = a.length;\r\n    var bLength = b.length;\r\n    var aEnd = aLength - 1;\r\n    var bEnd = bLength - 1;\r\n    var aStart = 0;\r\n    var bStart = 0;\r\n    var i;\r\n    var j;\r\n    var aNode;\r\n    var bNode;\r\n    var nextNode;\r\n    var nextPos;\r\n    var node;\r\n    if (aLength === 0) {\r\n        if (bLength > 0) {\r\n            mountArrayChildren(b, dom, lifecycle, context, isSVG);\r\n        }\r\n        return;\r\n    }\r\n    else if (bLength === 0) {\r\n        removeAllChildren(dom, a, lifecycle, isRecycling);\r\n        return;\r\n    }\r\n    var aStartNode = a[aStart];\r\n    var bStartNode = b[bStart];\r\n    var aEndNode = a[aEnd];\r\n    var bEndNode = b[bEnd];\r\n    if (bStartNode.dom) {\r\n        b[bStart] = bStartNode = directClone(bStartNode);\r\n    }\r\n    if (bEndNode.dom) {\r\n        b[bEnd] = bEndNode = directClone(bEndNode);\r\n    }\r\n    // Step 1\r\n    /* eslint no-constant-condition: 0 */\r\n    outer: while (true) {\r\n        // Sync nodes with the same key at the beginning.\r\n        while (aStartNode.key === bStartNode.key) {\r\n            patch(aStartNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            aStart++;\r\n            bStart++;\r\n            if (aStart > aEnd || bStart > bEnd) {\r\n                break outer;\r\n            }\r\n            aStartNode = a[aStart];\r\n            bStartNode = b[bStart];\r\n            if (bStartNode.dom) {\r\n                b[bStart] = bStartNode = directClone(bStartNode);\r\n            }\r\n        }\r\n        // Sync nodes with the same key at the end.\r\n        while (aEndNode.key === bEndNode.key) {\r\n            patch(aEndNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            aEnd--;\r\n            bEnd--;\r\n            if (aStart > aEnd || bStart > bEnd) {\r\n                break outer;\r\n            }\r\n            aEndNode = a[aEnd];\r\n            bEndNode = b[bEnd];\r\n            if (bEndNode.dom) {\r\n                b[bEnd] = bEndNode = directClone(bEndNode);\r\n            }\r\n        }\r\n        // Move and sync nodes from right to left.\r\n        if (aEndNode.key === bStartNode.key) {\r\n            patch(aEndNode, bStartNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            insertOrAppend(dom, bStartNode.dom, aStartNode.dom);\r\n            aEnd--;\r\n            bStart++;\r\n            aEndNode = a[aEnd];\r\n            bStartNode = b[bStart];\r\n            if (bStartNode.dom) {\r\n                b[bStart] = bStartNode = directClone(bStartNode);\r\n            }\r\n            continue;\r\n        }\r\n        // Move and sync nodes from left to right.\r\n        if (aStartNode.key === bEndNode.key) {\r\n            patch(aStartNode, bEndNode, dom, lifecycle, context, isSVG, isRecycling);\r\n            nextPos = bEnd + 1;\r\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n            insertOrAppend(dom, bEndNode.dom, nextNode);\r\n            aStart++;\r\n            bEnd--;\r\n            aStartNode = a[aStart];\r\n            bEndNode = b[bEnd];\r\n            if (bEndNode.dom) {\r\n                b[bEnd] = bEndNode = directClone(bEndNode);\r\n            }\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    if (aStart > aEnd) {\r\n        if (bStart <= bEnd) {\r\n            nextPos = bEnd + 1;\r\n            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n            while (bStart <= bEnd) {\r\n                node = b[bStart];\r\n                if (node.dom) {\r\n                    b[bStart] = node = directClone(node);\r\n                }\r\n                bStart++;\r\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n            }\r\n        }\r\n    }\r\n    else if (bStart > bEnd) {\r\n        while (aStart <= aEnd) {\r\n            unmount(a[aStart++], dom, lifecycle, false, isRecycling);\r\n        }\r\n    }\r\n    else {\r\n        aLength = aEnd - aStart + 1;\r\n        bLength = bEnd - bStart + 1;\r\n        var sources = new Array(bLength);\r\n        // Mark all nodes as inserted.\r\n        for (i = 0; i < bLength; i++) {\r\n            sources[i] = -1;\r\n        }\r\n        var moved = false;\r\n        var pos = 0;\r\n        var patched = 0;\r\n        // When sizes are small, just loop them through\r\n        if (bLength <= 4 || aLength * bLength <= 16) {\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLength) {\r\n                    for (j = bStart; j <= bEnd; j++) {\r\n                        bNode = b[j];\r\n                        if (aNode.key === bNode.key) {\r\n                            sources[j - bStart] = i;\r\n                            if (pos > j) {\r\n                                moved = true;\r\n                            }\r\n                            else {\r\n                                pos = j;\r\n                            }\r\n                            if (bNode.dom) {\r\n                                b[j] = bNode = directClone(bNode);\r\n                            }\r\n                            patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\r\n                            patched++;\r\n                            a[i] = null;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            var keyIndex = new Map();\r\n            // Map keys by their index in array\r\n            for (i = bStart; i <= bEnd; i++) {\r\n                keyIndex.set(b[i].key, i);\r\n            }\r\n            // Try to patch same keys\r\n            for (i = aStart; i <= aEnd; i++) {\r\n                aNode = a[i];\r\n                if (patched < bLength) {\r\n                    j = keyIndex.get(aNode.key);\r\n                    if (!isUndefined(j)) {\r\n                        bNode = b[j];\r\n                        sources[j - bStart] = i;\r\n                        if (pos > j) {\r\n                            moved = true;\r\n                        }\r\n                        else {\r\n                            pos = j;\r\n                        }\r\n                        if (bNode.dom) {\r\n                            b[j] = bNode = directClone(bNode);\r\n                        }\r\n                        patch(aNode, bNode, dom, lifecycle, context, isSVG, isRecycling);\r\n                        patched++;\r\n                        a[i] = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // fast-path: if nothing patched remove all old and add all new\r\n        if (aLength === a.length && patched === 0) {\r\n            removeAllChildren(dom, a, lifecycle, isRecycling);\r\n            while (bStart < bLength) {\r\n                node = b[bStart];\r\n                if (node.dom) {\r\n                    b[bStart] = node = directClone(node);\r\n                }\r\n                bStart++;\r\n                insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), null);\r\n            }\r\n        }\r\n        else {\r\n            i = aLength - patched;\r\n            while (i > 0) {\r\n                aNode = a[aStart++];\r\n                if (!isNull(aNode)) {\r\n                    unmount(aNode, dom, lifecycle, true, isRecycling);\r\n                    i--;\r\n                }\r\n            }\r\n            if (moved) {\r\n                var seq = lis_algorithm(sources);\r\n                j = seq.length - 1;\r\n                for (i = bLength - 1; i >= 0; i--) {\r\n                    if (sources[i] === -1) {\r\n                        pos = i + bStart;\r\n                        node = b[pos];\r\n                        if (node.dom) {\r\n                            b[pos] = node = directClone(node);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n                    }\r\n                    else {\r\n                        if (j < 0 || i !== seq[j]) {\r\n                            pos = i + bStart;\r\n                            node = b[pos];\r\n                            nextPos = pos + 1;\r\n                            nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                            insertOrAppend(dom, node.dom, nextNode);\r\n                        }\r\n                        else {\r\n                            j--;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else if (patched !== bLength) {\r\n                // when patched count doesn't match b length we need to insert those new ones\r\n                // loop backwards so we can use insertBefore\r\n                for (i = bLength - 1; i >= 0; i--) {\r\n                    if (sources[i] === -1) {\r\n                        pos = i + bStart;\r\n                        node = b[pos];\r\n                        if (node.dom) {\r\n                            b[pos] = node = directClone(node);\r\n                        }\r\n                        nextPos = pos + 1;\r\n                        nextNode = nextPos < b.length ? b[nextPos].dom : null;\r\n                        insertOrAppend(dom, mount(node, null, lifecycle, context, isSVG), nextNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n// // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\r\nfunction lis_algorithm(arr) {\r\n    var p = arr.slice(0);\r\n    var result = [0];\r\n    var i;\r\n    var j;\r\n    var u;\r\n    var v;\r\n    var c;\r\n    var len = arr.length;\r\n    for (i = 0; i < len; i++) {\r\n        var arrI = arr[i];\r\n        if (arrI === -1) {\r\n            continue;\r\n        }\r\n        j = result[result.length - 1];\r\n        if (arr[j] < arrI) {\r\n            p[i] = j;\r\n            result.push(i);\r\n            continue;\r\n        }\r\n        u = 0;\r\n        v = result.length - 1;\r\n        while (u < v) {\r\n            c = ((u + v) / 2) | 0;\r\n            if (arr[result[c]] < arrI) {\r\n                u = c + 1;\r\n            }\r\n            else {\r\n                v = c;\r\n            }\r\n        }\r\n        if (arrI < arr[result[u]]) {\r\n            if (u > 0) {\r\n                p[i] = result[u - 1];\r\n            }\r\n            result[u] = i;\r\n        }\r\n    }\r\n    u = result.length;\r\n    v = result[u - 1];\r\n    while (u-- > 0) {\r\n        result[u] = v;\r\n        v = p[v];\r\n    }\r\n    return result;\r\n}\r\nfunction isAttrAnEvent(attr) {\r\n    return attr[0] === \"o\" && attr[1] === \"n\";\r\n}\r\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue) {\r\n    if (lastValue !== nextValue) {\r\n        if (skipProps.has(prop) || (hasControlledValue && prop === \"value\")) {\r\n            return;\r\n        }\r\n        else if (booleanProps.has(prop)) {\r\n            prop = prop === \"autoFocus\" ? prop.toLowerCase() : prop;\r\n            dom[prop] = !!nextValue;\r\n        }\r\n        else if (strictProps.has(prop)) {\r\n            var value = isNullOrUndef(nextValue) ? \"\" : nextValue;\r\n            if (dom[prop] !== value) {\r\n                dom[prop] = value;\r\n            }\r\n        }\r\n        else if (isAttrAnEvent(prop)) {\r\n            patchEvent(prop, lastValue, nextValue, dom);\r\n        }\r\n        else if (isNullOrUndef(nextValue)) {\r\n            dom.removeAttribute(prop);\r\n        }\r\n        else if (prop === \"style\") {\r\n            patchStyle(lastValue, nextValue, dom);\r\n        }\r\n        else if (prop === \"dangerouslySetInnerHTML\") {\r\n            var lastHtml = lastValue && lastValue.__html;\r\n            var nextHtml = nextValue && nextValue.__html;\r\n            if (lastHtml !== nextHtml) {\r\n                if (!isNullOrUndef(nextHtml)) {\r\n                    dom.innerHTML = nextHtml;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // We optimize for NS being boolean. Its 99.9% time false\r\n            if (isSVG && namespaces.has(prop)) {\r\n                // If we end up in this path we can read property again\r\n                dom.setAttributeNS(namespaces.get(prop), prop, nextValue);\r\n            }\r\n            else {\r\n                dom.setAttribute(prop, nextValue);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction patchEvent(name, lastValue, nextValue, dom) {\r\n    if (lastValue !== nextValue) {\r\n        if (delegatedEvents.has(name)) {\r\n            handleEvent(name, lastValue, nextValue, dom);\r\n        }\r\n        else {\r\n            var nameLowerCase = name.toLowerCase();\r\n            var domEvent = dom[nameLowerCase];\r\n            // if the function is wrapped, that means it's been controlled by a wrapper\r\n            if (domEvent && domEvent.wrapped) {\r\n                return;\r\n            }\r\n            if (!isFunction(nextValue) && !isNullOrUndef(nextValue)) {\r\n                var linkEvent = nextValue.event;\r\n                if (linkEvent && isFunction(linkEvent)) {\r\n                    dom[nameLowerCase] = function (e) {\r\n                        linkEvent(nextValue.data, e);\r\n                    };\r\n                }\r\n                else {\r\n                    if (process.env.NODE_ENV !== \"production\") {\r\n                        throwError((\"an event on a VNode \\\"\" + name + \"\\\". was not a function or a valid linkEvent.\"));\r\n                    }\r\n                    throwError();\r\n                }\r\n            }\r\n            else {\r\n                dom[nameLowerCase] = nextValue;\r\n            }\r\n        }\r\n    }\r\n}\r\n// We are assuming here that we come from patchProp routine\r\n// -nextAttrValue cannot be null or undefined\r\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\r\n    var domStyle = dom.style;\r\n    var style;\r\n    var value;\r\n    if (isString(nextAttrValue)) {\r\n        domStyle.cssText = nextAttrValue;\r\n        return;\r\n    }\r\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\r\n        for (style in nextAttrValue) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            value = nextAttrValue[style];\r\n            if (value !== lastAttrValue[style]) {\r\n                domStyle[style] =\r\n                    !isNumber(value) || isUnitlessNumber.has(style)\r\n                        ? value\r\n                        : value + \"px\";\r\n            }\r\n        }\r\n        for (style in lastAttrValue) {\r\n            if (isNullOrUndef(nextAttrValue[style])) {\r\n                domStyle[style] = \"\";\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (style in nextAttrValue) {\r\n            value = nextAttrValue[style];\r\n            domStyle[style] =\r\n                !isNumber(value) || isUnitlessNumber.has(style) ? value : value + \"px\";\r\n        }\r\n    }\r\n}\r\nfunction removeProp(prop, lastValue, dom, nextFlags) {\r\n    if (prop === \"value\") {\r\n        // When removing value of select element, it needs to be set to null instead empty string, because empty string is valid value for option which makes that option selected\r\n        // MS IE/Edge don't follow html spec for textArea and input elements and we need to set empty string to value in those cases to avoid \"null\" and \"undefined\" texts\r\n        dom.value = nextFlags & 2048 /* SelectElement */ ? null : \"\";\r\n    }\r\n    else if (prop === \"style\") {\r\n        dom.removeAttribute(\"style\");\r\n    }\r\n    else if (isAttrAnEvent(prop)) {\r\n        handleEvent(prop, lastValue, null, dom);\r\n    }\r\n    else {\r\n        dom.removeAttribute(prop);\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction mount(vNode, parentDom, lifecycle, context, isSVG) {\r\n    var flags = vNode.flags;\r\n    if (flags & 3970 /* Element */) {\r\n        return mountElement(vNode, parentDom, lifecycle, context, isSVG);\r\n    }\r\n    else if (flags & 28 /* Component */) {\r\n        return mountComponent(vNode, parentDom, lifecycle, context, isSVG, (flags & 4 /* ComponentClass */) > 0);\r\n    }\r\n    else if (flags & 4096 /* Void */) {\r\n        return mountVoid(vNode, parentDom);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        return mountText(vNode, parentDom);\r\n    }\r\n    else {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            if (typeof vNode === \"object\") {\r\n                throwError((\"mount() received an object that's not a valid VNode, you should stringify it first. Object: \\\"\" + (JSON.stringify(vNode)) + \"\\\".\"));\r\n            }\r\n            else {\r\n                throwError((\"mount() expects a valid VNode, instead it received an object with the type \\\"\" + (typeof vNode) + \"\\\".\"));\r\n            }\r\n        }\r\n        throwError();\r\n    }\r\n}\r\nfunction mountText(vNode, parentDom) {\r\n    var dom = document.createTextNode(vNode.children);\r\n    vNode.dom = dom;\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountVoid(vNode, parentDom) {\r\n    var dom = document.createTextNode(\"\");\r\n    vNode.dom = dom;\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountElement(vNode, parentDom, lifecycle, context, isSVG) {\r\n    var dom;\r\n    if (options.recyclingEnabled) {\r\n        dom = recycleElement(vNode, lifecycle, context, isSVG);\r\n        if (!isNull(dom)) {\r\n            if (!isNull(parentDom)) {\r\n                appendChild(parentDom, dom);\r\n            }\r\n            return dom;\r\n        }\r\n    }\r\n    var flags = vNode.flags;\r\n    isSVG = isSVG || (flags & 128 /* SvgElement */) > 0;\r\n    dom = documentCreateElement(vNode.type, isSVG);\r\n    var children = vNode.children;\r\n    var props = vNode.props;\r\n    var className = vNode.className;\r\n    var ref = vNode.ref;\r\n    vNode.dom = dom;\r\n    if (!isInvalid(children)) {\r\n        if (isStringOrNumber(children)) {\r\n            setTextContent(dom, children);\r\n        }\r\n        else {\r\n            var childrenIsSVG = isSVG === true && vNode.type !== \"foreignObject\";\r\n            if (isArray(children)) {\r\n                mountArrayChildren(children, dom, lifecycle, context, childrenIsSVG);\r\n            }\r\n            else if (isVNode(children)) {\r\n                mount(children, dom, lifecycle, context, childrenIsSVG);\r\n            }\r\n        }\r\n    }\r\n    if (!isNull(props)) {\r\n        var hasControlledValue = false;\r\n        var isFormElement = (flags & 3584 /* FormElement */) > 0;\r\n        if (isFormElement) {\r\n            hasControlledValue = isControlledFormElement(props);\r\n        }\r\n        for (var prop in props) {\r\n            // do not add a hasOwnProperty check here, it affects performance\r\n            patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue);\r\n        }\r\n        if (isFormElement) {\r\n            processElement(flags, vNode, dom, props, true, hasControlledValue);\r\n        }\r\n    }\r\n    if (className !== null) {\r\n        if (isSVG) {\r\n            dom.setAttribute(\"class\", className);\r\n        }\r\n        else {\r\n            dom.className = className;\r\n        }\r\n    }\r\n    if (!isNull(ref)) {\r\n        mountRef(dom, ref, lifecycle);\r\n    }\r\n    if (!isNull(parentDom)) {\r\n        appendChild(parentDom, dom);\r\n    }\r\n    return dom;\r\n}\r\nfunction mountArrayChildren(children, dom, lifecycle, context, isSVG) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        // Verify can string/number be here. might cause de-opt. - Normalization takes care of it.\r\n        if (!isInvalid(child)) {\r\n            if (child.dom) {\r\n                children[i] = child = directClone(child);\r\n            }\r\n            mount(children[i], dom, lifecycle, context, isSVG);\r\n        }\r\n    }\r\n}\r\nfunction mountComponent(vNode, parentDom, lifecycle, context, isSVG, isClass) {\r\n    var dom;\r\n    if (options.recyclingEnabled) {\r\n        dom = recycleComponent(vNode, lifecycle, context, isSVG);\r\n        if (!isNull(dom)) {\r\n            if (!isNull(parentDom)) {\r\n                appendChild(parentDom, dom);\r\n            }\r\n            return dom;\r\n        }\r\n    }\r\n    var type = vNode.type;\r\n    var props = vNode.props || EMPTY_OBJ;\r\n    var ref = vNode.ref;\r\n    if (isClass) {\r\n        var instance = createClassComponentInstance(vNode, type, props, context, isSVG, lifecycle);\r\n        var input = instance._lastInput;\r\n        instance._vNode = vNode;\r\n        vNode.dom = dom = mount(input, null, lifecycle, instance._childContext, isSVG);\r\n        if (!isNull(parentDom)) {\r\n            appendChild(parentDom, dom);\r\n        }\r\n        mountClassComponentCallbacks(vNode, ref, instance, lifecycle);\r\n        instance._updating = false;\r\n        if (options.findDOMNodeEnabled) {\r\n            componentToDOMNodeMap.set(instance, dom);\r\n        }\r\n    }\r\n    else {\r\n        var input$1 = createFunctionalComponentInput(vNode, type, props, context);\r\n        vNode.dom = dom = mount(input$1, null, lifecycle, context, isSVG);\r\n        vNode.children = input$1;\r\n        mountFunctionalComponentCallbacks(props, ref, dom, lifecycle);\r\n        if (!isNull(parentDom)) {\r\n            appendChild(parentDom, dom);\r\n        }\r\n    }\r\n    return dom;\r\n}\r\nfunction mountClassComponentCallbacks(vNode, ref, instance, lifecycle) {\r\n    if (ref) {\r\n        if (isFunction(ref)) {\r\n            ref(instance);\r\n        }\r\n        else {\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                if (isStringOrNumber(ref)) {\r\n                    throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n                }\r\n                else if (isObject(ref) && vNode.flags & 4 /* ComponentClass */) {\r\n                    throwError(\"functional component lifecycle events are not supported on ES2015 class components.\");\r\n                }\r\n                else {\r\n                    throwError((\"a bad value for \\\"ref\\\" was used on component: \\\"\" + (JSON.stringify(ref)) + \"\\\"\"));\r\n                }\r\n            }\r\n            throwError();\r\n        }\r\n    }\r\n    var hasDidMount = !isUndefined(instance.componentDidMount);\r\n    var afterMount = options.afterMount;\r\n    if (hasDidMount || !isNull(afterMount)) {\r\n        lifecycle.addListener((function () {\r\n            instance._updating = true;\r\n            if (afterMount) {\r\n                afterMount(vNode);\r\n            }\r\n            if (hasDidMount) {\r\n                instance.componentDidMount();\r\n            }\r\n            instance._updating = false;\r\n        }));\r\n    }\r\n}\r\nfunction mountFunctionalComponentCallbacks(props, ref, dom, lifecycle) {\r\n    if (ref) {\r\n        if (!isNullOrUndef(ref.onComponentWillMount)) {\r\n            ref.onComponentWillMount(props);\r\n        }\r\n        if (!isNullOrUndef(ref.onComponentDidMount)) {\r\n            lifecycle.addListener((function () { return ref.onComponentDidMount(dom, props); }));\r\n        }\r\n    }\r\n}\r\nfunction mountRef(dom, value, lifecycle) {\r\n    if (isFunction(value)) {\r\n        lifecycle.addListener((function () { return value(dom); }));\r\n    }\r\n    else {\r\n        if (isInvalid(value)) {\r\n            return;\r\n        }\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError('string \"refs\" are not supported in Inferno 1.0. Use callback \"refs\" instead.');\r\n        }\r\n        throwError();\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n// We need EMPTY_OBJ defined in one place.\r\n// Its used for comparison so we cant inline it into shared\r\nvar EMPTY_OBJ = {};\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    Object.freeze(EMPTY_OBJ);\r\n}\r\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\r\n    if (isUndefined(context)) {\r\n        context = EMPTY_OBJ; // Context should not be mutable\r\n    }\r\n    var instance = new Component(props, context);\r\n    vNode.children = instance;\r\n    instance._blockSetState = false;\r\n    instance.context = context;\r\n    if (instance.props === EMPTY_OBJ) {\r\n        instance.props = props;\r\n    }\r\n    // setState callbacks must fire after render is done when called from componentWillReceiveProps or componentWillMount\r\n    instance._lifecycle = lifecycle;\r\n    instance._unmounted = false;\r\n    instance._pendingSetState = true;\r\n    instance._isSVG = isSVG;\r\n    if (!isNullOrUndef(instance.componentWillMount)) {\r\n        instance._blockRender = true;\r\n        instance.componentWillMount();\r\n        instance._blockRender = false;\r\n    }\r\n    var childContext;\r\n    if (!isNullOrUndef(instance.getChildContext)) {\r\n        childContext = instance.getChildContext();\r\n    }\r\n    if (isNullOrUndef(childContext)) {\r\n        instance._childContext = context;\r\n    }\r\n    else {\r\n        instance._childContext = combineFrom(context, childContext);\r\n    }\r\n    if (!isNull(options.beforeRender)) {\r\n        options.beforeRender(instance);\r\n    }\r\n    var input = instance.render(props, instance.state, context);\r\n    if (!isNull(options.afterRender)) {\r\n        options.afterRender(instance);\r\n    }\r\n    if (isArray(input)) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n        }\r\n        throwError();\r\n    }\r\n    else if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 28 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = vNode;\r\n        }\r\n    }\r\n    instance._pendingSetState = false;\r\n    instance._lastInput = input;\r\n    return instance;\r\n}\r\nfunction replaceLastChildAndUnmount(lastInput, nextInput, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    replaceVNode(parentDom, mount(nextInput, null, lifecycle, context, isSVG), lastInput, lifecycle, isRecycling);\r\n}\r\nfunction replaceVNode(parentDom, dom, vNode, lifecycle, isRecycling) {\r\n    unmount(vNode, null, lifecycle, false, isRecycling);\r\n    replaceChild(parentDom, dom, vNode.dom);\r\n}\r\nfunction createFunctionalComponentInput(vNode, component, props, context) {\r\n    var input = component(props, context);\r\n    if (isArray(input)) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n        }\r\n        throwError();\r\n    }\r\n    else if (isInvalid(input)) {\r\n        input = createVoidVNode();\r\n    }\r\n    else if (isStringOrNumber(input)) {\r\n        input = createTextVNode(input, null);\r\n    }\r\n    else {\r\n        if (input.dom) {\r\n            input = directClone(input);\r\n        }\r\n        if (input.flags & 28 /* Component */) {\r\n            // if we have an input that is also a component, we run into a tricky situation\r\n            // where the root vNode needs to always have the correct DOM entry\r\n            // so we break monomorphism on our input and supply it our vNode as parentVNode\r\n            // we can optimise this in the future, but this gets us out of a lot of issues\r\n            input.parentVNode = vNode;\r\n        }\r\n    }\r\n    return input;\r\n}\r\nfunction setTextContent(dom, text) {\r\n    if (text !== \"\") {\r\n        dom.textContent = text;\r\n    }\r\n    else {\r\n        dom.appendChild(document.createTextNode(\"\"));\r\n    }\r\n}\r\nfunction updateTextContent(dom, text) {\r\n    dom.firstChild.nodeValue = text;\r\n}\r\nfunction appendChild(parentDom, dom) {\r\n    parentDom.appendChild(dom);\r\n}\r\nfunction insertOrAppend(parentDom, newNode, nextNode) {\r\n    if (isNullOrUndef(nextNode)) {\r\n        appendChild(parentDom, newNode);\r\n    }\r\n    else {\r\n        parentDom.insertBefore(newNode, nextNode);\r\n    }\r\n}\r\nfunction documentCreateElement(tag, isSVG) {\r\n    if (isSVG === true) {\r\n        return document.createElementNS(svgNS, tag);\r\n    }\r\n    else {\r\n        return document.createElement(tag);\r\n    }\r\n}\r\nfunction replaceWithNewNode(lastNode, nextNode, parentDom, lifecycle, context, isSVG, isRecycling) {\r\n    unmount(lastNode, null, lifecycle, false, isRecycling);\r\n    var dom = mount(nextNode, null, lifecycle, context, isSVG);\r\n    nextNode.dom = dom;\r\n    replaceChild(parentDom, dom, lastNode.dom);\r\n}\r\nfunction replaceChild(parentDom, nextDom, lastDom) {\r\n    if (!parentDom) {\r\n        parentDom = lastDom.parentNode;\r\n    }\r\n    parentDom.replaceChild(nextDom, lastDom);\r\n}\r\nfunction removeChild(parentDom, dom) {\r\n    parentDom.removeChild(dom);\r\n}\r\nfunction removeAllChildren(dom, children, lifecycle, isRecycling) {\r\n    if (!options.recyclingEnabled || (options.recyclingEnabled && !isRecycling)) {\r\n        removeChildren(null, children, lifecycle, isRecycling);\r\n    }\r\n    dom.textContent = \"\";\r\n}\r\nfunction removeChildren(dom, children, lifecycle, isRecycling) {\r\n    for (var i = 0, len = children.length; i < len; i++) {\r\n        var child = children[i];\r\n        if (!isInvalid(child)) {\r\n            unmount(child, dom, lifecycle, true, isRecycling);\r\n        }\r\n    }\r\n}\r\nfunction isKeyed(lastChildren, nextChildren) {\r\n    return (nextChildren.length > 0 &&\r\n        !isNullOrUndef(nextChildren[0]) &&\r\n        !isNullOrUndef(nextChildren[0].key) &&\r\n        lastChildren.length > 0 &&\r\n        !isNullOrUndef(lastChildren[0]) &&\r\n        !isNullOrUndef(lastChildren[0].key));\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction VNode(children, className, flags, key, props, ref, type) {\r\n    this.children = children;\r\n    this.className = className;\r\n    this.dom = null;\r\n    this.flags = flags;\r\n    this.key = key;\r\n    this.props = props;\r\n    this.ref = ref;\r\n    this.type = type;\r\n}\r\n/**\r\n * Creates virtual node\r\n * @param {number} flags\r\n * @param {string|Function|null} type\r\n * @param {string|null=} className\r\n * @param {object=} children\r\n * @param {object=} props\r\n * @param {*=} key\r\n * @param {object|Function=} ref\r\n * @param {boolean=} noNormalise\r\n * @returns {VNode} returns new virtual node\r\n */\r\nfunction createVNode(flags, type, className, children, props, key, ref, noNormalise) {\r\n    if (flags & 16 /* ComponentUnknown */) {\r\n        flags = isStatefulComponent(type)\r\n            ? 4 /* ComponentClass */\r\n            : 8 /* ComponentFunction */;\r\n    }\r\n    var vNode = new VNode(children === void 0 ? null : children, className === void 0 ? null : className, flags, key === void 0 ? null : key, props === void 0 ? null : props, ref === void 0 ? null : ref, type);\r\n    if (noNormalise !== true) {\r\n        normalize(vNode);\r\n    }\r\n    if (options.createVNode !== null) {\r\n        options.createVNode(vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction directClone(vNodeToClone) {\r\n    var newVNode;\r\n    var flags = vNodeToClone.flags;\r\n    if (flags & 28 /* Component */) {\r\n        var props;\r\n        var propsToClone = vNodeToClone.props;\r\n        if (isNull(propsToClone)) {\r\n            props = EMPTY_OBJ;\r\n        }\r\n        else {\r\n            props = {};\r\n            for (var key in propsToClone) {\r\n                props[key] = propsToClone[key];\r\n            }\r\n        }\r\n        newVNode = createVNode(flags, vNodeToClone.type, null, null, props, vNodeToClone.key, vNodeToClone.ref, true);\r\n        var newProps = newVNode.props;\r\n        var newChildren = newProps.children;\r\n        // we need to also clone component children that are in props\r\n        // as the children may also have been hoisted\r\n        if (newChildren) {\r\n            if (isArray(newChildren)) {\r\n                var len = newChildren.length;\r\n                if (len > 0) {\r\n                    var tmpArray = [];\r\n                    for (var i = 0; i < len; i++) {\r\n                        var child = newChildren[i];\r\n                        if (isStringOrNumber(child)) {\r\n                            tmpArray.push(child);\r\n                        }\r\n                        else if (!isInvalid(child) && isVNode(child)) {\r\n                            tmpArray.push(directClone(child));\r\n                        }\r\n                    }\r\n                    newProps.children = tmpArray;\r\n                }\r\n            }\r\n            else if (isVNode(newChildren)) {\r\n                newProps.children = directClone(newChildren);\r\n            }\r\n        }\r\n        newVNode.children = null;\r\n    }\r\n    else if (flags & 3970 /* Element */) {\r\n        var children = vNodeToClone.children;\r\n        var props$1;\r\n        var propsToClone$1 = vNodeToClone.props;\r\n        if (propsToClone$1 === null) {\r\n            props$1 = EMPTY_OBJ;\r\n        }\r\n        else {\r\n            props$1 = {};\r\n            for (var key$1 in propsToClone$1) {\r\n                props$1[key$1] = propsToClone$1[key$1];\r\n            }\r\n        }\r\n        newVNode = createVNode(flags, vNodeToClone.type, vNodeToClone.className, children, props$1, vNodeToClone.key, vNodeToClone.ref, !children);\r\n    }\r\n    else if (flags & 1 /* Text */) {\r\n        newVNode = createTextVNode(vNodeToClone.children, vNodeToClone.key);\r\n    }\r\n    return newVNode;\r\n}\r\n/*\r\n directClone is preferred over cloneVNode and used internally also.\r\n This function makes Inferno backwards compatible.\r\n And can be tree-shaked by modern bundlers\r\n\n Would be nice to combine this with directClone but could not do it without breaking change\r\n */\r\n/**\r\n * Clones given virtual node by creating new instance of it\r\n * @param {VNode} vNodeToClone virtual node to be cloned\r\n * @param {Props=} props additional props for new virtual node\r\n * @param {...*} _children new children for new virtual node\r\n * @returns {VNode} new virtual node\r\n */\r\nfunction cloneVNode(vNodeToClone, props) {\n    var _children = [], len$2 = arguments.length - 2;\n    while ( len$2-- > 0 ) _children[ len$2 ] = arguments[ len$2 + 2 ];\n\r\n    var children = _children;\r\n    var childrenLen = _children.length;\r\n    if (childrenLen > 0 && !isUndefined(_children[0])) {\r\n        if (!props) {\r\n            props = {};\r\n        }\r\n        if (childrenLen === 1) {\r\n            children = _children[0];\r\n        }\r\n        if (!isUndefined(children)) {\r\n            props.children = children;\r\n        }\r\n    }\r\n    var newVNode;\r\n    if (isArray(vNodeToClone)) {\r\n        var tmpArray = [];\r\n        for (var i = 0, len = vNodeToClone.length; i < len; i++) {\r\n            tmpArray.push(directClone(vNodeToClone[i]));\r\n        }\r\n        newVNode = tmpArray;\r\n    }\r\n    else {\r\n        var flags = vNodeToClone.flags;\r\n        var className = vNodeToClone.className;\r\n        var key = vNodeToClone.key;\r\n        var ref = vNodeToClone.ref;\r\n        if (props) {\r\n            if (props.hasOwnProperty(\"className\")) {\r\n                className = props.className;\r\n            }\r\n            if (props.hasOwnProperty(\"ref\")) {\r\n                ref = props.ref;\r\n            }\r\n            if (props.hasOwnProperty(\"key\")) {\r\n                key = props.key;\r\n            }\r\n        }\r\n        if (flags & 28 /* Component */) {\r\n            newVNode = createVNode(flags, vNodeToClone.type, className, null, !vNodeToClone.props && !props\r\n                ? EMPTY_OBJ\r\n                : combineFrom(vNodeToClone.props, props), key, ref, true);\r\n            var newProps = newVNode.props;\r\n            if (newProps) {\r\n                var newChildren = newProps.children;\r\n                // we need to also clone component children that are in props\r\n                // as the children may also have been hoisted\r\n                if (newChildren) {\r\n                    if (isArray(newChildren)) {\r\n                        var len$1 = newChildren.length;\r\n                        if (len$1 > 0) {\r\n                            var tmpArray$1 = [];\r\n                            for (var i$1 = 0; i$1 < len$1; i$1++) {\r\n                                var child = newChildren[i$1];\r\n                                if (isStringOrNumber(child)) {\r\n                                    tmpArray$1.push(child);\r\n                                }\r\n                                else if (!isInvalid(child) && isVNode(child)) {\r\n                                    tmpArray$1.push(directClone(child));\r\n                                }\r\n                            }\r\n                            newProps.children = tmpArray$1;\r\n                        }\r\n                    }\r\n                    else if (isVNode(newChildren)) {\r\n                        newProps.children = directClone(newChildren);\r\n                    }\r\n                }\r\n            }\r\n            newVNode.children = null;\r\n        }\r\n        else if (flags & 3970 /* Element */) {\r\n            children =\r\n                props && !isUndefined(props.children)\r\n                    ? props.children\r\n                    : vNodeToClone.children;\r\n            newVNode = createVNode(flags, vNodeToClone.type, className, children, !vNodeToClone.props && !props\r\n                ? EMPTY_OBJ\r\n                : combineFrom(vNodeToClone.props, props), key, ref, false);\r\n        }\r\n        else if (flags & 1 /* Text */) {\r\n            newVNode = createTextVNode(vNodeToClone.children, key);\r\n        }\r\n    }\r\n    return newVNode;\r\n}\r\nfunction createVoidVNode() {\r\n    return createVNode(4096 /* Void */, null);\r\n}\r\nfunction createTextVNode(text, key) {\r\n    return createVNode(1 /* Text */, null, null, text, null, key);\r\n}\r\nfunction isVNode(o) {\r\n    return !!o.flags;\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\nfunction applyKey(key, vNode) {\r\n    vNode.key = key;\r\n    return vNode;\r\n}\r\nfunction applyKeyIfMissing(key, vNode) {\r\n    if (isNumber(key)) {\r\n        key = \".\" + key;\r\n    }\r\n    if (isNull(vNode.key) || vNode.key[0] === \".\") {\r\n        return applyKey(key, vNode);\r\n    }\r\n    return vNode;\r\n}\r\nfunction applyKeyPrefix(key, vNode) {\r\n    vNode.key = key + vNode.key;\r\n    return vNode;\r\n}\r\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\r\n    for (var len = nodes.length; index < len; index++) {\r\n        var n = nodes[index];\r\n        var key = currentKey + \".\" + index;\r\n        if (!isInvalid(n)) {\r\n            if (isArray(n)) {\r\n                _normalizeVNodes(n, result, 0, key);\r\n            }\r\n            else {\r\n                if (isStringOrNumber(n)) {\r\n                    n = createTextVNode(n, null);\r\n                }\r\n                else if ((isVNode(n) && n.dom) || (n.key && n.key[0] === \".\")) {\r\n                    n = directClone(n);\r\n                }\r\n                if (isNull(n.key) || n.key[0] === \".\") {\r\n                    n = applyKey(key, n);\r\n                }\r\n                else {\r\n                    n = applyKeyPrefix(currentKey, n);\r\n                }\r\n                result.push(n);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction normalizeVNodes(nodes) {\r\n    var newNodes;\r\n    // we assign $ which basically means we've flagged this array for future note\r\n    // if it comes back again, we need to clone it, as people are using it\r\n    // in an immutable way\r\n    // tslint:disable\r\n    if (nodes[\"$\"] === true) {\r\n        nodes = nodes.slice();\r\n    }\r\n    else {\r\n        nodes[\"$\"] = true;\r\n    }\r\n    // tslint:enable\r\n    for (var i = 0, len = nodes.length; i < len; i++) {\r\n        var n = nodes[i];\r\n        if (isInvalid(n) || isArray(n)) {\r\n            var result = (newNodes || nodes).slice(0, i);\r\n            _normalizeVNodes(nodes, result, i, \"\");\r\n            return result;\r\n        }\r\n        else if (isStringOrNumber(n)) {\r\n            if (!newNodes) {\r\n                newNodes = nodes.slice(0, i);\r\n            }\r\n            newNodes.push(applyKeyIfMissing(i, createTextVNode(n, null)));\r\n        }\r\n        else if ((isVNode(n) && n.dom !== null) ||\r\n            (isNull(n.key) && (n.flags & 64 /* HasNonKeyedChildren */) === 0)) {\r\n            if (!newNodes) {\r\n                newNodes = nodes.slice(0, i);\r\n            }\r\n            newNodes.push(applyKeyIfMissing(i, directClone(n)));\r\n        }\r\n        else if (newNodes) {\r\n            newNodes.push(applyKeyIfMissing(i, directClone(n)));\r\n        }\r\n    }\r\n    return newNodes || nodes;\r\n}\r\nfunction normalizeChildren(children) {\r\n    if (isArray(children)) {\r\n        return normalizeVNodes(children);\r\n    }\r\n    else if (isVNode(children) && children.dom !== null) {\r\n        return directClone(children);\r\n    }\r\n    return children;\r\n}\r\nfunction normalizeProps(vNode, props, children) {\r\n    if (vNode.flags & 3970 /* Element */) {\r\n        if (isNullOrUndef(children) && props.hasOwnProperty(\"children\")) {\r\n            vNode.children = props.children;\r\n        }\r\n        if (props.hasOwnProperty(\"className\")) {\r\n            vNode.className = props.className || null;\r\n            delete props.className;\r\n        }\r\n    }\r\n    if (props.hasOwnProperty(\"ref\")) {\r\n        vNode.ref = props.ref;\r\n        delete props.ref;\r\n    }\r\n    if (props.hasOwnProperty(\"key\")) {\r\n        vNode.key = props.key;\r\n        delete props.key;\r\n    }\r\n}\r\nfunction getFlagsForElementVnode(type) {\r\n    if (type === \"svg\") {\r\n        return 128 /* SvgElement */;\r\n    }\r\n    else if (type === \"input\") {\r\n        return 512 /* InputElement */;\r\n    }\r\n    else if (type === \"select\") {\r\n        return 2048 /* SelectElement */;\r\n    }\r\n    else if (type === \"textarea\") {\r\n        return 1024 /* TextareaElement */;\r\n    }\r\n    else if (type === \"media\") {\r\n        return 256 /* MediaElement */;\r\n    }\r\n    return 2 /* HtmlElement */;\r\n}\r\nfunction normalize(vNode) {\r\n    var props = vNode.props;\r\n    var children = vNode.children;\r\n    // convert a wrongly created type back to element\r\n    // Primitive node doesn't have defaultProps, only Component\r\n    if (vNode.flags & 28 /* Component */) {\r\n        // set default props\r\n        var type = vNode.type;\r\n        var defaultProps = type.defaultProps;\r\n        if (!isNullOrUndef(defaultProps)) {\r\n            if (!props) {\r\n                props = vNode.props = defaultProps; // Create new object if only defaultProps given\r\n            }\r\n            else {\r\n                for (var prop in defaultProps) {\r\n                    if (isUndefined(props[prop])) {\r\n                        props[prop] = defaultProps[prop];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (isString(type)) {\r\n            vNode.flags = getFlagsForElementVnode(type);\r\n            if (props && props.children) {\r\n                vNode.children = props.children;\r\n                children = props.children;\r\n            }\r\n        }\r\n    }\r\n    if (props) {\r\n        normalizeProps(vNode, props, children);\r\n        if (!isInvalid(props.children)) {\r\n            props.children = normalizeChildren(props.children);\r\n        }\r\n    }\r\n    if (!isInvalid(children)) {\r\n        vNode.children = normalizeChildren(children);\r\n    }\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n        // This code will be stripped out from production CODE\r\n        // It helps users to track errors in their applications.\r\n        var verifyKeys = function (vNodes) {\r\n            var keyValues = vNodes.map((function (vnode) {\r\n                return vnode.key;\r\n            }));\r\n            keyValues.some((function (item, idx) {\r\n                var hasDuplicate = keyValues.indexOf(item) !== idx;\r\n                if (hasDuplicate) {\r\n                    warning(\"Inferno normalisation(...): Encountered two children with same key, all keys must be unique within its siblings. Duplicated key is:\" +\r\n                        item);\r\n                }\r\n                return hasDuplicate;\r\n            }));\r\n        };\r\n        if (vNode.children && Array.isArray(vNode.children)) {\r\n            verifyKeys(vNode.children);\r\n        }\r\n    }\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/**\r\n * Links given data to event as first parameter\r\n * @param {*} data data to be linked, it will be available in function as first parameter\r\n * @param {Function} event Function to be called when event occurs\r\n * @returns {{data: *, event: Function}}\r\n */\r\nfunction linkEvent(data, event) {\r\n    if (isFunction(event)) {\r\n        return { data: data, event: event };\r\n    }\r\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\r\n}\n\n/**\r\n * @module Inferno\r\n */ /** TypeDoc Comment */\r\n/* tslint:disable:object-literal-sort-keys */\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    /* tslint:disable-next-line:no-empty */\r\n    var testFunc = function testFn() { };\r\n    if ((testFunc.name || testFunc.toString()).indexOf(\"testFn\") ===\r\n        -1) {\r\n        warning(\"It looks like you're using a minified copy of the development build \" +\r\n            \"of Inferno. When deploying Inferno apps to production, make sure to use \" +\r\n            \"the production build which skips development warnings and is faster. \" +\r\n            \"See http://infernojs.org for more details.\");\r\n    }\r\n}\r\nvar version = \"3.7.1\";\r\n// we duplicate it so it plays nicely with different module loading systems\r\nvar index = {\r\n    EMPTY_OBJ: EMPTY_OBJ,\r\n    NO_OP: NO_OP,\r\n    cloneVNode: cloneVNode,\r\n    createRenderer: createRenderer,\r\n    createVNode: createVNode,\r\n    findDOMNode: findDOMNode,\r\n    getFlagsForElementVnode: getFlagsForElementVnode,\r\n    internal_DOMNodeMap: componentToDOMNodeMap,\r\n    internal_isUnitlessNumber: isUnitlessNumber,\r\n    internal_normalize: normalize,\r\n    internal_patch: patch,\r\n    linkEvent: linkEvent,\r\n    options: options,\r\n    render: render,\r\n    version: version\r\n};\n\nexports['default'] = index;\nexports.EMPTY_OBJ = EMPTY_OBJ;\nexports.NO_OP = NO_OP;\nexports.cloneVNode = cloneVNode;\nexports.createRenderer = createRenderer;\nexports.createVNode = createVNode;\nexports.findDOMNode = findDOMNode;\nexports.getFlagsForElementVnode = getFlagsForElementVnode;\nexports.internal_DOMNodeMap = componentToDOMNodeMap;\nexports.internal_isUnitlessNumber = isUnitlessNumber;\nexports.internal_normalize = normalize;\nexports.internal_patch = patch;\nexports.linkEvent = linkEvent;\nexports.options = options;\nexports.render = render;\nexports.version = version;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_inferno@3.7.1@inferno/dist/index.js\n// module id = 14\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar inferno = require('inferno');\n\n/**\r\n * @module Inferno-Shared\r\n */ /** TypeDoc Comment */\r\nvar NO_OP = \"$NO_OP\";\r\nvar ERROR_MSG = \"a runtime error occured! Use Inferno in development environment to find the error.\";\r\n// This should be boolean and not reference to window.document\r\nvar isBrowser = !!(typeof window !== \"undefined\" && window.document);\r\n// this is MUCH faster than .constructor === Array and instanceof Array\r\n// in Node 7 and the later versions of V8, slower in older versions though\r\nvar isArray = Array.isArray;\r\nfunction isStringOrNumber(o) {\r\n    var type = typeof o;\r\n    return type === \"string\" || type === \"number\";\r\n}\r\nfunction isNullOrUndef(o) {\r\n    return isUndefined(o) || isNull(o);\r\n}\r\nfunction isInvalid(o) {\r\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\r\n}\r\nfunction isFunction(o) {\r\n    return typeof o === \"function\";\r\n}\r\nfunction isNull(o) {\r\n    return o === null;\r\n}\r\nfunction isTrue(o) {\r\n    return o === true;\r\n}\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\r\nfunction throwError(message) {\r\n    if (!message) {\r\n        message = ERROR_MSG;\r\n    }\r\n    throw new Error((\"Inferno Error: \" + message));\r\n}\r\nfunction combineFrom(first, second) {\r\n    var out = {};\r\n    if (first) {\r\n        for (var key in first) {\r\n            out[key] = first[key];\r\n        }\r\n    }\r\n    if (second) {\r\n        for (var key$1 in second) {\r\n            out[key$1] = second[key$1];\r\n        }\r\n    }\r\n    return out;\r\n}\n\n/**\r\n * @module Inferno-Component\r\n */ /** TypeDoc Comment */\r\n// Make sure u use EMPTY_OBJ from 'inferno', otherwise it'll be a different reference\r\nvar noOp = ERROR_MSG;\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    noOp =\r\n        \"Inferno Error: Can only update a mounted or mounting component. This usually means you called setState() or forceUpdate() on an unmounted component. This is a no-op.\";\r\n}\r\nvar componentCallbackQueue = new Map();\r\n// when a components root VNode is also a component, we can run into issues\r\n// this will recursively look for vNode.parentNode if the VNode is a component\r\nfunction updateParentComponentVNodes(vNode, dom) {\r\n    if (vNode.flags & 28 /* Component */) {\r\n        var parentVNode = vNode.parentVNode;\r\n        if (parentVNode) {\r\n            parentVNode.dom = dom;\r\n            updateParentComponentVNodes(parentVNode, dom);\r\n        }\r\n    }\r\n}\r\nvar resolvedPromise = Promise.resolve();\r\nfunction addToQueue(component, force, callback) {\r\n    var queue = componentCallbackQueue.get(component);\r\n    if (queue === void 0) {\r\n        queue = [];\r\n        componentCallbackQueue.set(component, queue);\r\n        resolvedPromise.then((function () {\r\n            componentCallbackQueue.delete(component);\r\n            component._updating = true;\r\n            applyState(component, force, (function () {\r\n                for (var i = 0, len = queue.length; i < len; i++) {\r\n                    queue[i].call(component);\r\n                }\r\n            }));\r\n            component._updating = false;\r\n        }));\r\n    }\r\n    if (!isNullOrUndef(callback)) {\r\n        queue.push(callback);\r\n    }\r\n}\r\nfunction queueStateChanges(component, newState, callback) {\r\n    if (isFunction(newState)) {\r\n        newState = newState(component.state, component.props, component.context);\r\n    }\r\n    var pending = component._pendingState;\r\n    if (isNullOrUndef(pending)) {\r\n        component._pendingState = pending = newState;\r\n    }\r\n    else {\r\n        for (var stateKey in newState) {\r\n            pending[stateKey] = newState[stateKey];\r\n        }\r\n    }\r\n    if (isBrowser && !component._pendingSetState && !component._blockRender) {\r\n        if (!component._updating) {\r\n            component._pendingSetState = true;\r\n            component._updating = true;\r\n            applyState(component, false, callback);\r\n            component._updating = false;\r\n        }\r\n        else {\r\n            addToQueue(component, false, callback);\r\n        }\r\n    }\r\n    else {\r\n        var state = component.state;\r\n        if (state === null) {\r\n            component.state = pending;\r\n        }\r\n        else {\r\n            for (var key in pending) {\r\n                state[key] = pending[key];\r\n            }\r\n        }\r\n        component._pendingState = null;\r\n        if (!isNullOrUndef(callback) && component._blockRender) {\r\n            component._lifecycle.addListener(callback.bind(component));\r\n        }\r\n    }\r\n}\r\nfunction applyState(component, force, callback) {\r\n    if (component._unmounted) {\r\n        return;\r\n    }\r\n    if (force || !component._blockRender) {\r\n        component._pendingSetState = false;\r\n        var pendingState = component._pendingState;\r\n        var prevState = component.state;\r\n        var nextState = combineFrom(prevState, pendingState);\r\n        var props = component.props;\r\n        var context = component.context;\r\n        component._pendingState = null;\r\n        var nextInput = component._updateComponent(prevState, nextState, props, props, context, force, true);\r\n        var didUpdate = true;\r\n        if (isInvalid(nextInput)) {\r\n            nextInput = inferno.createVNode(4096 /* Void */, null);\r\n        }\r\n        else if (nextInput === NO_OP) {\r\n            nextInput = component._lastInput;\r\n            didUpdate = false;\r\n        }\r\n        else if (isStringOrNumber(nextInput)) {\r\n            nextInput = inferno.createVNode(1 /* Text */, null, null, nextInput);\r\n        }\r\n        else if (isArray(nextInput)) {\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                throwError(\"a valid Inferno VNode (or null) must be returned from a component render. You may have returned an array or an invalid object.\");\r\n            }\r\n            throwError();\r\n        }\r\n        var lastInput = component._lastInput;\r\n        var vNode = component._vNode;\r\n        var parentDom = (lastInput.dom && lastInput.dom.parentNode) ||\r\n            (lastInput.dom = vNode.dom);\r\n        component._lastInput = nextInput;\r\n        if (didUpdate) {\r\n            var childContext;\r\n            if (!isNullOrUndef(component.getChildContext)) {\r\n                childContext = component.getChildContext();\r\n            }\r\n            if (isNullOrUndef(childContext)) {\r\n                childContext = component._childContext;\r\n            }\r\n            else {\r\n                childContext = combineFrom(context, childContext);\r\n            }\r\n            var lifeCycle = component._lifecycle;\r\n            inferno.internal_patch(lastInput, nextInput, parentDom, lifeCycle, childContext, component._isSVG, false);\r\n            lifeCycle.trigger();\r\n            if (!isNullOrUndef(component.componentDidUpdate)) {\r\n                component.componentDidUpdate(props, prevState, context);\r\n            }\r\n            if (!isNull(inferno.options.afterUpdate)) {\r\n                inferno.options.afterUpdate(vNode);\r\n            }\r\n        }\r\n        var dom = (vNode.dom = nextInput.dom);\r\n        if (inferno.options.findDOMNodeEnabled) {\r\n            inferno.internal_DOMNodeMap.set(component, nextInput.dom);\r\n        }\r\n        updateParentComponentVNodes(vNode, dom);\r\n    }\r\n    else {\r\n        component.state = component._pendingState;\r\n        component._pendingState = null;\r\n    }\r\n    if (!isNullOrUndef(callback)) {\r\n        callback.call(component);\r\n    }\r\n}\r\nvar alreadyWarned = false;\r\nvar Component = function Component(props, context) {\r\n    this.state = null;\r\n    this._blockRender = false;\r\n    this._blockSetState = true;\r\n    this._pendingSetState = false;\r\n    this._pendingState = null;\r\n    this._lastInput = null;\r\n    this._vNode = null;\r\n    this._unmounted = false;\r\n    this._lifecycle = null;\r\n    this._childContext = null;\r\n    this._isSVG = false;\r\n    this._updating = true;\r\n    /** @type {object} */\r\n    this.props = props || inferno.EMPTY_OBJ;\r\n    /** @type {object} */\r\n    this.context = context || inferno.EMPTY_OBJ; // context should not be mutable\r\n};\r\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\r\n    if (this._unmounted || !isBrowser) {\r\n        return;\r\n    }\r\n    applyState(this, true, callback);\r\n};\r\nComponent.prototype.setState = function setState (newState, callback) {\r\n    if (this._unmounted) {\r\n        return;\r\n    }\r\n    if (!this._blockSetState) {\r\n        queueStateChanges(this, newState, callback);\r\n    }\r\n    else {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(\"cannot update state via setState() in componentWillUpdate() or constructor.\");\r\n        }\r\n        throwError();\r\n    }\r\n};\r\nComponent.prototype.setStateSync = function setStateSync (newState) {\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n        if (!alreadyWarned) {\r\n            alreadyWarned = true;\r\n            // tslint:disable-next-line:no-console\r\n            console.warn(\"Inferno WARNING: setStateSync has been deprecated and will be removed in next release. Use setState instead.\");\r\n        }\r\n    }\r\n    this.setState(newState);\r\n};\r\nComponent.prototype._updateComponent = function _updateComponent (prevState, nextState, prevProps, nextProps, context, force, fromSetState) {\r\n    if (this._unmounted === true) {\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            throwError(noOp);\r\n        }\r\n        throwError();\r\n    }\r\n    if (prevProps !== nextProps ||\r\n        nextProps === inferno.EMPTY_OBJ ||\r\n        prevState !== nextState ||\r\n        force) {\r\n        if (prevProps !== nextProps || nextProps === inferno.EMPTY_OBJ) {\r\n            if (!isNullOrUndef(this.componentWillReceiveProps) && !fromSetState) {\r\n                // keep a copy of state before componentWillReceiveProps\r\n                var beforeState = combineFrom(this.state);\r\n                this._blockRender = true;\r\n                this.componentWillReceiveProps(nextProps, context);\r\n                this._blockRender = false;\r\n                var afterState = this.state;\r\n                if (beforeState !== afterState) {\r\n                    // if state changed in componentWillReceiveProps, reassign the beforeState\r\n                    this.state = beforeState;\r\n                    // set the afterState as pending state so the change gets picked up below\r\n                    this._pendingSetState = true;\r\n                    this._pendingState = afterState;\r\n                }\r\n            }\r\n            if (this._pendingSetState) {\r\n                nextState = combineFrom(nextState, this._pendingState);\r\n                this._pendingSetState = false;\r\n                this._pendingState = null;\r\n            }\r\n        }\r\n        /* Update if scu is not defined, or it returns truthy value or force */\r\n        if (force ||\r\n            isNullOrUndef(this.shouldComponentUpdate) ||\r\n            (this.shouldComponentUpdate &&\r\n                this.shouldComponentUpdate(nextProps, nextState, context))) {\r\n            if (!isNullOrUndef(this.componentWillUpdate)) {\r\n                this._blockSetState = true;\r\n                this.componentWillUpdate(nextProps, nextState, context);\r\n                this._blockSetState = false;\r\n            }\r\n            this.props = nextProps;\r\n            this.state = nextState;\r\n            this.context = context;\r\n            if (inferno.options.beforeRender) {\r\n                inferno.options.beforeRender(this);\r\n            }\r\n            var render = this.render(nextProps, nextState, context);\r\n            if (inferno.options.afterRender) {\r\n                inferno.options.afterRender(this);\r\n            }\r\n            return render;\r\n        }\r\n        else {\r\n            this.props = nextProps;\r\n            this.state = nextState;\r\n            this.context = context;\r\n        }\r\n    }\r\n    return NO_OP;\r\n};\r\n// tslint:disable-next-line:no-empty\r\nComponent.prototype.render = function render (nextProps, nextState, nextContext) { };\n\nexports['default'] = Component;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_inferno-component@3.7.1@inferno-component/dist/index.js\n// module id = 15\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar hoistStatics = _interopDefault(require('hoist-non-inferno-statics'));\nvar Component = _interopDefault(require('inferno-component'));\nvar createElement = _interopDefault(require('inferno-create-element'));\nvar redux = require('redux');\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\n\r\n\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) { if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        { t[p] = s[p]; } }\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        { for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) { if (e.indexOf(p[i]) < 0)\r\n            { t[p[i]] = s[p[i]]; } } }\r\n    return t;\r\n}\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar CLEARED = null;\r\n// tslint:disable-next-line:no-empty\r\nvar nullSubscriptionHandler = function () { };\r\nvar nullListenerCollection = {\r\n    // tslint:disable-next-line:no-empty\r\n    clear: function () { },\r\n    // tslint:disable-next-line:no-empty\r\n    notify: function () { },\r\n    subscribe: function (_) { return nullSubscriptionHandler; }\r\n};\r\nvar createListenerCollection = function () {\r\n    // the current/next pattern is copied from redux's createStore code.\r\n    var current = [];\r\n    var next = [];\r\n    return {\r\n        clear: function () {\r\n            next = CLEARED;\r\n            current = CLEARED;\r\n        },\r\n        notify: function () {\r\n            var listeners = (current = next);\r\n            for (var i = 0; i < listeners.length; i++) {\r\n                listeners[i]();\r\n            }\r\n        },\r\n        subscribe: function (listener) {\r\n            var isSubscribed = true;\r\n            if (next === current) {\r\n                next = current.slice();\r\n            }\r\n            next.push(listener);\r\n            var unsubscribe = function () {\r\n                if (!isSubscribed || current === null) {\r\n                    return;\r\n                }\r\n                isSubscribed = false;\r\n                if (next === current) {\r\n                    next = current.slice();\r\n                }\r\n                next.splice(next.indexOf(listener), 1);\r\n            };\r\n            return unsubscribe;\r\n        }\r\n    };\r\n};\r\nvar Subscription = function Subscription(store, parentSub, onStateChange) {\r\n    this.store = store;\r\n    this.parentSub = parentSub;\r\n    this.onStateChange = onStateChange;\r\n    this.unsubscribe = null;\r\n    this.listeners = nullListenerCollection;\r\n};\r\nSubscription.prototype.addNestedSub = function addNestedSub (listener) {\r\n    this.trySubscribe();\r\n    return this.listeners.subscribe(listener);\r\n};\r\nSubscription.prototype.notifyNestedSubs = function notifyNestedSubs () {\r\n    this.listeners.notify();\r\n};\r\nSubscription.prototype.isSubscribed = function isSubscribed () {\r\n    return Boolean(this.unsubscribe);\r\n};\r\nSubscription.prototype.trySubscribe = function trySubscribe () {\r\n    if (!this.unsubscribe) {\r\n        this.unsubscribe = this.parentSub\r\n            ? this.parentSub.addNestedSub(this.onStateChange)\r\n            : this.store.subscribe(this.onStateChange);\r\n        this.listeners = createListenerCollection();\r\n    }\r\n};\r\nSubscription.prototype.tryUnsubscribe = function tryUnsubscribe () {\r\n    if (this.unsubscribe) {\r\n        this.unsubscribe();\r\n        this.unsubscribe = null;\r\n        this.listeners.clear();\r\n        this.listeners = nullListenerCollection;\r\n    }\r\n};\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar hotReloadingVersion = 0;\r\nvar dummyState = {};\r\n// tslint:disable-next-line:no-empty\r\nvar noop = function () { };\r\nvar makeSelectorStateful = function (sourceSelector, store) {\r\n    // wrap the selector in an object that tracks its results between runs.\r\n    var selector = {\r\n        error: null,\r\n        props: {},\r\n        run: function runComponentSelector(props) {\r\n            try {\r\n                var nextProps = sourceSelector(store.getState(), props);\r\n                if (nextProps !== selector.props || selector.error) {\r\n                    selector.shouldComponentUpdate = true;\r\n                    selector.props = nextProps;\r\n                    selector.error = null;\r\n                }\r\n            }\r\n            catch (e) {\r\n                selector.shouldComponentUpdate = true;\r\n                selector.error = e;\r\n            }\r\n        },\r\n        shouldComponentUpdate: false\r\n    };\r\n    return selector;\r\n};\r\n// TODO: Move\r\nvar invariant = function (test, error) {\r\n    if (!test) {\r\n        throw new Error(error);\r\n    }\r\n};\r\nfunction getDefaultName(name) {\r\n    return (\"ConnectAdvanced(\" + name + \")\");\r\n}\r\nfunction connectAdvanced(selectorFactory, _a) {\r\n    var getDisplayName = _a.getDisplayName; if ( getDisplayName === void 0 ) getDisplayName = getDefaultName;\n    var methodName = _a.methodName; if ( methodName === void 0 ) methodName = \"connectAdvanced\";\n    var renderCountProp = _a.renderCountProp; if ( renderCountProp === void 0 ) renderCountProp = null;\n    var shouldHandleStateChanges = _a.shouldHandleStateChanges; if ( shouldHandleStateChanges === void 0 ) shouldHandleStateChanges = true;\n    var storeKey = _a.storeKey; if ( storeKey === void 0 ) storeKey = \"store\";\n    var withRef = _a.withRef; if ( withRef === void 0 ) withRef = false;\n    var connectOptions = __rest(_a, [\"getDisplayName\", \"methodName\", \"renderCountProp\", \"shouldHandleStateChanges\", \"storeKey\", \"withRef\"]);\r\n    var subscriptionKey = storeKey + \"Subscription\";\r\n    var version = hotReloadingVersion++;\r\n    var wrapWithConnect = function (WrappedComponent) {\r\n        invariant(typeof WrappedComponent === \"function\", \"You must pass a component to the function returned by \" +\r\n            \"connect. Instead received \" + WrappedComponent);\r\n        var wrappedComponentName = WrappedComponent.displayName ||\r\n            WrappedComponent.name ||\r\n            \"Component\";\r\n        var displayName = getDisplayName(wrappedComponentName);\r\n        var selectorFactoryOptions = Object.assign({}, connectOptions, { WrappedComponent: WrappedComponent,\r\n            displayName: displayName,\r\n            getDisplayName: getDisplayName,\r\n            methodName: methodName,\r\n            renderCountProp: renderCountProp,\r\n            shouldHandleStateChanges: shouldHandleStateChanges,\r\n            storeKey: storeKey,\r\n            withRef: withRef,\r\n            wrappedComponentName: wrappedComponentName });\r\n        var Connect = (function (Component$$1) {\n            function Connect(props, context) {\r\n                Component$$1.call(this, props, context);\r\n                this.version = version;\r\n                this.state = {};\r\n                this.renderCount = 0;\r\n                this.store = this.props[storeKey] || this.context[storeKey];\r\n                this.propsMode = Boolean(props[storeKey]);\r\n                this.setWrappedInstance = this.setWrappedInstance.bind(this);\r\n                invariant(!!this.store, \"Could not find \\\"\" + storeKey + \"\\\" in either the context or \" +\r\n                    \"props of \\\"\" + displayName + \"\\\". \" +\r\n                    \"Either wrap the root component in a <Provider>, \" +\r\n                    \"or explicitly pass \\\"\" + storeKey + \"\\\" as a prop to \\\"\" + displayName + \"\\\".\");\r\n                this.initSelector();\r\n                this.initSubscription();\r\n            }\n\n            if ( Component$$1 ) Connect.__proto__ = Component$$1;\n            Connect.prototype = Object.create( Component$$1 && Component$$1.prototype );\n            Connect.prototype.constructor = Connect;\r\n            Connect.prototype.getChildContext = function getChildContext () {\r\n                // If this component received store from props, its subscription should be transparent\r\n                // to any descendants receiving store+subscription from context; it passes along\r\n                // subscription passed to it. Otherwise, it shadows the parent subscription, which allows\r\n                // Connect to control ordering of notifications to flow top-down.\r\n                var subscription = this.propsMode ? null : this.subscription;\r\n                return ( obj = {}, obj[subscriptionKey] = subscription || this.context[subscriptionKey], obj );\n                var obj;\r\n            };\r\n            Connect.prototype.componentDidMount = function componentDidMount () {\r\n                if (!shouldHandleStateChanges) {\r\n                    return;\r\n                }\r\n                // componentWillMount fires during server side rendering, but componentDidMount and\r\n                // componentWillUnmount do not. Because of this, trySubscribe happens during ...didMount.\r\n                // Otherwise, unsubscription would never take place during SSR, causing a memory leak.\r\n                // To handle the case where a child component may have triggered a state change by\r\n                // dispatching an action in its componentWillMount, we have to re-run the select and maybe\r\n                // re-render.\r\n                this.subscription.trySubscribe();\r\n                this.selector.run(this.props);\r\n                if (this.selector.shouldComponentUpdate) {\r\n                    this.forceUpdate();\r\n                }\r\n            };\r\n            Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps (nextProps) {\r\n                this.selector.run(nextProps);\r\n            };\r\n            Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate () {\r\n                return this.selector.shouldComponentUpdate;\r\n            };\r\n            Connect.prototype.componentWillUnmount = function componentWillUnmount () {\r\n                if (this.subscription) {\r\n                    this.subscription.tryUnsubscribe();\r\n                }\r\n                // these are just to guard against extra memory leakage if a parent element doesn't\r\n                // dereference this instance properly, such as an async callback that never finishes\r\n                this.subscription = null;\r\n                this.notifyNestedSubs = noop;\r\n                this.store = null;\r\n                this.selector.run = noop;\r\n                this.selector.shouldComponentUpdate = false;\r\n            };\r\n            Connect.prototype.getWrappedInstance = function getWrappedInstance () {\r\n                invariant(withRef, \"To access the wrapped instance, you need to specify \" +\r\n                    \"{ withRef: true } in the options argument of the \" + methodName + \"() call.\");\r\n                return this.wrappedInstance;\r\n            };\r\n            Connect.prototype.setWrappedInstance = function setWrappedInstance (ref) {\r\n                this.wrappedInstance = ref;\r\n            };\r\n            Connect.prototype.initSelector = function initSelector () {\r\n                var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);\r\n                this.selector = makeSelectorStateful(sourceSelector, this.store);\r\n                this.selector.run(this.props);\r\n            };\r\n            Connect.prototype.initSubscription = function initSubscription () {\r\n                if (!shouldHandleStateChanges) {\r\n                    return;\r\n                }\r\n                // parentSub's source should match where store came from: props vs. context. A component\r\n                // connected to the store via props shouldn't use subscription from context, or vice versa.\r\n                var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];\r\n                this.subscription = new Subscription(this.store, parentSub, this.onStateChange.bind(this));\r\n                // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in\r\n                // the middle of the notification loop, where `this.subscription` will then be null. An\r\n                // extra null check every change can be avoided by copying the method onto `this` and then\r\n                // replacing it with a no-op on unmount. This can probably be avoided if Subscription's\r\n                // listeners logic is changed to not call listeners that have been unsubscribed in the\r\n                // middle of the notification loop.\r\n                this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);\r\n            };\r\n            Connect.prototype.onStateChange = function onStateChange () {\r\n                this.selector.run(this.props);\r\n                if (!this.selector.shouldComponentUpdate) {\r\n                    this.notifyNestedSubs();\r\n                }\r\n                else {\r\n                    this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;\r\n                    this.setState(dummyState);\r\n                }\r\n            };\r\n            Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate () {\r\n                // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it\r\n                // needs to notify nested subs. Once called, it unimplements itself until further state\r\n                // changes occur. Doing it this way vs having a permanent `componentDidMount` that does\r\n                // a boolean check every time avoids an extra method call most of the time, resulting\r\n                // in some perf boost.\r\n                this.componentDidUpdate = undefined;\r\n                this.notifyNestedSubs();\r\n            };\r\n            Connect.prototype.isSubscribed = function isSubscribed () {\r\n                return Boolean(this.subscription && this.subscription.isSubscribed());\r\n            };\r\n            Connect.prototype.addExtraProps = function addExtraProps (props) {\r\n                if (!withRef && !renderCountProp) {\r\n                    return props;\r\n                }\r\n                // make a shallow copy so that fields added don't leak to the original selector.\r\n                // this is especially important for 'ref' since that's a reference back to the component\r\n                // instance. a singleton memoized selector would then be holding a reference to the\r\n                // instance, preventing the instance from being garbage collected, and that would be bad\r\n                var withExtras = Object.assign({}, props);\r\n                if (withRef) {\r\n                    withExtras.ref = this.setWrappedInstance;\r\n                }\r\n                if (renderCountProp) {\r\n                    withExtras[renderCountProp] = this.renderCount++;\r\n                }\r\n                if (this.propsMode && this.subscription) {\r\n                    withExtras[subscriptionKey] = this.subscription;\r\n                }\r\n                return withExtras;\r\n            };\r\n            Connect.prototype.render = function render () {\r\n                var selector = this.selector;\r\n                selector.shouldComponentUpdate = false;\r\n                if (selector.error) {\r\n                    throw selector.error;\r\n                }\r\n                else {\r\n                    return createElement(WrappedComponent, this.addExtraProps(selector.props));\r\n                }\r\n            };\n\n            return Connect;\n        }(Component));\r\n        Connect.displayName = displayName;\r\n        Connect.WrappedComponent = WrappedComponent;\r\n        if (process.env.NODE_ENV !== \"production\") {\r\n            Connect.prototype.componentWillUpdate = function componentWillUpdate() {\r\n                if (this.version !== version) {\r\n                    // We are hot reloading!\r\n                    this.version = version;\r\n                    this.initSelector();\r\n                    if (this.subscription) {\r\n                        this.subscription.tryUnsubscribe();\r\n                    }\r\n                    this.initSubscription();\r\n                    if (shouldHandleStateChanges) {\r\n                        this.subscription.trySubscribe();\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        return hoistStatics(Connect, WrappedComponent);\r\n    };\r\n    return wrapWithConnect;\r\n}\n\n/**\r\n * @module Inferno-Shared\r\n */ /** TypeDoc Comment */\r\nfunction toArray(children) {\r\n    return isArray(children) ? children : children ? [children] : children;\r\n}\r\n// this is MUCH faster than .constructor === Array and instanceof Array\r\n// in Node 7 and the later versions of V8, slower in older versions though\r\nvar isArray = Array.isArray;\r\nfunction isNullOrUndef(o) {\r\n    return isUndefined(o) || isNull(o);\r\n}\r\nfunction isNull(o) {\r\n    return o === null;\r\n}\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar warning$1 = function (message) {\r\n    if (typeof console !== \"undefined\" && typeof console.error === \"function\") {\r\n        // tslint:disable-next-line:no-console\r\n        console.error(message);\r\n    }\r\n    try {\r\n        // This error was thrown as a convenience so that if you enable\r\n        // \"break on all exceptions\" in your console,\r\n        // it would pause the execution at this line.\r\n        throw new Error(message);\r\n        // tslint:disable-next-line:no-empty\r\n    }\r\n    catch (e) { }\r\n};\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar didWarnAboutReceivingStore = false;\r\nvar warnAboutReceivingStore = function () {\r\n    if (didWarnAboutReceivingStore) {\r\n        return;\r\n    }\r\n    didWarnAboutReceivingStore = true;\r\n    warning$1(\"<Provider> does not support changing `store` on the fly.\");\r\n};\r\nvar Provider = (function (Component$$1) {\n    function Provider(props, context) {\r\n        Component$$1.call(this, props, context);\r\n        this.store = props.store;\r\n    }\n\n    if ( Component$$1 ) Provider.__proto__ = Component$$1;\n    Provider.prototype = Object.create( Component$$1 && Component$$1.prototype );\n    Provider.prototype.constructor = Provider;\r\n    Provider.prototype.getChildContext = function getChildContext () {\r\n        return { store: this.store, storeSubscription: null };\r\n    };\r\n    Provider.prototype.render = function render () {\r\n        // TODO: Maybe not allocate an array here for no reason?\r\n        if (isNullOrUndef(this.props.children) ||\r\n            toArray(this.props.children).length !== 1) {\r\n            throw Error(\"Inferno Error: Only one child is allowed within the `Provider` component\");\r\n        }\r\n        return this.props.children;\r\n    };\n\n    return Provider;\n}(Component));\r\nProvider.displayName = \"Provider\";\r\nif (process.env.NODE_ENV !== \"production\") {\r\n    Provider.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\r\n        var ref = this;\n        var store = ref.store;\r\n        var nextStore = nextProps.store;\r\n        if (store !== nextStore) {\r\n            warnAboutReceivingStore();\r\n        }\r\n    };\r\n}\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar hasOwn = Object.prototype.hasOwnProperty;\r\nvar shallowEqual = function (a, b) {\r\n    if (a === b) {\r\n        return true;\r\n    }\r\n    var countA = 0;\r\n    var countB = 0;\r\n    for (var key in a) {\r\n        if (hasOwn.call(a, key) && a[key] !== b[key]) {\r\n            return false;\r\n        }\r\n        countA++;\r\n    }\r\n    for (var key$1 in b) {\r\n        if (hasOwn.call(b, key$1)) {\r\n            countB++;\r\n        }\r\n    }\r\n    return countA === countB;\r\n};\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol$1 = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty$1 = objectProto$1.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto$1.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty$1.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto$2 = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$2.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString$1.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]';\nvar undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype;\nvar objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar verifyPlainObject = function (value, displayName, methodName) {\r\n    if (!isPlainObject(value)) {\r\n        warning$1((methodName + \"() in \" + displayName + \" must return a plain object. Instead received \" + value + \".\"));\r\n    }\r\n};\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\n// TODO: Type\r\nvar wrapMapToPropsConstant = function (getConstant) {\r\n    var initConstantSelector = function (dispatch, options) {\r\n        var constant = getConstant(dispatch, options);\r\n        var constantSelector = function () { return constant; };\r\n        constantSelector.dependsOnOwnProps = false;\r\n        return constantSelector;\r\n    };\r\n    return initConstantSelector;\r\n};\r\n// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args\r\n// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine\r\n// whether mapToProps needs to be invoked when props have changed.\r\n//\r\n// A length of one signals that mapToProps does not depend on props from the parent component.\r\n// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and\r\n// therefore not reporting its length accurately..\r\nvar getDependsOnOwnProps = function (mapToProps) { return mapToProps.dependsOnOwnProps !== null &&\r\n    mapToProps.dependsOnOwnProps !== undefined\r\n    ? !!mapToProps.dependsOnOwnProps\r\n    : mapToProps.length !== 1; };\r\n// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,\r\n// this function wraps mapToProps in a proxy function which does several things:\r\n//\r\n//  * Detects whether the mapToProps function being called depends on props, which\r\n//    is used by selectorFactory to decide if it should reinvoke on props changes.\r\n//\r\n//  * On first call, handles mapToProps if returns another function, and treats that\r\n//    new function as the true mapToProps for subsequent calls.\r\n//\r\n//  * On first call, verifies the first result is a plain object, in order to warn\r\n//    the developer that their mapToProps function is not returning a valid result.\r\n//\r\nvar wrapMapToPropsFunc = function (mapToProps, methodName) {\r\n    var initProxySelector = function (dispatch, ref) {\n        var displayName = ref.displayName;\n\r\n        var proxy = function (stateOrDispatch, ownProps) { return proxy.dependsOnOwnProps\r\n            ? proxy.mapToProps(stateOrDispatch, ownProps)\r\n            : proxy.mapToProps(stateOrDispatch); };\r\n        proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);\r\n        proxy.mapToProps = function (stateOrDispatch, ownProps) {\r\n            proxy.mapToProps = mapToProps;\r\n            var props = proxy(stateOrDispatch, ownProps);\r\n            if (typeof props === \"function\") {\r\n                proxy.mapToProps = props;\r\n                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);\r\n                props = proxy(stateOrDispatch, ownProps);\r\n            }\r\n            if (process.env.NODE_ENV !== \"production\") {\r\n                verifyPlainObject(props, displayName, methodName);\r\n            }\r\n            return props;\r\n        };\r\n        return proxy;\r\n    };\r\n    return initProxySelector;\r\n};\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar whenMapDispatchToPropsIsFunction = function (mapDispatchToProps) { return typeof mapDispatchToProps === \"function\"\r\n    ? wrapMapToPropsFunc(mapDispatchToProps, \"mapDispatchToProps\")\r\n    : undefined; };\r\nvar whenMapDispatchToPropsIsMissing = function (mapDispatchToProps) { return !mapDispatchToProps\r\n    ? wrapMapToPropsConstant((function (dispatch) { return ({ dispatch: dispatch }); }))\r\n    : undefined; };\r\nvar whenMapDispatchToPropsIsObject = function (mapDispatchToProps) { return mapDispatchToProps && typeof mapDispatchToProps === \"object\"\r\n    ? wrapMapToPropsConstant((function (dispatch) { return redux.bindActionCreators(mapDispatchToProps, dispatch); }))\r\n    : undefined; };\r\nvar defaultMapDispatchToPropsFactories = [\r\n    whenMapDispatchToPropsIsFunction,\r\n    whenMapDispatchToPropsIsMissing,\r\n    whenMapDispatchToPropsIsObject\r\n];\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar whenMapStateToPropsIsFunction = function (mapStateToProps) { return typeof mapStateToProps === \"function\"\r\n    ? wrapMapToPropsFunc(mapStateToProps, \"mapStateToProps\")\r\n    : undefined; };\r\nvar whenMapStateToPropsIsMissing = function (mapStateToProps) { return !mapStateToProps ? wrapMapToPropsConstant((function () { return ({}); })) : undefined; };\r\nvar defaultMapStateToPropsFactories = [\r\n    whenMapStateToPropsIsFunction,\r\n    whenMapStateToPropsIsMissing\r\n];\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar defaultMergeProps = function (stateProps, dispatchProps, ownProps) { return (Object.assign({}, ownProps, stateProps, dispatchProps)); };\r\nvar wrapMergePropsFunc = function (mergeProps) {\r\n    var initMergePropsProxy = function (dispatch, ref) {\n        var displayName = ref.displayName;\n        var pure = ref.pure;\n        var areMergedPropsEqual = ref.areMergedPropsEqual;\n\r\n        var hasRunOnce = false;\r\n        var mergedProps;\r\n        var mergePropsProxy = function (stateProps, dispatchProps, ownProps) {\r\n            var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n            if (hasRunOnce) {\r\n                if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) {\r\n                    mergedProps = nextMergedProps;\r\n                }\r\n            }\r\n            else {\r\n                hasRunOnce = true;\r\n                mergedProps = nextMergedProps;\r\n                if (process.env.NODE_ENV !== \"production\") {\r\n                    verifyPlainObject(mergedProps, displayName, \"mergeProps\");\r\n                }\r\n            }\r\n            return mergedProps;\r\n        };\r\n        return mergePropsProxy;\r\n    };\r\n    return initMergePropsProxy;\r\n};\r\nvar whenMergePropsIsFunction = function (mergeProps) { return typeof mergeProps === \"function\" ? wrapMergePropsFunc(mergeProps) : undefined; };\r\nvar whenMergePropsIsOmitted = function (mergeProps) { return !mergeProps ? function () { return defaultMergeProps; } : undefined; };\r\nvar defaultMergePropsFactories = [\r\n    whenMergePropsIsFunction,\r\n    whenMergePropsIsOmitted\r\n];\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar verify = function (selector, methodName, displayName) {\r\n    if (!selector) {\r\n        throw new Error((\"Unexpected value for \" + methodName + \" in \" + displayName + \".\"));\r\n    }\r\n    if (methodName === \"mapStateToProps\" || methodName === \"mapDispatchToProps\") {\r\n        if (!selector.hasOwnProperty(\"dependsOnOwnProps\")) {\r\n            warning$1((\"The selector for \" + methodName + \" of \" + displayName + \" did not specify a value for dependsOnOwnProps.\"));\r\n        }\r\n    }\r\n};\r\nvar verifySubselectors = function (mapStateToProps, mapDispatchToProps, mergeProps, displayName) {\r\n    verify(mapStateToProps, \"mapStateToProps\", displayName);\r\n    verify(mapDispatchToProps, \"mapDispatchToProps\", displayName);\r\n    verify(mergeProps, \"mergeProps\", displayName);\r\n};\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar impureFinalPropsSelectorFactory = function (mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {\r\n    var impureFinalPropsSelector = function (state, ownProps) {\r\n        return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);\r\n    };\r\n    return impureFinalPropsSelector;\r\n};\r\nvar pureFinalPropsSelectorFactory = function (mapStateToProps, mapDispatchToProps, mergeProps, dispatch, ref) {\n    var areStatesEqual = ref.areStatesEqual;\n    var areOwnPropsEqual = ref.areOwnPropsEqual;\n    var areStatePropsEqual = ref.areStatePropsEqual;\n\r\n    var hasRunAtLeastOnce = false;\r\n    var state;\r\n    var ownProps;\r\n    var stateProps;\r\n    var dispatchProps;\r\n    var mergedProps;\r\n    var handleFirstCall = function (firstState, firstOwnProps) {\r\n        state = firstState;\r\n        ownProps = firstOwnProps;\r\n        stateProps = mapStateToProps(state, ownProps);\r\n        dispatchProps = mapDispatchToProps(dispatch, ownProps);\r\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n        hasRunAtLeastOnce = true;\r\n        return mergedProps;\r\n    };\r\n    var handleNewPropsAndNewState = function () {\r\n        stateProps = mapStateToProps(state, ownProps);\r\n        if (mapDispatchToProps.dependsOnOwnProps) {\r\n            dispatchProps = mapDispatchToProps(dispatch, ownProps);\r\n        }\r\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n        return mergedProps;\r\n    };\r\n    var handleNewProps = function () {\r\n        if (mapStateToProps.dependsOnOwnProps) {\r\n            stateProps = mapStateToProps(state, ownProps);\r\n        }\r\n        if (mapDispatchToProps.dependsOnOwnProps) {\r\n            dispatchProps = mapDispatchToProps(dispatch, ownProps);\r\n        }\r\n        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n        return mergedProps;\r\n    };\r\n    var handleNewState = function () {\r\n        var nextStateProps = mapStateToProps(state, ownProps);\r\n        var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);\r\n        stateProps = nextStateProps;\r\n        if (statePropsChanged) {\r\n            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);\r\n        }\r\n        return mergedProps;\r\n    };\r\n    var handleSubsequentCalls = function (nextState, nextOwnProps) {\r\n        var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);\r\n        var stateChanged = !areStatesEqual(nextState, state);\r\n        state = nextState;\r\n        ownProps = nextOwnProps;\r\n        if (propsChanged && stateChanged) {\r\n            return handleNewPropsAndNewState();\r\n        }\r\n        if (propsChanged) {\r\n            return handleNewProps();\r\n        }\r\n        if (stateChanged) {\r\n            return handleNewState();\r\n        }\r\n        return mergedProps;\r\n    };\r\n    var pureFinalPropsSelector = function (nextState, nextOwnProps) { return hasRunAtLeastOnce\r\n        ? handleSubsequentCalls(nextState, nextOwnProps)\r\n        : handleFirstCall(nextState, nextOwnProps); };\r\n    return pureFinalPropsSelector;\r\n};\r\n// If pure is true, the selector returned by selectorFactory will memoize its results,\r\n// allowing connectAdvanced's shouldComponentUpdate to return false if final\r\n// props have not changed. If false, the selector will always return a new\r\n// object and shouldComponentUpdate will always return true.\r\nvar defaultSelectorFactory = function (dispatch, _a) {\r\n    var initMapStateToProps = _a.initMapStateToProps;\n    var initMapDispatchToProps = _a.initMapDispatchToProps;\n    var initMergeProps = _a.initMergeProps;\n    var opts = __rest(_a, [\"initMapStateToProps\", \"initMapDispatchToProps\", \"initMergeProps\"]);\r\n    var options = opts; // trick typescript\r\n    var mapStateToProps = initMapStateToProps(dispatch, options);\r\n    var mapDispatchToProps = initMapDispatchToProps(dispatch, options);\r\n    var mergeProps = initMergeProps(dispatch, options);\r\n    if (process.env.NODE_ENV !== \"production\") {\r\n        verifySubselectors(mapStateToProps, mapDispatchToProps, mergeProps, options.displayName);\r\n    }\r\n    var selectorFactory = options.pure\r\n        ? pureFinalPropsSelectorFactory\r\n        : impureFinalPropsSelectorFactory;\r\n    return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);\r\n};\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar match = function (arg, factories, name) {\r\n    for (var i = factories.length - 1; i >= 0; i--) {\r\n        var result = factories[i](arg);\r\n        if (result) {\r\n            return result;\r\n        }\r\n    }\r\n    return function (dispatch, options) {\r\n        throw new Error((\"Invalid value of type \" + (typeof arg) + \" for \" + name + \" argument when connecting component \" + (options\r\n            .wrappedComponentName) + \".\"));\r\n    };\r\n};\r\nvar strictEqual = function (a, b) { return a === b; };\r\n// createConnect with default args builds the 'official' connect behavior. Calling it with\r\n// different options opens up some testing and extensibility scenarios\r\nvar createConnect = function (ref) {\n    if ( ref === void 0 ) ref = {};\n    var connectHOC = ref.connectHOC; if ( connectHOC === void 0 ) connectHOC = connectAdvanced;\n    var mapStateToPropsFactories = ref.mapStateToPropsFactories; if ( mapStateToPropsFactories === void 0 ) mapStateToPropsFactories = defaultMapStateToPropsFactories;\n    var mapDispatchToPropsFactories = ref.mapDispatchToPropsFactories; if ( mapDispatchToPropsFactories === void 0 ) mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories;\n    var mergePropsFactories = ref.mergePropsFactories; if ( mergePropsFactories === void 0 ) mergePropsFactories = defaultMergePropsFactories;\n    var selectorFactory = ref.selectorFactory; if ( selectorFactory === void 0 ) selectorFactory = defaultSelectorFactory;\n\n    return function (mapStateToProps, mapDispatchToProps, mergeProps, _a) {\n    if ( _a === void 0 ) _a = {};\n\r\n    var pure = _a.pure; if ( pure === void 0 ) pure = true;\n    var areStatesEqual = _a.areStatesEqual; if ( areStatesEqual === void 0 ) areStatesEqual = strictEqual;\n    var areOwnPropsEqual = _a.areOwnPropsEqual; if ( areOwnPropsEqual === void 0 ) areOwnPropsEqual = shallowEqual;\n    var areStatePropsEqual = _a.areStatePropsEqual; if ( areStatePropsEqual === void 0 ) areStatePropsEqual = shallowEqual;\n    var areMergedPropsEqual = _a.areMergedPropsEqual; if ( areMergedPropsEqual === void 0 ) areMergedPropsEqual = shallowEqual;\n    var extraOptions = __rest(_a, [\"pure\", \"areStatesEqual\", \"areOwnPropsEqual\", \"areStatePropsEqual\", \"areMergedPropsEqual\"]);\r\n    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, \"mapStateToProps\");\r\n    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, \"mapDispatchToProps\");\r\n    var initMergeProps = match(mergeProps, mergePropsFactories, \"mergeProps\");\r\n    return connectHOC(selectorFactory, Object.assign({ \r\n        // used in error messages\r\n        methodName: \"connect\", \r\n        // used to compute Connect's displayName from the wrapped component's displayName.\r\n        // tslint:disable-next-line:object-literal-sort-keys\r\n        getDisplayName: function (name) { return (\"Connect(\" + name + \")\"); }, \r\n        // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes\r\n        shouldHandleStateChanges: !!mapStateToProps, \r\n        // passed through to selectorFactory\r\n        initMapStateToProps: initMapStateToProps,\r\n        initMapDispatchToProps: initMapDispatchToProps,\r\n        initMergeProps: initMergeProps,\r\n        pure: pure,\r\n        areStatesEqual: areStatesEqual,\r\n        areOwnPropsEqual: areOwnPropsEqual,\r\n        areStatePropsEqual: areStatePropsEqual,\r\n        areMergedPropsEqual: areMergedPropsEqual }, extraOptions));\r\n};\n};\r\nvar connect = createConnect();\n\n/**\r\n * @module Inferno-Redux\r\n */ /** TypeDoc Comment */\r\nvar index = { Provider: Provider, connectAdvanced: connectAdvanced, connect: connect };\n\nexports.Provider = Provider;\nexports.connectAdvanced = connectAdvanced;\nexports.connect = connect;\nexports['default'] = index;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_inferno-redux@3.7.1@inferno-redux/dist/index.js\n// module id = 16\n// module chunks = 0","'use strict';\n\nvar INFERNO_STATICS = {\n    childContextTypes: true,\n    contextTypes: true,\n    defaultProps: true,\n    displayName: true,\n    getDefaultProps: true,\n    propTypes: true,\n    type: true\n};\n\nvar KNOWN_STATICS = {\n    name: true,\n    length: true,\n    prototype: true,\n    caller: true,\n    arguments: true,\n    arity: true\n};\n\nvar isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';\n\nfunction hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {\n    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components\n        var keys = Object.getOwnPropertyNames(sourceComponent);\n\n        /* istanbul ignore else */\n        if (isGetOwnPropertySymbolsAvailable) {\n            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));\n        }\n\n        for (var i = 0; i < keys.length; ++i) {\n            if (!INFERNO_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {\n                try {\n                    targetComponent[keys[i]] = sourceComponent[keys[i]];\n                } catch (error) {\n\n                }\n            }\n        }\n    }\n\n    return targetComponent;\n};\n\nmodule.exports = hoistNonReactStatics;\nmodule.exports.default = module.exports;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_hoist-non-inferno-statics@1.1.3@hoist-non-inferno-statics/index.js\n// module id = 17\n// module chunks = 0","module.exports = require('./dist').default;\nmodule.exports.default = module.exports;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_inferno-create-element@3.7.1@inferno-create-element/index.js\n// module id = 18\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar inferno = require('inferno');\n\n/**\r\n * @module Inferno-Shared\r\n */ /** TypeDoc Comment */\r\nfunction isNullOrUndef(o) {\r\n    return isUndefined(o) || isNull(o);\r\n}\r\nfunction isInvalid(o) {\r\n    return isNull(o) || o === false || isTrue(o) || isUndefined(o);\r\n}\r\nfunction isString(o) {\r\n    return typeof o === \"string\";\r\n}\r\nfunction isNull(o) {\r\n    return o === null;\r\n}\r\nfunction isTrue(o) {\r\n    return o === true;\r\n}\r\nfunction isUndefined(o) {\r\n    return o === void 0;\r\n}\r\nfunction isObject(o) {\r\n    return typeof o === \"object\";\r\n}\n\n/**\r\n * @module Inferno-Create-Element\r\n */ /** TypeDoc Comment */\r\nvar componentHooks = new Set();\r\ncomponentHooks.add(\"onComponentWillMount\");\r\ncomponentHooks.add(\"onComponentDidMount\");\r\ncomponentHooks.add(\"onComponentWillUnmount\");\r\ncomponentHooks.add(\"onComponentShouldUpdate\");\r\ncomponentHooks.add(\"onComponentWillUpdate\");\r\ncomponentHooks.add(\"onComponentDidUpdate\");\r\n/**\r\n * Creates virtual node\r\n * @param {string|Function|Component<any, any>} type Type of node\r\n * @param {object=} props Optional props for virtual node\r\n * @param {...{object}=} _children Optional children for virtual node\r\n * @returns {VNode} new virtual ndoe\r\n */\r\nfunction createElement(type, props) {\n    var _children = [], len = arguments.length - 2;\n    while ( len-- > 0 ) _children[ len ] = arguments[ len + 2 ];\n\r\n    if (isInvalid(type) || isObject(type)) {\r\n        throw new Error(\"Inferno Error: createElement() name parameter cannot be undefined, null, false or true, It must be a string, class or function.\");\r\n    }\r\n    var children = _children;\r\n    var ref = null;\r\n    var key = null;\r\n    var className = null;\r\n    var flags = 0;\r\n    var newProps;\r\n    if (_children) {\r\n        if (_children.length === 1) {\r\n            children = _children[0];\r\n        }\r\n        else if (_children.length === 0) {\r\n            children = void 0;\r\n        }\r\n    }\r\n    if (isString(type)) {\r\n        flags = inferno.getFlagsForElementVnode(type);\r\n        if (!isNullOrUndef(props)) {\r\n            newProps = {};\r\n            for (var prop in props) {\r\n                if (prop === \"className\" || prop === \"class\") {\r\n                    className = props[prop];\r\n                }\r\n                else if (prop === \"key\") {\r\n                    key = props.key;\r\n                }\r\n                else if (prop === \"children\" && isUndefined(children)) {\r\n                    children = props.children; // always favour children args, default to props\r\n                }\r\n                else if (prop === \"ref\") {\r\n                    ref = props.ref;\r\n                }\r\n                else {\r\n                    newProps[prop] = props[prop];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        flags = 16 /* ComponentUnknown */;\r\n        if (!isUndefined(children)) {\r\n            if (!props) {\r\n                props = {};\r\n            }\r\n            props.children = children;\r\n            children = null;\r\n        }\r\n        if (!isNullOrUndef(props)) {\r\n            newProps = {};\r\n            for (var prop$1 in props) {\r\n                if (componentHooks.has(prop$1)) {\r\n                    if (!ref) {\r\n                        ref = {};\r\n                    }\r\n                    ref[prop$1] = props[prop$1];\r\n                }\r\n                else if (prop$1 === \"key\") {\r\n                    key = props.key;\r\n                }\r\n                else {\r\n                    newProps[prop$1] = props[prop$1];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return inferno.createVNode(flags, type, className, children, newProps, key, ref);\r\n}\n\nexports['default'] = createElement;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_inferno-create-element@3.7.1@inferno-create-element/dist/index.js\n// module id = 19\n// module chunks = 0","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_lodash-es@4.17.4@lodash-es/_baseGetTag.js\n// module id = 20\n// module chunks = 0","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_lodash-es@4.17.4@lodash-es/_root.js\n// module id = 21\n// module chunks = 0","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_lodash-es@4.17.4@lodash-es/_freeGlobal.js\n// module id = 22\n// module chunks = 0","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_lodash-es@4.17.4@lodash-es/_getRawTag.js\n// module id = 23\n// module chunks = 0","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_lodash-es@4.17.4@lodash-es/_objectToString.js\n// module id = 24\n// module chunks = 0","import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_lodash-es@4.17.4@lodash-es/_getPrototype.js\n// module id = 25\n// module chunks = 0","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_lodash-es@4.17.4@lodash-es/_overArg.js\n// module id = 26\n// module chunks = 0","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_lodash-es@4.17.4@lodash-es/isObjectLike.js\n// module id = 27\n// module chunks = 0","module.exports = require('./lib/index');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_symbol-observable@1.0.4@symbol-observable/index.js\n// module id = 28\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _ponyfill = require('./ponyfill');\n\nvar _ponyfill2 = _interopRequireDefault(_ponyfill);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nvar root; /* global window */\n\n\nif (typeof self !== 'undefined') {\n  root = self;\n} else if (typeof window !== 'undefined') {\n  root = window;\n} else if (typeof global !== 'undefined') {\n  root = global;\n} else if (typeof module !== 'undefined') {\n  root = module;\n} else {\n  root = Function('return this')();\n}\n\nvar result = (0, _ponyfill2['default'])(root);\nexports['default'] = result;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_symbol-observable@1.0.4@symbol-observable/lib/index.js\n// module id = 29\n// module chunks = 0","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 30\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports['default'] = symbolObservablePonyfill;\nfunction symbolObservablePonyfill(root) {\n\tvar result;\n\tvar _Symbol = root.Symbol;\n\n\tif (typeof _Symbol === 'function') {\n\t\tif (_Symbol.observable) {\n\t\t\tresult = _Symbol.observable;\n\t\t} else {\n\t\t\tresult = _Symbol('observable');\n\t\t\t_Symbol.observable = result;\n\t\t}\n\t} else {\n\t\tresult = '@@observable';\n\t}\n\n\treturn result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_symbol-observable@1.0.4@symbol-observable/lib/ponyfill.js\n// module id = 31\n// module chunks = 0","import { ActionTypes } from './createStore';\nimport isPlainObject from 'lodash-es/isPlainObject';\nimport warning from './utils/warning';\n\nfunction getUndefinedStateErrorMessage(key, action) {\n  var actionType = action && action.type;\n  var actionName = actionType && '\"' + actionType.toString() + '\"' || 'an action';\n\n  return 'Given action ' + actionName + ', reducer \"' + key + '\" returned undefined. ' + 'To ignore an action, you must explicitly return the previous state. ' + 'If you want this reducer to hold no value, you can return null instead of undefined.';\n}\n\nfunction getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {\n  var reducerKeys = Object.keys(reducers);\n  var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';\n\n  if (reducerKeys.length === 0) {\n    return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';\n  }\n\n  if (!isPlainObject(inputState)) {\n    return 'The ' + argumentName + ' has unexpected type of \"' + {}.toString.call(inputState).match(/\\s([a-z|A-Z]+)/)[1] + '\". Expected argument to be an object with the following ' + ('keys: \"' + reducerKeys.join('\", \"') + '\"');\n  }\n\n  var unexpectedKeys = Object.keys(inputState).filter(function (key) {\n    return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];\n  });\n\n  unexpectedKeys.forEach(function (key) {\n    unexpectedKeyCache[key] = true;\n  });\n\n  if (unexpectedKeys.length > 0) {\n    return 'Unexpected ' + (unexpectedKeys.length > 1 ? 'keys' : 'key') + ' ' + ('\"' + unexpectedKeys.join('\", \"') + '\" found in ' + argumentName + '. ') + 'Expected to find one of the known reducer keys instead: ' + ('\"' + reducerKeys.join('\", \"') + '\". Unexpected keys will be ignored.');\n  }\n}\n\nfunction assertReducerShape(reducers) {\n  Object.keys(reducers).forEach(function (key) {\n    var reducer = reducers[key];\n    var initialState = reducer(undefined, { type: ActionTypes.INIT });\n\n    if (typeof initialState === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined during initialization. ' + 'If the state passed to the reducer is undefined, you must ' + 'explicitly return the initial state. The initial state may ' + 'not be undefined. If you don\\'t want to set a value for this reducer, ' + 'you can use null instead of undefined.');\n    }\n\n    var type = '@@redux/PROBE_UNKNOWN_ACTION_' + Math.random().toString(36).substring(7).split('').join('.');\n    if (typeof reducer(undefined, { type: type }) === 'undefined') {\n      throw new Error('Reducer \"' + key + '\" returned undefined when probed with a random type. ' + ('Don\\'t try to handle ' + ActionTypes.INIT + ' or other actions in \"redux/*\" ') + 'namespace. They are considered private. Instead, you must return the ' + 'current state for any unknown actions, unless it is undefined, ' + 'in which case you must return the initial state, regardless of the ' + 'action type. The initial state may not be undefined, but can be null.');\n    }\n  });\n}\n\n/**\n * Turns an object whose values are different reducer functions, into a single\n * reducer function. It will call every child reducer, and gather their results\n * into a single state object, whose keys correspond to the keys of the passed\n * reducer functions.\n *\n * @param {Object} reducers An object whose values correspond to different\n * reducer functions that need to be combined into one. One handy way to obtain\n * it is to use ES6 `import * as reducers` syntax. The reducers may never return\n * undefined for any action. Instead, they should return their initial state\n * if the state passed to them was undefined, and the current state for any\n * unrecognized action.\n *\n * @returns {Function} A reducer function that invokes every reducer inside the\n * passed object, and builds a state object with the same shape.\n */\nexport default function combineReducers(reducers) {\n  var reducerKeys = Object.keys(reducers);\n  var finalReducers = {};\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning('No reducer provided for key \"' + key + '\"');\n      }\n    }\n\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers);\n\n  var unexpectedKeyCache = void 0;\n  if (process.env.NODE_ENV !== 'production') {\n    unexpectedKeyCache = {};\n  }\n\n  var shapeAssertionError = void 0;\n  try {\n    assertReducerShape(finalReducers);\n  } catch (e) {\n    shapeAssertionError = e;\n  }\n\n  return function combination() {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var action = arguments[1];\n\n    if (shapeAssertionError) {\n      throw shapeAssertionError;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);\n      if (warningMessage) {\n        warning(warningMessage);\n      }\n    }\n\n    var hasChanged = false;\n    var nextState = {};\n    for (var _i = 0; _i < finalReducerKeys.length; _i++) {\n      var _key = finalReducerKeys[_i];\n      var reducer = finalReducers[_key];\n      var previousStateForKey = state[_key];\n      var nextStateForKey = reducer(previousStateForKey, action);\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(_key, action);\n        throw new Error(errorMessage);\n      }\n      nextState[_key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_redux@3.7.2@redux/es/combineReducers.js\n// module id = 32\n// module chunks = 0","function bindActionCreator(actionCreator, dispatch) {\n  return function () {\n    return dispatch(actionCreator.apply(undefined, arguments));\n  };\n}\n\n/**\n * Turns an object whose values are action creators, into an object with the\n * same keys, but with every function wrapped into a `dispatch` call so they\n * may be invoked directly. This is just a convenience method, as you can call\n * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.\n *\n * For convenience, you can also pass a single function as the first argument,\n * and get a function in return.\n *\n * @param {Function|Object} actionCreators An object whose values are action\n * creator functions. One handy way to obtain it is to use ES6 `import * as`\n * syntax. You may also pass a single function.\n *\n * @param {Function} dispatch The `dispatch` function available on your Redux\n * store.\n *\n * @returns {Function|Object} The object mimicking the original object, but with\n * every action creator wrapped into the `dispatch` call. If you passed a\n * function as `actionCreators`, the return value will also be a single\n * function.\n */\nexport default function bindActionCreators(actionCreators, dispatch) {\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch);\n  }\n\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error('bindActionCreators expected an object or a function, instead received ' + (actionCreators === null ? 'null' : typeof actionCreators) + '. ' + 'Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?');\n  }\n\n  var keys = Object.keys(actionCreators);\n  var boundActionCreators = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var actionCreator = actionCreators[key];\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);\n    }\n  }\n  return boundActionCreators;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_redux@3.7.2@redux/es/bindActionCreators.js\n// module id = 33\n// module chunks = 0","var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport compose from './compose';\n\n/**\n * Creates a store enhancer that applies middleware to the dispatch method\n * of the Redux store. This is handy for a variety of tasks, such as expressing\n * asynchronous actions in a concise manner, or logging every action payload.\n *\n * See `redux-thunk` package as an example of the Redux middleware.\n *\n * Because middleware is potentially asynchronous, this should be the first\n * store enhancer in the composition chain.\n *\n * Note that each middleware will be given the `dispatch` and `getState` functions\n * as named arguments.\n *\n * @param {...Function} middlewares The middleware chain to be applied.\n * @returns {Function} A store enhancer applying the middleware.\n */\nexport default function applyMiddleware() {\n  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {\n    middlewares[_key] = arguments[_key];\n  }\n\n  return function (createStore) {\n    return function (reducer, preloadedState, enhancer) {\n      var store = createStore(reducer, preloadedState, enhancer);\n      var _dispatch = store.dispatch;\n      var chain = [];\n\n      var middlewareAPI = {\n        getState: store.getState,\n        dispatch: function dispatch(action) {\n          return _dispatch(action);\n        }\n      };\n      chain = middlewares.map(function (middleware) {\n        return middleware(middlewareAPI);\n      });\n      _dispatch = compose.apply(undefined, chain)(store.dispatch);\n\n      return _extends({}, store, {\n        dispatch: _dispatch\n      });\n    };\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/_redux@3.7.2@redux/es/applyMiddleware.js\n// module id = 34\n// module chunks = 0","export function getNumber() {\n  const store = getState()\n  return store.foo.number\n}\n\n\nexport function getFontSize() {\n  const store = getState()\n  return store.foo.fontSize\n}\n\n\nfunction getState() {\n  return window.reduxStore.getState()\n}\n\n\n// WEBPACK FOOTER //\n// ./src/InfernoReduxProject/examplePage/selector/index.js","import { createActions } from '../../../share/action/actionCreator'\n\nconst actions = {\n  ADD_FONT_SIZE(value) {\n    return {\n      value\n    }\n  },\n\n  ADD_NUMBER(number) {\n    return {\n      number\n    }\n  },\n\n  REDUCE_FONT_SIZE(value) {\n    return {\n      value\n    }\n  },\n\n  REDUCE_NUMBER(number) {\n    return {\n      number\n    }\n  },\n}\n\n\nexport default createActions(actions)\n\n\n// WEBPACK FOOTER //\n// ./src/InfernoReduxProject/examplePage/action/index.js","export function createActions(actions) {\n  Object.keys(actions).map(key => {\n    const defaultAction = actions[key]\n    actions[key] = createAction(key, defaultAction)\n  })\n  return actions\n}\n\nexport function createAction(name, defaultAction) {\n  return (...arg) => {\n    window.reduxStore.dispatch({\n      type: name,\n      ...defaultAction(...arg)\n    })\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/share/action/actionCreator.js","import { Controller as SuperController } from '../../../share/controller/index.js'\n\n\nexport class Controller extends SuperController {\n  constructor(props) {\n    super(props)\n  }\n}\n\nexport default new Controller()\n\n\n// WEBPACK FOOTER //\n// ./src/InfernoReduxProject/share/controller/index.js","export class Controller {\n\n}\n\nexport default new Controller()\n\n\n// WEBPACK FOOTER //\n// ./src/share/controller/index.js","const defaultState = {\n  foo: {\n    number: 0,\n    fontSize: 20\n  }\n}\n\nexport default function (state = defaultState, action) {\n  return {\n    foo: foo(state.foo, action)\n  }\n}\n\nfunction foo(state, action) {\n  switch (action.type) {\n    case 'ADD_FONT_SIZE':\n      return {\n        ...state,\n        fontSize: state.fontSize + action.value\n      }\n    case 'ADD_NUMBER':\n      return {\n        ...state,\n        number: state.number + action.number\n      }\n    case 'REDUCE_FONT_SIZE':\n      return {\n        ...state,\n        fontSize: state.fontSize - action.value\n      }\n    case 'REDUCE_NUMBER':\n      return {\n        ...state,\n        number: state.number - action.number\n      }\n    default:\n      return state\n  }\n}\n\n\n// WEBPACK FOOTER //\n// ./src/InfernoReduxProject/examplePage/reducer/index.js","export default function middlewareLogger(store) {\n  return next => action => {\n    console.group(action.type)\n    console.info('dispatching', action)\n    let result = next(action)\n    console.log('next state', store.getState())\n    console.groupEnd(action.type)\n    return result\n  }\n} \n\n\n// WEBPACK FOOTER //\n// ./src/InfernoReduxProject/examplePage/util/middlewareLogger.js","import '../../../share/util/fetch'\n\nexport function FETCH_JQUERY() {\n  return fetch('https://code.jquery.com/jquery-3.2.1.min.js')\n}\n\n\n// WEBPACK FOOTER //\n// ./src/InfernoReduxProject/examplePage/model/index.js","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status === undefined ? 200 : options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n// WEBPACK FOOTER //\n// ./src/share/util/fetch.js"],"sourceRoot":""}